<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=0.1, maximum-scale=5.0">
    <title>Shared Weekly Schedule with Firestore</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', 'Roboto', Arial, sans-serif;
            margin: 0;
            background-color: #f0f2f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
        }
        .main-container {
            width: 100%;
            max-width: 1400px;
            background-color: #ffffff;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 6px 20px rgba(0,0,0,0.08);
            box-sizing: border-box;
        }
        h2, h3 {
            color: #1c1e21;
            text-align: center;
            margin-bottom: 20px;
        }
        #scheduleTitle { /* This is "Jadual Anjal" */
            font-size: 2.2em;
            color: #0056b3;
            border-bottom: 2px solid #0056b3;
            padding-bottom: 10px;
        }
        #userIdDisplay {
            text-align: center;
            font-size: 0.9em;
            color: #555;
            margin-bottom: 20px;
            min-height: 1.2em;
        }

        #controlsToggler {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 15px;
            font-size: 1em;
            font-weight: 500;
            border-radius: 6px;
            cursor: pointer;
            border: 1px solid #007bff;
            background-color: #007bff;
            color: white;
            margin-bottom: 15px;
            transition: background-color 0.2s ease, border-color 0.2s ease;
            width: auto;
        }
        #controlsToggler:hover {
            background-color: #0056b3;
            border-color: #0056b3;
        }
        #controlsToggler .toggler-icon {
            transition: transform 0.3s ease-out;
            width: 20px;
            height: 20px;
        }
        #controlsToggler[aria-expanded="false"] .toggler-icon {
            transform: rotate(180deg);
        }
         #controlsToggler[aria-expanded="true"] .toggler-icon {
            transform: rotate(0deg);
        }
        #collapsibleButtonBars {
            max-height: 1000px;
            overflow: hidden;
            transition: max-height 0.4s ease-in-out, margin-top 0.4s ease-in-out, padding-top 0.4s ease-in-out, padding-bottom 0.4s ease-in-out;
            padding-top: 5px;
            padding-bottom: 5px;
        }
        #collapsibleButtonBars:not(.open) {
            max-height: 0;
            padding-top: 0;
            padding-bottom: 0;
            margin-top: 0;
        }

        table {
            border-collapse: collapse;
            width: 100%;
            margin-top: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            background-color: #fff;
            table-layout: auto;
        }
        #tablesContainer, #summaryTableContainer {
            overflow-x: auto;
            position: relative;
            width: 100%;
        }
        #tablesContainer > table {
            display: none;
        }
        #tablesContainer > table.active {
            display: table;
        }
        #summaryTable {
            margin-top: 25px;
        }
        th, td {
            border: 1px solid #dee2e6;
            padding: 12px 15px;
            text-align: center;
            min-width: 100px;
            box-sizing: border-box;
            position: relative;
        }
        table th {
            background-color: #f8f9fa;
            color: #343a40;
            font-weight: 600;
            white-space: nowrap;
        }
        #tablesContainer > table > thead > tr > th {
            font-weight: bold;
            background-color: lightgrey;
            color: #343a40;
        }
        #tablesContainer > table > thead > tr > th:first-child,
        #tablesContainer > table > tbody > tr > td:first-child,
        #tablesContainer > table > tbody > tr > th:first-child {
            font-weight: bold;
            background-color: aliceblue;
            color: #1c1e21;
        }
        #summaryTable > thead > tr > th {
            font-weight: bold;
            background-color: lightgrey;
            color: #212529;
        }
        #summaryTable > thead > tr > th:first-child,
        #summaryTable > tbody > tr > td:first-child {
            font-weight: bold;
            background-color: aliceblue;
            color: #1c1e21;
        }
        td.selected, th.selected {
            outline: 3px solid #007bff;
            background-color: #dbeafe;
        }
        .bar {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
            align-items: center;
            justify-content: center;
        }
        .bar button, .table-tabs button, .name-session-tabs button {
            padding: 10px 18px;
            font-size: 14px;
            border-radius: 6px;
            cursor: pointer;
            border: 1px solid #ced4da;
            background-color: #fff;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 1px 3px rgba(0,0,0,0.06);
            display: inline-flex;
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
        }
        .bar button:hover, .table-tabs button:hover, .name-session-tabs button:hover {
            background-color: #f8f9fa;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }
        .bar button:active, .table-tabs button:active, .name-session-tabs button:active {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        #rowColManipulationBar button {
            background-image: linear-gradient(to bottom, #ffffff 0%, #f1f3f5 100%);
            border: 1px solid #ced4da;
            color: #343a40;
            box-shadow: 0 2px 3px rgba(0,0,0,0.08), inset 0 1px 0 rgba(255,255,255,0.2);
            padding: 8px 14px;
        }
        #rowColManipulationBar button:hover {
            background-image: linear-gradient(to bottom, #e9ecef 0%, #dee2e6 100%);
            border-color: #adb5bd;
            box-shadow: 0 2px 5px rgba(0,0,0,0.12), inset 0 1px 0 rgba(255,255,255,0.1);
        }
         #rowColManipulationBar button.delete-btn {
            background-image: linear-gradient(to bottom, #f8d7da 0%, #f1c6cb 100%);
            border-color: #f5c6cb;
            color: #721c24;
        }
        #rowColManipulationBar button.delete-btn:hover {
            background-image: linear-gradient(to bottom, #f5c6cb 0%, #ebaeb3 100%);
            border-color: #f1b0b7;
        }
        #directCopyFullHtmlBtn { background-color: #545b62; color: white; border-color: #545b62;}
        #excelBtnTrigger, #importExcelBtn { background-color: #28a745; color: white; border-color: #28a745;}
        #saveSharedScheduleBtn { background-color: #007bff; color: white; border-color: #007bff;}
        #loadSharedScheduleBtn { background-color: #ffc107; color: #212529; border-color: #ffc107;}
        #clearActiveTableContentBtn { background-color: #fd7e14; color: white; border-color: #fd7e14;}
        #selectBtn { background-color: #17a2b8; color: white; border-color: #17a2b8;}
        #selectBtn.active { background-color: #fd7e14; border-color: #fd7e14;}
        #mergeBtn { background-color: #6f42c1; color: white; border-color: #6f42c1;}
        #unmergeBtn { background-color: #e83e8c; color: white; border-color: #e83e8c;}
        #addTableBtn { background-color: #20c997; color: white; border-color: #20c997;}
        #renameTableBtn { background-color: #6c757d; color: white; border-color: #6c757d;}
        #deleteTableBtn { background-color: #dc3545; color: white; border-color: #dc3545;}
        #nameListBtn { background-color: #fd7e14; color: white; border-color: #fd7e14;}
        #deselectBtn { background-color: #6c757d; color: white; border-color: #6c757d;}
        #exportSharedSchedulesBtn { background-color: #4e54c8; color: white; border-color: #4e54c8;}
        #importSharedSchedulesBtn { background-color: #8f94fb; color: white; border-color: #8f94fb;}
        #downloadPdfBtn { background-color: #dc3545; color: white; border-color: #dc3545;}
        .table-tabs {
            margin-bottom: 15px;
            border-bottom: 2px solid #007bff;
            padding-bottom: 0;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }
        .table-tabs button {
            background-color: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            border-radius: 6px 6px 0 0;
            color: #0056b3;
            font-weight: 500;
            padding: 10px 15px;
        }
        .table-tabs button.active {
            background-color: #007bff;
            color: white;
            border-color: #007bff;
        }
        .name-session-tabs {
            margin-bottom: 20px;
            border-bottom: 2px solid #dee2e6;
            padding-bottom: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }
        .name-session-tabs button {
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
            border-bottom: none;
            margin-bottom: -2px;
            padding: 10px 15px;
            font-size: 1em;
        }
        .name-session-tabs button.active {
            background-color: #007bff;
            color: white;
            border-color: #007bff #007bff #fff;
            font-weight: bold;
        }
        #summaryTable td {
            background-color: #fff9e6;
        }
        #summaryTable > tbody > tr > td:first-child {
             background-color: aliceblue !important;
        }
        .highlight-conflict {
            background-color: #f8d7da !important;
            font-weight: bold;
            color: #721c24 !important;
        }
        #summaryTable > tbody > tr > td.highlight-conflict:first-child {
            background-color: aliceblue !important;
            color: #721c24 !important;
        }
        .modal {
            display: none;
            position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%;
            overflow: hidden;
            background-color: rgba(0,0,0,0.5);
            align-items: center; justify-content: center;
            pointer-events: none;
        }
        .modal-content {
            background-color: #fff;
            padding: 25px; border: 1px solid #ccc; width: 90%; max-width: 650px;
            border-radius: 10px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.3); position: relative;
            pointer-events: auto;
            max-height: 90vh;
            overflow-y: auto;
            box-sizing: border-box;
        }
        .modal-content.dragging { transform: none; }
        .modal-header {
            padding-bottom: 15px;
            border-bottom: 1px solid #e9ecef; margin-bottom: 20px;
            font-size: 1.3em; color: #333; display: flex; justify-content: space-between; align-items: center;
            cursor: move; user-select: none;
        }
        .modal-close-btn {
            font-size: 1.8rem;
            font-weight: bold; line-height: 1; color: #555;
            text-shadow: none; opacity: .7; background: transparent; border: 0; cursor: pointer;
            padding: 0 5px;
            transition: color 0.2s;
        }
        .modal-close-btn:hover { opacity: 1; color: #dc3545; }
        .name-item {
            display: flex;
            justify-content: space-between; align-items: center;
            padding: 10px 8px; border-bottom: 1px solid #f1f3f5;
            transition: background-color 0.2s;
        }
        .name-item:hover { background-color: #f8f9fa; }
        .name-item:last-child { border-bottom: none; }
        .name-item span { flex-grow: 1; cursor: pointer; color: #007bff; font-weight: 500; }
        .name-item span:hover { text-decoration: none; color: #0056b3; }
        .name-item button { background-color: #dc3545; color: white; border: none; border-radius: 5px;
            padding: 6px 12px; font-size: 0.9em; transition: background-color 0.2s; }
        .name-item button:hover { background-color: #c82333; }
        .highlighted { background-color: #cfe2ff !important; font-weight: bold; }
        #sharedScheduleListContainer {
            border: 1px solid #ddd; padding: 15px; margin-bottom: 20px; border-radius: 8px;
            background-color: #f8f9fa;
            max-height: 300px;
            overflow-y: auto;
        }
        .shared-schedule-item { display: flex; justify-content: space-between; align-items: center;
            padding: 10px 8px; border-bottom: 1px solid #e9ecef; }
        .shared-schedule-item:last-child { border-bottom: none; }
        .shared-schedule-item span { cursor: pointer; color: #007bff; flex-grow: 1; margin-right: 10px; }
        .shared-schedule-item span:hover { text-decoration: underline; }
        .shared-schedule-item .schedule-date { font-size: 0.8em; color: #6c757d; margin-right: 10px; white-space: nowrap;}
        .shared-schedule-item button { background-color: #dc3545; color: white; border: none; border-radius: 5px;
            padding: 6px 12px; font-size: 0.9em; flex-shrink: 0; }
        #newNameInput, #searchNameInput {
            padding: 10px;
            margin-right: 8px; border: 1px solid #ccc; border-radius: 5px; flex-grow: 1;
            width: calc(100% - 120px);
            box-sizing: border-box;
        }
         #searchNameInput {
            margin-bottom: 15px;
            width: 100%;
            box-sizing: border-box;
            margin-right: 0;
         }
        .input-group {
            display: flex;
            margin-bottom: 15px;
            width: 100%;
        }
        .input-group button, #importNameListBtn {
            background-color: #28a745;
            color: white; border-color: #28a745; padding: 10px 15px;
            font-size: 1em; border-radius: 5px; cursor: pointer; flex-shrink: 0;
            transition: background-color 0.2s;
        }
        .input-group button:hover, #importNameListBtn:hover { background-color: #218838; }
        #importNameListBtn {
            margin-top: 10px;
            width: 100%;
        }
        #nameList {
            margin-top:15px;
            max-height:250px;
            overflow-y:auto;
        }
        @media (min-width: 480px) {
            #nameList {
                column-count: 2;
                column-gap: 20px;
            }
        }
        .custom-message-box {
            display: none;
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            background-color: #333; color: white; padding: 15px 25px; border-radius: 8px;
            z-index: 2000;
            box-shadow: 0 4px 15px rgba(0,0,0,0.25); font-size: 1.05em;
            text-align: center;
            width: 90%;
            max-width: 400px;
        }
        .custom-message-box.success { background-color: #28a745; }
        .custom-message-box.error { background-color: #dc3545; }
        .custom-message-box.info { background-color: #007bff; }
        .merged-cell-container { position: relative; z-index: 2; vertical-align: top; }
        .merged-cell-overlay {
            position: absolute;
            top: 0; left: 0; width: var(--merged-width); height: var(--merged-height);
            background-color: rgba(240, 248, 255, 0.95); font-style: italic; border: 1px solid #add8e6;
            display: flex; align-items: center;
            justify-content: center; overflow: hidden;
            box-sizing: border-box; z-index: 5;
        }
        .subsumed-cell { visibility: hidden; }
        #loadingIndicatorModal, #generalLoadingIndicator {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(255, 255, 255, 0.85);
            display: flex; align-items: center; justify-content: center;
            z-index: 10;
            border-radius: 10px;
        }
        #generalLoadingIndicator {
            position: fixed;
            z-index: 3000;
            border-radius: 0;
        }
        .spinner {
            border: 5px solid rgba(0, 0, 0, 0.1);
            width: 40px; height: 40px;
            border-radius: 50%;
            border-left-color: #007bff;
            animation: spin 1s ease infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        input[type="file"][style*="display:none"],
        input[type="file"][style*="display: none"] {
            position: absolute;
            left: -9999px;
            width: 1px;
            height: 1px;
            opacity: 0;
        }
        #autocompleteSuggestions {
            display: none;
            position: absolute;
            border: 1px solid #ccc;
            background-color: white;
            z-index: 1001;
            max-height: 150px;
            overflow-y: auto;
            min-width: 120px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.15);
            border-radius: 4px;
        }
        .suggestion-item {
            padding: 8px 10px;
            cursor: pointer;
            font-size: 0.9em;
            white-space: nowrap;
        }
        .suggestion-item:hover, .suggestion-item.active-suggestion {
            background-color: #e9ecef;
            color: #0056b3;
        }

        /* Styles for PDF content container */
        #pdfContent {
            padding: 10px;
            background-color: #fff;
            color: #333;
            font-family: 'Arial', sans-serif;
            box-sizing: border-box;
            width: 100%;
            display: none;
        }
        #pdfContent .pdf-page-wrapper {
            page-break-inside: avoid !important;
            padding-bottom: 25px;
            box-sizing: border-box;
            /* page-break-after: always; REMOVED - will be applied selectively in JS */
        }
         #pdfContent .pdf-page-wrapper:not(:first-child) { /* Add page break before subsequent wrappers */
             page-break-before: always !important;
        }
        #pdfContent .pdf-page-wrapper:last-child {
             page-break-after: auto !important; /* No page break after the very last one */
        }
        #pdfContent h2 { /* Main schedule title - "Jadual Anjal" */
            text-align: center;
            color: #1c1e21;
            margin-bottom: 10px; /* Reduced margin to keep it closer to the first table's title */
            font-size: 1.3em;
            page-break-after: avoid !important; /* Try to keep with content below */
        }
        #pdfContent h3 { /* Individual table titles */
            text-align: center;
            color: #1c1e21;
            margin-top: 5px;
            margin-bottom: 8px; /* Reduced margin */
            font-size: 1.0em;
            page-break-before: avoid !important;
            page-break-after: avoid !important;
        }
        #pdfContent table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 10px;
            box-shadow: none;
            background-color: #fff;
            table-layout: fixed;
            page-break-inside: avoid !important;
        }
        #pdfContent th { /* Table headers */
            background-color: #f0f0f0 !important;
            color: #000;
            font-weight: bold;
            font-size: 0.75em;
            padding: 4px 5px;
        }
        #pdfContent td { /* Table cells */
            border: 1px solid #555 !important;
            padding: 3px 4px; /* Further reduced padding */
            text-align: center;
            font-size: 0.7em; /* Further reduced font size */
            word-wrap: break-word;
            background-color: #fff;
        }
        #pdfContent table tbody tr td:first-child,
        #pdfContent table thead tr th:first-child {
            background-color: #e6f7ff !important;
            font-weight: bold;
        }
        #pdfContent .pdf-footnote {
            text-align: right;
            font-size: 0.65em;
            color: #555555;
            margin-top: 10px;
            padding-top: 5px;
            border-top: 1px solid #dddddd;
            width: 100%;
            box-sizing: border-box;
            position: relative;
            bottom: 0;
        }
    </style>
</head>
<body>
<div class="main-container">
    <h2 contenteditable="true" id="scheduleTitle">Jadual Anjal</h2>
    <div id="userIdDisplay">User ID: Loading...</div>

    <button id="controlsToggler" aria-expanded="false" aria-controls="collapsibleButtonBars" title="Toggle button controls visibility">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="toggler-icon"><polyline points="18 15 12 9 6 15"></polyline></svg>
        <span>Show Controls</span>
    </button>

    <div id="collapsibleButtonBars">
        <div class="bar">
            <button id="directCopyFullHtmlBtn" title="Copy the entire page's HTML to clipboard">📋 Copy Full HTML (Direct)</button>
            <button id="downloadPdfBtn" title="Download schedule tables as PDF">📄 Download PDF</button> </div>
        <div class="bar">
            <button id="excelBtnTrigger" title="Export the currently active table to an Excel file">💾 Export Active Table to Excel</button>
            <button id="importExcelBtn" title="Import data from an Excel file into a new table">📂 Import from Excel</button>
            <input type="file" id="fileInput" accept=".xlsx, .xls" style="display:none">
        </div>
        <div class="bar">
            <button id="saveSharedScheduleBtn" title="Save current schedule to the shared Cloud space">💠 Save Shared Schedule</button>
            <button id="loadSharedScheduleBtn" title="Show list of shared schedules from Cloud to load">☁️ Load Shared Schedule</button>
            <button id="exportSharedSchedulesBtn" title="Export all shared schedules from Cloud to a JSON file">📤 Export All Shared Schedules</button>
            <button id="importSharedSchedulesBtn" title="Import schedules from a JSON file to the shared Cloud space">📥 Import Shared Schedules</button>
            <input type="file" id="sharedScheduleImportFile" accept=".json" style="display:none;">
            <button id="clearActiveTableContentBtn" title="Clear all data from the cells of the active table">🧹 Clear Active Table</button>
        </div>
        <div class="bar">
            <button id="selectBtn" title="Toggle cell selection mode on/off">✨ Select Cells</button>
            <button id="mergeBtn" title="Merge the currently selected cells">🔗 Merge Cells</button>
            <button id="deselectBtn" title="Clear current cell selection">🚫 Deselect All</button>
            <button id="unmergeBtn" title="Unmerge the cell that was last clicked if it's part of a merge">💔 Unmerge Cell</button>
        </div>
        <div class="bar">
            <button id="addTableBtn" title="Add a new, empty table/sheet">➕ Add New Table</button>
            <button id="renameTableBtn" title="Rename the currently active table/sheet">📝 Rename Active Table</button>
            <button id="deleteTableBtn" title="Delete the currently active table/sheet">❌ Delete Active Table</button>
            <button id="nameListBtn" title="Open a dialog to manage the shared list of names (Firestore)">👥 Manage Shared Names</button>
        </div>
        <div class="bar" id="rowColManipulationBar">
            <button id="addRowAboveBtn" title="Add a new row above the currently selected/clicked row">⬆️ Add Row Above</button>
            <button id="addRowBelowBtn" title="Add a new row below the currently selected/clicked row">⬇️ Add Row Below</button>
            <button id="addColLeftBtn" title="Add a new column to the left of the currently selected/clicked column">⬅️ Add Column Left</button>
            <button id="addColRightBtn" title="Add a new column to the right of the currently selected/clicked column">➡️ Add Column Right</button>
            <button id="deleteRowBtn" class="delete-btn" title="Delete the currently selected/clicked row">🗑️ Delete Row</button>
            <button id="deleteColBtn" class="delete-btn" title="Delete the currently selected/clicked column">🗑️ Delete Column</button>
        </div>
    </div>
    <div id="sharedScheduleListContainer" style="display:none;"></div>
    <div class="bar table-tabs" id="tableTabs"></div>
    <div id="tablesContainer">
        <table id="tbl_1" class="active" data-table-name="Kelas 3 & 5">
            <thead>
                <tr>
                    <th contenteditable="true">Class</th>
                    <th contenteditable="true">08:00</th>
                    <th contenteditable="true">09:00</th>
                    <th contenteditable="true">10:00</th>
                    <th contenteditable="true" data-merge-id="rehat_tbl1_col4" class="merged-cell-container">
                        <div class="merged-cell-overlay" style="--merged-width: 200px; --merged-height: 50px;" contenteditable="true">REHAT</div>
                    </th>
                    <th contenteditable="true" data-merge-id="rehat_tbl1_col4" class="subsumed-cell">11:00</th>
                    <th contenteditable="true">12:00</th>
                    <th contenteditable="true">13:00</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td contenteditable="true">5S1</td>
                    <td contenteditable="true"></td><td contenteditable="true">JAMES *ReportDue // Sick leave</td><td contenteditable="true"></td>
                    <td contenteditable="true" data-merge-id="rehat_tbl1_col4_row1" class="merged-cell-container">
                         <div class="merged-cell-overlay" style="--merged-width: 200px; --merged-height: 50px;" contenteditable="true"></div>
                    </td>
                    <td contenteditable="true" data-merge-id="rehat_tbl1_col4_row1" class="subsumed-cell"></td>
                    <td contenteditable="true"></td><td contenteditable="true"></td>
                </tr>
                 <tr>
                    <td contenteditable="true">5S2</td>
                    <td contenteditable="true">*SpecialAssembly</td><td contenteditable="true"></td><td contenteditable="true">LILY</td>
                     <td contenteditable="true" data-merge-id="rehat_tbl1_col4_row2" class="merged-cell-container">
                         <div class="merged-cell-overlay" style="--merged-width: 200px; --merged-height: 50px;" contenteditable="true"></div>
                    </td>
                    <td contenteditable="true" data-merge-id="rehat_tbl1_col4_row2" class="subsumed-cell"></td>
                    <td contenteditable="true"></td><td contenteditable="true"></td>
                </tr>
            </tbody>
        </table>
        <table id="tbl_2" data-table-name="Kelas 1, 2 & 4">
            <thead>
                <tr>
                    <th contenteditable="true">Class</th>
                    <th contenteditable="true">08:00</th>
                    <th contenteditable="true">09:00</th>
                    <th contenteditable="true">10:00</th>
                    <th contenteditable="true" data-merge-id="rehat_tbl2_col4" class="merged-cell-container">
                        <div class="merged-cell-overlay" style="--merged-width: 200px; --merged-height: 50px;" contenteditable="true">REHAT</div>
                    </th>
                    <th contenteditable="true" data-merge-id="rehat_tbl2_col4" class="subsumed-cell">11:00</th>
                    <th contenteditable="true">12:00</th>
                    <th contenteditable="true">13:00</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td contenteditable="true">1A</td>
                    <td contenteditable="true">MATH</td><td contenteditable="true"></td><td contenteditable="true">SCIENCE</td>
                    <td contenteditable="true" data-merge-id="rehat_tbl2_col4_row1" class="merged-cell-container">
                         <div class="merged-cell-overlay" style="--merged-width: 200px; --merged-height: 50px;" contenteditable="true"></div>
                    </td>
                    <td contenteditable="true" data-merge-id="rehat_tbl2_col4_row1" class="subsumed-cell"></td>
                    <td contenteditable="true"></td><td contenteditable="true"></td>
                </tr>
                 <tr>
                    <td contenteditable="true">2B</td>
                    <td contenteditable="true"></td><td contenteditable="true">HISTORY</td><td contenteditable="true"></td>
                    <td contenteditable="true" data-merge-id="rehat_tbl2_col4_row2" class="merged-cell-container">
                         <div class="merged-cell-overlay" style="--merged-width: 200px; --merged-height: 50px;" contenteditable="true"></div>
                    </td>
                    <td contenteditable="true" data-merge-id="rehat_tbl2_col4_row2" class="subsumed-cell"></td>
                    <td contenteditable="true">ART</td><td contenteditable="true"></td>
                </tr>
                <tr>
                    <td contenteditable="true">4C</td>
                    <td contenteditable="true">PHYSICS</td><td contenteditable="true"></td><td contenteditable="true">CHEMISTRY</td>
                    <td contenteditable="true" data-merge-id="rehat_tbl2_col4_row3" class="merged-cell-container">
                         <div class="merged-cell-overlay" style="--merged-width: 200px; --merged-height: 50px;" contenteditable="true"></div>
                    </td>
                    <td contenteditable="true" data-merge-id="rehat_tbl2_col4_row3" class="subsumed-cell"></td>
                    <td contenteditable="true"></td><td contenteditable="true"></td>
                </tr>
            </tbody>
        </table>
    </div>

    <div id="nameModal" class="modal">
        <div class="modal-content" id="nameModalContent">
            <div class="modal-header" id="nameModalHeader">
                <h3 id="nameModalTitle">Shared Name List Manager</h3>
                <button type="button" class="modal-close-btn" id="closeNameModalBtnStandard" title="Close name manager">×</button>
            </div>
            <div class="name-session-tabs">
                <button id="namePagiTab" data-session="pagi" class="active">Pagi (Morning)</button>
                <button id="namePetangTab" data-session="petang">Petang (Afternoon)</button>
            </div>
             <div class="input-group">
                <input id="newNameInput" placeholder="Add new name to current shared session">
                <button id="addNameBtnInModal" title="Add the name to the shared list">Add</button>
             </div>
            <button id="importNameListBtn" title="Import names from a .txt file (one name per line) to current shared session">📂 Import Names (.txt) to Shared Session</button>
            <input type="file" id="nameListImportFile" accept=".txt" style="display:none;">
            <input type="text" id="searchNameInput" placeholder="🔍 Search names in current shared session..." title="Filter the list of names">
            <div id="nameList"></div>
            <div id="loadingIndicatorModal" style="display:none;"><div class="spinner"></div></div>
        </div>
    </div>

    <h3 style="margin-top:32px">Teacher/Subject Attendance Summary</h3>
    <div id="summaryTableContainer">
        <table id="summaryTable"></table>
    </div>
    <div id="customMessageBox" class="custom-message-box"></div>
    <div id="generalLoadingIndicator" style="display:none;"><div class="spinner"></div></div>
</div>

<div id="pdfContent"></div>

<script type="module">
    // Firebase App (the core Firebase SDK) is always required and must be listed first
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    // Add SDKs for Firebase products that you want to use
    import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, setDoc, onSnapshot, collection, addDoc, getDocs, getDoc, deleteDoc, updateDoc, query, serverTimestamp, orderBy, where, limit } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // --- Firebase Configuration ---
    // This is the configuration provided by the user.
    const userProvidedFirebaseConfig = {
      apiKey: "AIzaSyBgvyb95-jujtCC2HPiHXLdYMJgQquIEx4",
      authDomain: "jadual-3f0aa.firebaseapp.com",
      projectId: "jadual-3f0aa",
      storageBucket: "jadual-3f0aa.appspot.com", // Corrected from firebasestorage.app to appspot.com based on typical Firebase setup
      messagingSenderId: "496526436851",
      appId: "1:496526436851:web:78ff48b28bfc8c31f14a86"
    };

    let firebaseConfig;
    // Check if __firebase_config is provided by the environment (e.g., Canvas)
    if (typeof __firebase_config !== 'undefined' && __firebase_config !== null && __firebase_config.trim() !== '') {
        try {
            firebaseConfig = JSON.parse(__firebase_config);
            console.log("Using injected Firebase config (__firebase_config).");
        } catch (e) {
            console.error("Error parsing injected __firebase_config. Falling back to userProvidedFirebaseConfig. Error:", e);
            firebaseConfig = userProvidedFirebaseConfig;
        }
    } else {
        firebaseConfig = userProvidedFirebaseConfig;
        console.log("Using Firebase config defined in the script (userProvidedFirebaseConfig).");
    }

    // Basic check for placeholder API key if using userProvidedFirebaseConfig (though it's now filled)
    if (firebaseConfig.apiKey === "AIzaSyEXAMPLE-API-KEYdQquIEx4" || firebaseConfig.apiKey === "YOUR_API_KEY" ) { // Check against known placeholders
        console.error("Firebase Auth: CRITICAL - The Firebase API Key is still a placeholder even after attempting to set it. Please ensure the correct configuration is applied.");
        const userIdDisplayError = document.getElementById('userIdDisplay');
        if (userIdDisplayError) userIdDisplayError.textContent = "User ID: Firebase API Key Error!";
        showMessage("Firebase Configuration Error: Invalid API Key. Please update the script.", "error", 10000);
    }
    
    // Determine App ID: Use injected __app_id if available, otherwise use from config or a default.
    const appId = typeof __app_id !== 'undefined' ? __app_id : (firebaseConfig.appId || 'default-shared-scheduler-app');

    if (typeof __app_id === 'undefined') {
        console.warn("Firebase Auth: __app_id is not defined. Using App ID from Firebase config or a default value. This might affect data isolation if multiple apps use the same Firebase project without distinct app IDs.");
    }


    let fbApp, fbAuth, fbDb;
    let fbUserId = null;
    let fbIsAuthReady = false;
    let unsubscribePagiShared = null;
    let unsubscribePetangShared = null;

    try {
        fbApp = initializeApp(firebaseConfig);
        fbAuth = getAuth(fbApp);
        fbDb = getFirestore(fbApp);
        console.log("Firebase services initialized for Shared Scheduler with Project ID:", firebaseConfig.projectId);
    } catch (e) {
        console.error("CRITICAL Error initializing Firebase services:", e);
        showMessage("Critical Error: Firebase initialization failed. Cloud features will not work. Error: " + e.message, "error", 10000);
        const userIdDisplayInitError = document.getElementById('userIdDisplay');
        if (userIdDisplayInitError) userIdDisplayInitError.textContent = "User ID: Firebase Init Error!";
    }


    const SCHEDULE_TITLE_KEY = `shared_jadual_title_${appId}`;
    let activeTableId = 'tbl_1'; // Default active table ID
    let tableCount = 1; // To generate unique IDs for new tables
    let selectionMode = false;
    let selectedCells = [];
    let lastClickedCell = null; // To keep track of the last clicked cell for context actions
    let selectedNameFromList = null; // Name selected from the shared list for insertion
    let currentNameListSession = 'pagi'; // 'pagi' or 'petang'
    let namesPagiShared = []; // Holds names for 'pagi' session from Firestore
    let namesPetangShared = []; // Holds names for 'petang' session from Firestore
    let isDraggingModal = false;
    let modalDragOffsetX, modalDragOffsetY;
    let autocompleteSuggestionsDiv = null;
    let activeCellForAutocomplete = null;
    let currentAutocompleteIndex = -1;
    let currentWorkingScheduleDocId = null; // Firestore document ID of the currently loaded/active shared schedule
    let autoSaveIntervalId = null;
    const AUTO_SAVE_INTERVAL = 60000; // 60 seconds for auto-save

    // DOM Element Cache
    let scheduleTitleElement, tablesContainer, tableTabs, nameModal, nameModalContent, nameModalHeader, nameListContainer, newNameInput, sharedScheduleListContainerElement, summaryTableElement, summaryTableContainerElement, customMessageBox, fileInputElement, directCopyFullHtmlButtonElement, closeNameModalButtonStandardElement, nameListImportFileInputElement, searchNameInputElement, sharedScheduleImportFileInputElement, userIdDisplayElement, namePagiTabElement, namePetangTabElement, loadingIndicatorModalElement, nameModalTitleElement, generalLoadingIndicatorElement, controlsTogglerElement, collapsibleButtonBarsElement, downloadPdfButtonElement, pdfContentElement;

    // Utility to show custom messages
    function showMessage(message, type = 'info', duration = 3000) {
        if (!customMessageBox) {
            customMessageBox = document.getElementById('customMessageBox');
            if (!customMessageBox) { // Fallback if element not found early
                console.warn("showMessage called but customMessageBox element not found. Message:", message);
                return;
            }
        }
        customMessageBox.textContent = message;
        customMessageBox.className = `custom-message-box ${type}`; // Applies 'success', 'error', or 'info' class
        customMessageBox.style.display = 'block';
        setTimeout(() => { if (customMessageBox) customMessageBox.style.display = 'none'; }, duration);
    }

    // Custom prompt function (simple wrapper around browser prompt)
    function customPrompt(message, defaultValue = "") {
        return prompt(message, defaultValue);
    }

    // Custom confirm dialog
    function customConfirm(message) {
        return new Promise((resolve) => {
            const confirmModalId = 'customConfirmModal';
            let existingModal = document.getElementById(confirmModalId);
            if (existingModal) existingModal.remove(); // Remove if already exists

            const modal = document.createElement('div');
            modal.id = confirmModalId;
            modal.style.cssText = `display: flex; position: fixed; z-index: 2001; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5); align-items: center; justify-content: center;`;

            const modalContent = document.createElement('div');
            modalContent.style.cssText = `background-color: #fff; padding: 25px; border-radius: 8px; text-align: center; box-shadow: 0 5px 15px rgba(0,0,0,0.3); min-width: 300px; max-width: 90%;`;

            const messageP = document.createElement('p');
            messageP.textContent = message;
            messageP.style.marginBottom = '20px'; messageP.style.fontSize = '1.1em';

            const yesButton = document.createElement('button');
            yesButton.textContent = 'Yes';
            yesButton.style.cssText = `padding: 10px 20px; margin: 0 10px; border-radius: 5px; cursor: pointer; background-color: #28a745; color: white; border: none; font-size: 1em;`;

            const noButton = document.createElement('button');
            noButton.textContent = 'No';
            noButton.style.cssText = `padding: 10px 20px; margin: 0 10px; border-radius: 5px; cursor: pointer; background-color: #dc3545; color: white; border: none; font-size: 1em;`;

            const closeModal = (value) => { modal.remove(); resolve(value); };
            yesButton.onclick = () => closeModal(true);
            noButton.onclick = () => closeModal(false);

            modalContent.appendChild(messageP);
            modalContent.appendChild(yesButton);
            modalContent.appendChild(noButton);
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
        });
    }
    
    // --- Loading Indicators ---
    function showGeneralLoading(isLoading) {
        if (generalLoadingIndicatorElement) {
            generalLoadingIndicatorElement.style.display = isLoading ? 'flex' : 'none';
        }
    }

    function toggleButtonBarsVisibility() {
        if (!collapsibleButtonBarsElement || !controlsTogglerElement) return;
        const isOpen = collapsibleButtonBarsElement.classList.toggle('open');
        controlsTogglerElement.setAttribute('aria-expanded', isOpen.toString());
        const textSpan = controlsTogglerElement.querySelector('span');
        if (textSpan) {
            textSpan.textContent = isOpen ? 'Hide Controls' : 'Show Controls';
        }
    }


    function showNameModalLoading(isLoading) {
        if (loadingIndicatorModalElement) {
            loadingIndicatorModalElement.style.display = isLoading ? 'flex' : 'none';
        }
    }

    // --- Shared Name List Management (Firestore) ---
    async function saveSharedNameListToFirestore(session, namesArray) {
        if (!fbDb || !fbIsAuthReady) {
            showMessage("Firebase not ready. Cannot save shared name list.", "error");
            return;
        }
        showNameModalLoading(true);
        // Sanitize and sort names: ensure they are strings, trimmed, non-empty, unique, and sorted
        const uniqueSortedNames = [...new Set(namesArray.map(n => String(n||'').trim()).filter(n => n))]
                                .sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));

        if (!appId || appId === 'default-shared-scheduler-app') { // Check for valid appId
            showMessage("Configuration error: App ID is missing or default. Cannot save shared name list.", "error");
            showNameModalLoading(false);
            return;
        }
        const docRef = doc(fbDb, "artifacts", appId, "public/data/sharedNameLists", session);
        try {
            await setDoc(docRef, { names: uniqueSortedNames, lastUpdatedBy: fbUserId || "anonymous", updatedAt: serverTimestamp() });
            showMessage(`Shared name list for ${session} session updated.`, "success");
        } catch (error) {
            console.error(`Error saving shared list to ${session}:`, error);
            showMessage(`Failed to save shared list to ${session}. Error: ${error.message}`, "error");
        } finally {
            showNameModalLoading(false);
        }
    }

    async function addNameToSharedSessionInFirestore(name) {
        if (!fbDb || !fbIsAuthReady) {
            showMessage("Firebase not ready. Cannot add name to shared list.", "error");
            return;
        }
        const trimmedName = String(name || '').trim();
        if (!trimmedName) {
            showMessage("Name cannot be empty.", "info");
            return;
        }
        showNameModalLoading(true);
        const sessionNames = currentNameListSession === 'pagi' ? namesPagiShared : namesPetangShared;
        // Check if name already exists (case-insensitive)
        if (sessionNames.map(n => String(n || '').toLowerCase()).includes(trimmedName.toLowerCase())) {
            showMessage(`Name "${trimmedName}" already exists in shared ${currentNameListSession} session.`, "info");
            showNameModalLoading(false);
            return;
        }
        if (!appId || appId === 'default-shared-scheduler-app') { // Check for valid appId
            showMessage("Configuration error: App ID is missing or default. Cannot add name.", "error");
            showNameModalLoading(false);
            return;
        }
        const updatedNames = [...sessionNames, trimmedName].sort((a, b) => String(a).localeCompare(String(b), undefined, { sensitivity: 'base' }));
        const docRef = doc(fbDb, "artifacts", appId, "public/data/sharedNameLists", currentNameListSession);
        try {
            await setDoc(docRef, { names: updatedNames, lastUpdatedBy: fbUserId || "anonymous", updatedAt: serverTimestamp() });
            // Clear input and focus after adding
            if(newNameInput) {
                newNameInput.value = '';
                newNameInput.focus();
            }
        } catch (error) {
            console.error(`Error adding name to shared ${currentNameListSession}:`, error);
            showMessage(`Failed to add name to shared list. Error: ${error.message}`, "error");
        } finally {
            showNameModalLoading(false);
        }
    }

    async function deleteNameFromSharedSessionInFirestore(nameToDelete) {
        if (!fbDb || !fbIsAuthReady) {
            showMessage("Firebase not ready. Cannot delete name from shared list.", "error");
            return;
        }
        const nameToDeleteStr = String(nameToDelete || '');
        if (await customConfirm(`Delete "${nameToDeleteStr}" from shared ${currentNameListSession} session? This also removes it from all schedule tables for everyone.`)) {
            showNameModalLoading(true);
            if (!appId || appId === 'default-shared-scheduler-app') { // Check for valid appId
                showMessage("Configuration error: App ID is missing or default. Cannot delete name.", "error");
                showNameModalLoading(false);
                return;
            }
            const currentNames = currentNameListSession === 'pagi' ? namesPagiShared : namesPetangShared;
            const updatedNames = currentNames.filter(name => String(name || '') !== nameToDeleteStr);
            const docRef = doc(fbDb, "artifacts", appId, "public/data/sharedNameLists", currentNameListSession);
            try {
                await setDoc(docRef, { names: updatedNames, lastUpdatedBy: fbUserId || "anonymous", updatedAt: serverTimestamp() });
                // Remove the deleted name from all tables
                tablesContainer.querySelectorAll('table').forEach(table => {
                    table.querySelectorAll('tbody td, tbody th, .merged-cell-overlay').forEach(cell => {
                        const cellText = cell.textContent.trim();
                        const parts = cellText.split(' // '); // Split content and remarks
                        let mainContent = parts[0];
                        const remarkContent = parts.length > 1 ? ` // ${parts.slice(1).join(' // ')}` : '';

                        // Remove the name, preserving starred items not matching the name
                        const wordsInMain = mainContent.split(/\s+/);
                        const newWordsInMain = wordsInMain.filter(word => {
                            // If word is starred and related to the name, remove it. Otherwise keep starred items.
                            if (word.startsWith('*') && mainContent.includes(nameToDeleteStr)) {
                                // This logic might need refinement if starred items can be complex
                                return !mainContent.includes(word.substring(1)); // A simple check
                            }
                            return word !== nameToDeleteStr;
                        });
                        const newMainContent = newWordsInMain.join(' ').trim();

                        if (newMainContent || remarkContent) { // If there's any content left
                            cell.textContent = (newMainContent + remarkContent).trim();
                        } else {
                            cell.textContent = ''; // Clear cell if name was the only content
                        }
                    });
                });
                rebuildAndRenderSummary(); // Update summary table
                if (selectedNameFromList === nameToDeleteStr) clearNameSelection(); // Clear if it was selected
            } catch (error) {
                console.error(`Error deleting name from shared ${currentNameListSession}:`, error);
                showMessage(`Failed to delete name from shared list. Error: ${error.message}`, "error");
            } finally {
                showNameModalLoading(false);
            }
        }
    }

    function listenToSharedNameList(sessionToListen) {
        if (!fbDb || !fbIsAuthReady) {
            console.warn(`listenToSharedNameList (${sessionToListen}): Firestore not ready.`);
            return () => {}; // Return a no-op unsubscribe function
        }
        if (!appId || appId === 'default-shared-scheduler-app') { // Check for valid appId
            console.error(`listenToSharedNameList (${sessionToListen}): Invalid appId. Cannot listen to shared names.`);
            return () => {};
        }

        const docRef = doc(fbDb, "artifacts", appId, "public/data/sharedNameLists", sessionToListen);
        return onSnapshot(docRef, (docSnap) => {
            showNameModalLoading(true);
            if (docSnap.exists()) {
                const data = docSnap.data();
                const namesFromDb = data.names || [];
                // Sanitize names: ensure they are strings, trimmed, and non-empty
                const sanitizedNames = namesFromDb.map(name => String(name || '').trim()).filter(name => name.length > 0);
                if (sessionToListen === 'pagi') namesPagiShared = sanitizedNames;
                else namesPetangShared = sanitizedNames;
            } else {
                // If document doesn't exist, clear local list
                if (sessionToListen === 'pagi') namesPagiShared = [];
                else namesPetangShared = [];
                 console.log(`No shared name list found for ${sessionToListen} under appId ${appId}. A new one will be created on save.`);
            }
            // Re-render list if modal is open and it's the current session
            if (sessionToListen === currentNameListSession && nameModal && nameModal.style.display === 'flex' && searchNameInputElement) {
                renderNameListFromFirestore(searchNameInputElement.value);
            }
            rebuildAndRenderSummary(); // Update summary table as names might affect it
            showNameModalLoading(false);
        }, (error) => {
            console.error(`Error listening to shared ${sessionToListen} names:`, error);
            showMessage(`Error fetching shared ${sessionToListen} names.`, "error");
            showNameModalLoading(false);
        });
    }

    // --- Shared Schedule Management (Firestore) ---
    async function saveSharedScheduleToFirestore() {
        if (!fbDb || !fbIsAuthReady) {
            showMessage("Firebase not ready. Cannot save shared schedule.", "error"); return;
        }
        if (!tablesContainer || tablesContainer.children.length === 0) {
            showMessage('No schedule data to save.', 'error'); return;
        }
        const scheduleName = customPrompt('Enter a name for this shared schedule:', `Shared Schedule ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`);
        if (!scheduleName || scheduleName.trim() === "") {
            showMessage('Save cancelled or name is empty.', 'info'); return;
        }
        showGeneralLoading(true);
        const allTablesData = tablesContainer.innerHTML; // Full HTML of all tables
        const allTableMeta = {}; // Metadata like table names
        tablesContainer.querySelectorAll('table').forEach(table => {
            allTableMeta[table.id] = { name: table.dataset.tableName || table.id };
        });

        const scheduleData = {
            name: scheduleName.trim(),
            html: allTablesData,
            meta: allTableMeta,
            activeTableId: activeTableId,
            createdAt: serverTimestamp(),
            lastUpdatedAt: serverTimestamp(),
            lastUpdatedBy: fbUserId || "anonymous",
            isAutoDraft: false // Explicitly saved schedules are not drafts
        };

        try {
            const sharedSchedulesCollectionRef = collection(fbDb, "artifacts", appId, "public/data/sharedSchedules");
            const newDocRef = await addDoc(sharedSchedulesCollectionRef, scheduleData);
            currentWorkingScheduleDocId = newDocRef.id; // Update current working ID to this new document
            showMessage(`Shared schedule "${scheduleName.trim()}" saved to Cloud! (ID: ${currentWorkingScheduleDocId})`, 'success');
            // Refresh list if it's visible
            if (sharedScheduleListContainerElement && sharedScheduleListContainerElement.style.display === 'block') {
                await loadAndRenderSharedSchedulesFromFirestore();
            }
        } catch (error) {
            console.error("Error saving shared schedule to Firestore:", error);
            showMessage(`Failed to save shared schedule. Error: ${error.message}`, "error");
        } finally {
            showGeneralLoading(false);
        }
    }

    // NEW: Helper function to create an initial auto-save document if one doesn't exist
    async function ensureAutoSaveDocumentExists() {
        if (currentWorkingScheduleDocId) return true; // A document is already being tracked

        if (!fbDb || !fbIsAuthReady || !fbUserId) {
            console.warn("ensureAutoSaveDocumentExists: Firebase not ready or user ID missing. Cannot create auto-save document.");
            return false;
        }

        console.log("ensureAutoSaveDocumentExists: Creating a new auto-save document.");
        // showGeneralLoading(true); // Avoid showing general loading for background auto-draft creation unless necessary

        const scheduleName = `Autosaved Draft (${fbUserId.substring(0, 5)}...) - ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`;
        const allTablesData = tablesContainer.innerHTML;
        const allTableMeta = {};
        tablesContainer.querySelectorAll('table').forEach(table => {
            allTableMeta[table.id] = { name: table.dataset.tableName || table.id };
        });

        const scheduleData = {
            name: scheduleName,
            html: allTablesData,
            meta: allTableMeta,
            activeTableId: activeTableId || tablesContainer.querySelector('table')?.id || 'tbl_1', // Ensure valid activeTableId
            createdAt: serverTimestamp(),
            lastUpdatedAt: serverTimestamp(),
            lastUpdatedBy: fbUserId || "anonymous",
            isAutoDraft: true // Flag this as an automatic draft
        };

        try {
            const sharedSchedulesCollectionRef = collection(fbDb, "artifacts", appId, "public/data/sharedSchedules");
            const newDocRef = await addDoc(sharedSchedulesCollectionRef, scheduleData);
            currentWorkingScheduleDocId = newDocRef.id;
            console.log(`ensureAutoSaveDocumentExists: New auto-save document created with ID: ${currentWorkingScheduleDocId} and name "${scheduleName}"`);
            // Don't show a disruptive message for background draft creation, console log is enough.
            // showMessage(`Draft auto-created: "${scheduleName}"`, 'info', 3000);
            
            // Optionally, refresh the list if it's open and configured to show drafts
            // if (sharedScheduleListContainerElement && sharedScheduleListContainerElement.style.display === 'block') {
            //    await loadAndRenderSharedSchedulesFromFirestore();
            // }
            return true;
        } catch (error) {
            console.error("Error creating auto-save document in Firestore:", error);
            showMessage(`Failed to create auto-save draft. Error: ${error.message}`, "error"); // Show error if it fails
            return false;
        } finally {
            // showGeneralLoading(false);
        }
    }


    // MODIFIED: autoSaveCurrentSchedule function
    async function autoSaveCurrentSchedule() {
        if (!fbDb || !fbIsAuthReady) {
            // console.log("Auto-save skipped: Firebase not ready.");
            return;
        }

        // Check for actual content before proceeding with any save operation
        if (!tablesContainer || tablesContainer.children.length === 0) {
            // console.log('Auto-save skipped: No schedule data to save (tablesContainer empty or no children).');
            return;
        }
        // Add more sophisticated check here if you want to avoid saving placeholder/empty default content

        if (!currentWorkingScheduleDocId) {
            // console.log("Auto-save: No currentWorkingScheduleDocId. Attempting to create/ensure a default auto-save document because there's content.");
            const success = await ensureAutoSaveDocumentExists(); // This function will use current tablesContainer.innerHTML
            if (!success || !currentWorkingScheduleDocId) {
                console.log("Auto-save: Failed to create/ensure auto-save document. Auto-save will not proceed for this cycle.");
                return;
            }
            // console.log(`Auto-save: New document created/ensured: ${currentWorkingScheduleDocId}. The initial save is done by ensureAutoSaveDocumentExists.`);
            // The document is created with the current content by ensureAutoSaveDocumentExists.
            // For this first cycle, the data is already "saved" as part of the draft creation.
            // We can return here to avoid an immediate redundant update, or let it proceed.
            // For simplicity and consistency, let it proceed to the update logic below.
            // This also handles the case where ensureAutoSaveDocumentExists might be quick and the interval triggers again.
        }

        // console.log(`Attempting auto-save for document ID: ${currentWorkingScheduleDocId}`);
        const allTablesData = tablesContainer.innerHTML;
        const allTableMeta = {};
        tablesContainer.querySelectorAll('table').forEach(table => {
            allTableMeta[table.id] = { name: table.dataset.tableName || table.id };
        });

        const docRef = doc(fbDb, "artifacts", appId, "public/data/sharedSchedules", currentWorkingScheduleDocId);
        try {
            const docSnap = await getDoc(docRef); // Check if the document still exists
            if (!docSnap.exists()) {
                console.warn(`Auto-save: Document ${currentWorkingScheduleDocId} not found. It might have been deleted. Clearing active schedule ID. A new draft will be attempted on the next cycle if content exists.`);
                currentWorkingScheduleDocId = null; // Clear the ID, next cycle will try to create a new draft
                return;
            }

            const existingData = docSnap.data();
            const scheduleDataForUpdate = {
                // name: existingData.name, // Preserve the existing name (could be user-set or auto-draft name)
                html: allTablesData,
                meta: allTableMeta,
                activeTableId: activeTableId || tablesContainer.querySelector('table')?.id || 'tbl_1',
                // createdAt: existingData.createdAt, // Preserve original creation timestamp
                lastUpdatedAt: serverTimestamp(),
                lastUpdatedBy: fbUserId || "anonymous",
                // isAutoDraft: existingData.isAutoDraft // Preserve the isAutoDraft flag
            };
            
            // Explicitly carry over fields that should not change during an auto-save update
            if (existingData.name) scheduleDataForUpdate.name = existingData.name;
            if (existingData.createdAt) scheduleDataForUpdate.createdAt = existingData.createdAt;
            if (typeof existingData.isAutoDraft === 'boolean') { // Check if isAutoDraft was ever set
                scheduleDataForUpdate.isAutoDraft = existingData.isAutoDraft;
            }


            await setDoc(docRef, scheduleDataForUpdate, { merge: true }); // Use merge:true to only update specified fields
            showMessage(`Auto-saved to "${scheduleDataForUpdate.name || 'current schedule'}"`, 'success', 2000);
        } catch (error) {
            console.error(`Error auto-saving schedule ID ${currentWorkingScheduleDocId}:`, error);
            showMessage(`Auto-save failed for "${currentWorkingScheduleDocId}". Error: ${error.message}`, "error", 3000);
        }
    }


    async function loadAndRenderSharedSchedulesFromFirestore() {
        if (!fbDb || !fbIsAuthReady) {
            showMessage("Firebase not ready. Cannot load shared schedules.", "error");
            if (sharedScheduleListContainerElement) sharedScheduleListContainerElement.innerHTML = '<p>Connect to Firebase to see shared schedules.</p>';
            return;
        }
        if (!sharedScheduleListContainerElement) return;

        showGeneralLoading(true);
        sharedScheduleListContainerElement.innerHTML = '<p>Loading shared schedules from Cloud...</p>';
        let querySnapshot;
        try {
            const sharedSchedulesCollectionRef = collection(fbDb, "artifacts", appId, "public/data/sharedSchedules");
            // Query for non-draft schedules first, then drafts if needed, or filter client-side.
            // For simplicity, load all and potentially filter/sort in renderSharedScheduleList.
            // Order by lastUpdatedAt descending to show most recent first.
            let q = query(sharedSchedulesCollectionRef, orderBy("lastUpdatedAt", "desc"));
            console.log("Attempting to load shared schedules sorted by lastUpdatedAt desc.");
            querySnapshot = await getDocs(q);
        } catch (error) {
            console.error("Error loading shared schedules with primary sort (lastUpdatedAt):", error);
            // Fallback sort if index for lastUpdatedAt is missing or causes error
            if (error.message.toLowerCase().includes("index")) {
                showMessage("Primary sort by lastUpdated failed. Trying fallback sort by creation date.", "info", 5000);
                console.warn("Firestore query for shared schedules (lastUpdatedAt) failed due to missing index. Trying fallback (createdAt). Error:", error.message);
            } else {
                showMessage("Error loading schedules. Trying fallback sort by creation date.", "info", 5000);
                console.warn("An error occurred loading schedules by lastUpdatedAt. Trying fallback (createdAt). Error:", error.message);
            }
            try {
                const sharedSchedulesCollectionRef = collection(fbDb, "artifacts", appId, "public/data/sharedSchedules");
                console.log("Attempting to load shared schedules with fallback sort by createdAt desc.");
                let qFallback = query(sharedSchedulesCollectionRef, orderBy("createdAt", "desc"));
                querySnapshot = await getDocs(qFallback);
            } catch (fallbackError) {
                console.error("Error loading shared schedules with fallback sort (createdAt):", fallbackError);
                showMessage(`Failed to load shared schedules. Error: ${fallbackError.message}`, "error");
                sharedScheduleListContainerElement.innerHTML = `<p>Error loading shared schedules. Please check console.</p>`;
                showGeneralLoading(false);
                return;
            }
        }

        const schedules = [];
        querySnapshot.forEach((docSnap) => {
            schedules.push({ id: docSnap.id, ...docSnap.data() });
        });
        renderSharedScheduleList(schedules); // This function will now handle rendering
        sharedScheduleListContainerElement.style.display = 'block';
        showGeneralLoading(false);
    }

    function renderSharedScheduleList(schedulesArray) {
        if (!sharedScheduleListContainerElement) return;
        sharedScheduleListContainerElement.innerHTML = '';

        // Separate drafts from regular schedules if needed, or just display all
        // For now, display all, maybe with a "(Draft)" suffix if isAutoDraft is true
        const sortedSchedules = schedulesArray.sort((a, b) => {
            const dateA = a.lastUpdatedAt?.toDate ? a.lastUpdatedAt.toDate() : (a.createdAt?.toDate ? a.createdAt.toDate() : new Date(0));
            const dateB = b.lastUpdatedAt?.toDate ? b.lastUpdatedAt.toDate() : (b.createdAt?.toDate ? b.createdAt.toDate() : new Date(0));
            return dateB - dateA; // Sort descending by date
        });


        if (!sortedSchedules || sortedSchedules.length === 0) {
            sharedScheduleListContainerElement.innerHTML = '<p>No shared schedules saved to Cloud yet.</p>'; return;
        }

        sortedSchedules.forEach(schedule => {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'shared-schedule-item';

            let dateToShow = 'N/A';
            if (schedule.lastUpdatedAt && schedule.lastUpdatedAt.toDate) {
                dateToShow = `Updated: ${schedule.lastUpdatedAt.toDate().toLocaleString()}`;
            } else if (schedule.createdAt && schedule.createdAt.toDate) {
                dateToShow = `Created: ${schedule.createdAt.toDate().toLocaleString()}`;
            }

            const updatedByText = schedule.lastUpdatedBy ? ` (by ${schedule.lastUpdatedBy.substring(0,8)}...)` : '';
            const draftSuffix = schedule.isAutoDraft ? " (Draft)" : "";
            const displayName = `${schedule.name}${draftSuffix}`;

            itemDiv.innerHTML = `
                <span data-schedule-id="${schedule.id}" title="Load shared schedule: ${displayName}">${displayName}${updatedByText}</span>
                <span class="schedule-date">${dateToShow}</span>
                <button data-schedule-id="${schedule.id}" title="Delete shared schedule '${displayName}' from Cloud">Delete</button>
            `;
            sharedScheduleListContainerElement.appendChild(itemDiv);
        });
    }

    async function loadSelectedSharedScheduleFromFirestore(scheduleDocId, isDefaultLoad = false) {
        if (!fbDb || !fbIsAuthReady) {
            if (!isDefaultLoad) showMessage("Firebase not ready. Cannot load shared schedule.", "error");
            else console.warn("loadSelectedSharedScheduleFromFirestore: Firebase not ready for default load.");
            return false;
        }
        if (!tablesContainer || !tableTabs) {
            console.error("loadSelectedSharedScheduleFromFirestore: Critical DOM elements missing (tablesContainer or tableTabs).");
            return false;
        }

        showGeneralLoading(true);
        try {
            const docRef = doc(fbDb, "artifacts", appId, "public/data/sharedSchedules", scheduleDocId);
            const docSnap = await getDoc(docRef);

            if (docSnap.exists()) {
                const scheduleData = docSnap.data();
                tablesContainer.innerHTML = scheduleData.html; // Load table HTML
                const tableMeta = scheduleData.meta || {}; // Load table metadata

                tableTabs.innerHTML = ''; // Clear existing tabs
                tablesContainer.querySelectorAll('table').forEach(table => {
                    const id = table.id;
                    const metaInfo = tableMeta[id] || {};
                    const name = metaInfo.name || `Table ${tableTabs.children.length + 1}`;
                    table.dataset.tableName = name; // Set table name
                    addTabButton(id, name); // Add tab for the table
                    // Ensure all cells are editable
                    table.querySelectorAll('td, th, .merged-cell-overlay').forEach(cell => cell.contentEditable = 'true');
                });

                activeTableId = scheduleData.activeTableId || tablesContainer.querySelector('table')?.id || 'tbl_1';
                if (document.getElementById(activeTableId)) {
                    switchTable(activeTableId); // Switch to the active table
                } else if (tablesContainer.querySelector('table')) {
                    // Fallback if activeTableId is invalid but tables exist
                    switchTable(tablesContainer.querySelector('table').id);
                } else {
                    // If no tables loaded (e.g., empty schedule HTML), add a new default table
                    console.warn("Loaded schedule has no tables or activeTableId is invalid. Adding new table.");
                    addNewTable(true); // true for initial/silent add
                }
                
                currentWorkingScheduleDocId = scheduleDocId; // Set current working document ID

                if (!isDefaultLoad) {
                    const displayName = scheduleData.name + (scheduleData.isAutoDraft ? " (Draft)" : "");
                    showMessage(`Shared schedule "${displayName}" loaded from Cloud!`, 'success');
                } else {
                     console.log(`Default schedule "${scheduleData.name}" loaded.`);
                }

                if (sharedScheduleListContainerElement) sharedScheduleListContainerElement.style.display = 'none'; // Hide list after loading
                rebuildAndRenderSummary(); // Update summary table
                updateAllMergeOverlays(); // Recalculate merged cell overlays
                return true;
            } else {
                if (!isDefaultLoad) showMessage(`Shared schedule with ID "${scheduleDocId}" not found in Cloud.`, "error");
                else console.log(`Default schedule ID "${scheduleDocId}" not found.`)
                currentWorkingScheduleDocId = null; // Clear ID if not found
                return false;
            }
        } catch (error) {
            console.error("Error loading selected shared schedule from Firestore:", error);
            if (!isDefaultLoad) showMessage(`Failed to load shared schedule. Error: ${error.message}`, "error");
            currentWorkingScheduleDocId = null; // Clear ID on error
            return false;
        } finally {
            showGeneralLoading(false);
        }
    }

    async function loadLatestSharedScheduleAsDefault() {
        if (!fbDb || !fbIsAuthReady) {
            console.log("loadLatestSharedScheduleAsDefault: Firebase not ready.");
            return false;
        }
        showGeneralLoading(true);
        console.log("Attempting to load the latest shared schedule as default...");
        let querySnapshot;
        let loadedSuccessfully = false;

        try {
            const schedulesRef = collection(fbDb, "artifacts", appId, "public/data/sharedSchedules");
            // Try to get the most recently updated non-draft schedule first.
            // This might require a composite index on (isAutoDraft, lastUpdatedAt)
            // For simplicity, we'll fetch by lastUpdatedAt and prefer non-drafts if multiple match.
            // Or, if drafts are common, maybe just load the absolute latest.
            
            // For now, just load the absolute latest updated document.
            const qPrimary = query(schedulesRef, orderBy("lastUpdatedAt", "desc"), limit(1));
            console.log("Attempting to load latest schedule sorted by lastUpdatedAt desc, limit 1.");
            querySnapshot = await getDocs(qPrimary);

            if (!querySnapshot.empty) {
                const latestScheduleDoc = querySnapshot.docs[0];
                console.log(`Latest schedule (primary sort by lastUpdatedAt) found: ID = ${latestScheduleDoc.id}, Name = ${latestScheduleDoc.data().name}`);
                loadedSuccessfully = await loadSelectedSharedScheduleFromFirestore(latestScheduleDoc.id, true);
            } else {
                console.log("No shared schedules found with primary sort by lastUpdatedAt.");
            }
        } catch (error) {
            console.error("Error loading latest shared schedule with primary sort (lastUpdatedAt):", error);
            if (error.message.toLowerCase().includes("index")) {
                console.warn("Firestore query for latest schedule (lastUpdatedAt) failed. Trying fallback (createdAt). Error:", error.message);
                // showMessage("Loading latest schedule by update time failed. Trying by creation time.", "info", 5000);
            } else {
                // showMessage("Error loading latest schedule. Trying by creation time.", "info", 5000);
                console.warn("An error occurred loading latest schedule by lastUpdatedAt. Trying fallback (createdAt). Error:", error.message);
            }
            // Fallback to createdAt if lastUpdatedAt query fails (e.g. missing index)
            try {
                const schedulesRef = collection(fbDb, "artifacts", appId, "public/data/sharedSchedules");
                console.log("Attempting to load latest schedule with fallback sort by createdAt desc, limit 1.");
                const qFallback = query(schedulesRef, orderBy("createdAt", "desc"), limit(1));
                querySnapshot = await getDocs(qFallback);
                if (!querySnapshot.empty) {
                    const latestScheduleDoc = querySnapshot.docs[0];
                    console.log(`Latest schedule (fallback sort by createdAt) found: ID = ${latestScheduleDoc.id}, Name = ${latestScheduleDoc.data().name}`);
                    loadedSuccessfully = await loadSelectedSharedScheduleFromFirestore(latestScheduleDoc.id, true);
                } else {
                    console.log("No shared schedules found with fallback sort by createdAt either.");
                }
            } catch (fallbackError) {
                console.error("Error loading latest shared schedule with fallback sort (createdAt):", fallbackError);
                // showMessage("Could not load the latest schedule automatically (fallback failed).", "error");
            }
        } finally {
            showGeneralLoading(false);
        }

        if (!loadedSuccessfully) {
            console.log("No latest schedule loaded from Firestore. Initializing default table setup.");
            currentWorkingScheduleDocId = null; // Ensure it's null if nothing loaded
        }
        return loadedSuccessfully;
    }


    async function confirmAndDeleteSharedScheduleFromFirestore(scheduleDocId, scheduleName) {
        if (!fbDb || !fbIsAuthReady) {
            showMessage("Firebase not ready. Cannot delete shared schedule.", "error"); return;
        }
        const displayName = scheduleName.includes("(Draft)") ? scheduleName : `${scheduleName} (and any associated drafts if this is the primary)`;
        if (await customConfirm(`Are you sure you want to delete shared schedule "${displayName}" from Cloud? This cannot be undone and affects all users.`)) {
            showGeneralLoading(true);
            try {
                const docRef = doc(fbDb, "artifacts", appId, "public/data/sharedSchedules", scheduleDocId);
                await deleteDoc(docRef);
                // If the deleted schedule was the one being worked on, clear the ID
                if (currentWorkingScheduleDocId === scheduleDocId) {
                    currentWorkingScheduleDocId = null;
                    console.log("Deleted schedule was the current working draft. Cleared currentWorkingScheduleDocId.");
                }
                showMessage(`Shared schedule "${scheduleName}" deleted from Cloud.`, 'success');
                await loadAndRenderSharedSchedulesFromFirestore(); // Refresh the list
            } catch (error) {
                console.error("Error deleting shared schedule from Firestore:", error);
                showMessage(`Failed to delete shared schedule. Error: ${error.message}`, "error");
            } finally {
                showGeneralLoading(false);
            }
        }
    }

    async function exportAllSharedSchedulesFromFirestore() {
        if (!fbDb || !fbIsAuthReady) {
            showMessage("Firebase not ready. Cannot export shared schedules.", "error"); return;
        }
        showGeneralLoading(true);
        try {
            const schedulesCollectionRef = collection(fbDb, "artifacts", appId, "public/data/sharedSchedules");
            const q = query(schedulesCollectionRef, orderBy("createdAt", "desc")); // Export ordered by creation
            const querySnapshot = await getDocs(q);
            const schedulesToExport = [];
            querySnapshot.forEach((docSnap) => {
                const data = docSnap.data();
                schedulesToExport.push({
                    name: data.name,
                    html: data.html,
                    meta: data.meta,
                    activeTableId: data.activeTableId,
                    createdAt: data.createdAt && data.createdAt.toDate ? data.createdAt.toDate().toISOString() : null,
                    lastUpdatedAt: data.lastUpdatedAt && data.lastUpdatedAt.toDate ? data.lastUpdatedAt.toDate().toISOString() : null,
                    lastUpdatedBy: data.lastUpdatedBy || null,
                    isAutoDraft: typeof data.isAutoDraft === 'boolean' ? data.isAutoDraft : undefined // Include draft status
                });
            });

            if (schedulesToExport.length === 0) {
                showMessage('No shared schedules in Cloud to export.', 'info');
                showGeneralLoading(false);
                return;
            }

            const blob = new Blob([JSON.stringify(schedulesToExport, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = `shared_schedules_${appId}_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a); a.click(); document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showMessage('All shared schedules exported successfully!', 'success');
        } catch (error) {
            console.error("Error exporting shared schedules from Firestore:", error);
            showMessage(`Failed to export shared schedules. Error: ${error.message}`, "error");
        } finally {
            showGeneralLoading(false);
        }
    }

    async function handleSharedSchedulesImport(event) {
        if (!fbDb || !fbIsAuthReady) {
            showMessage("Firebase not ready. Cannot import shared schedules.", "error"); return;
        }
        const file = event.target.files[0];
        if (!file) { showMessage('No file selected for import.', 'info'); return; }
        if (file.type !== 'application/json') {
            showMessage('Invalid file type. Please select a .json file exported from this app.', 'error');
            event.target.value = ''; // Clear file input
            return;
        }

        showGeneralLoading(true);
        const reader = new FileReader();
        reader.onload = async (e) => {
            try {
                const importedSchedulesData = JSON.parse(e.target.result);
                if (!Array.isArray(importedSchedulesData)) {
                    showMessage('Invalid schedule file format. Expected an array of schedules.', 'error'); return;
                }

                let importedCount = 0, skippedCount = 0;
                const schedulesCollectionRef = collection(fbDb, "artifacts", appId, "public/data/sharedSchedules");

                for (const schedule of importedSchedulesData) {
                    // Basic validation of schedule object structure
                    if (schedule && typeof schedule.name === 'string' && typeof schedule.html === 'string' && 
                        typeof schedule.meta === 'object' && (typeof schedule.activeTableId === 'string' || schedule.activeTableId === null)) {
                        
                        // Check for existing schedule with the same name
                        const q = query(schedulesCollectionRef, where("name", "==", schedule.name));
                        const existingSnapshot = await getDocs(q);
                        
                        if (!existingSnapshot.empty) {
                             if (await customConfirm(`A shared schedule named "${schedule.name}" already exists. Overwrite?`)) {
                                for(const docToDel of existingSnapshot.docs) { // Delete all matches
                                    await deleteDoc(docToDel.ref);
                                }
                            } else {
                                skippedCount++;
                                continue; // Skip if user chooses not to overwrite
                            }
                        }
                        // Add the new schedule
                        await addDoc(schedulesCollectionRef, {
                            name: schedule.name,
                            html: schedule.html,
                            meta: schedule.meta,
                            activeTableId: schedule.activeTableId,
                            createdAt: schedule.createdAt ? new Date(schedule.createdAt) : serverTimestamp(), // Convert ISO string back to Date or use serverTimestamp
                            lastUpdatedAt: schedule.lastUpdatedAt ? new Date(schedule.lastUpdatedAt) : serverTimestamp(),
                            lastUpdatedBy: schedule.lastUpdatedBy || fbUserId || "anonymous",
                            isAutoDraft: typeof schedule.isAutoDraft === 'boolean' ? schedule.isAutoDraft : false // Default to false if not specified
                        });
                        importedCount++;
                    } else {
                        console.warn("Skipping invalid schedule object during import:", schedule);
                        skippedCount++;
                    }
                }
                showMessage(`Shared schedules import to Cloud: ${importedCount} imported/overwritten, ${skippedCount} skipped.`, 'success', 5000);
                // Refresh list if it was open or if any schedules were imported
                if (sharedScheduleListContainerElement && (sharedScheduleListContainerElement.style.display === 'block' || importedCount > 0)) {
                    await loadAndRenderSharedSchedulesFromFirestore();
                }
            } catch (error) {
                console.error("Error processing shared schedule file for Firestore import:", error);
                showMessage('Error processing schedule file. Ensure it is a valid JSON export from this app.', 'error', 5000);
            }
            finally {
                event.target.value = ''; // Clear file input
                showGeneralLoading(false);
            }
        };
        reader.onerror = () => {
            showMessage('Failed to read the schedule file.', 'error');
            event.target.value = ''; // Clear file input
            showGeneralLoading(false);
        };
        reader.readAsText(file);
    }

    // --- Autocomplete for Cell Input ---
    function showCellAutocompleteSuggestions(cell, inputText) {
        if (!autocompleteSuggestionsDiv) return;
        const namesForAutocomplete = currentNameListSession === 'pagi' ? namesPagiShared : namesPetangShared;
        
        // Get text before " // " for matching
        let textForMatchingInput = String(inputText || '').split(' // ')[0];
        // Further refine: only match against the last word or a sequence that makes sense
        const wordsForMatching = textForMatchingInput.split(/\s+/).filter(word => !word.startsWith('*')); // Exclude starred items from becoming match triggers
        const textForMatching = wordsForMatching.join(' ').toLowerCase().trim(); // Match against the whole non-starred part

        if (!textForMatching) { // If no text to match (e.g., only starred items or empty)
            hideCellAutocompleteSuggestions();
            return;
        }

        const filteredSuggestions = namesForAutocomplete.filter(name => {
            const nameStr = String(name || '').toLowerCase().trim();
            return nameStr.startsWith(textForMatching) && nameStr !== textForMatching; // Starts with and is not an exact match
        });

        if (filteredSuggestions.length > 0) {
            activeCellForAutocomplete = cell; // The TD or TH element
            autocompleteSuggestionsDiv.innerHTML = ''; // Clear previous suggestions
            filteredSuggestions.slice(0, 10).forEach(suggestion => { // Limit to 10 suggestions
                const item = document.createElement('div');
                item.className = 'suggestion-item';
                item.textContent = suggestion;
                item.addEventListener('mousedown', (e) => { // Use mousedown to fire before blur
                    e.preventDefault(); // Prevent blur on cell
                    selectCellAutocompleteSuggestion(suggestion);
                });
                autocompleteSuggestionsDiv.appendChild(item);
            });

            const cellRect = cell.getBoundingClientRect();
            autocompleteSuggestionsDiv.style.left = `${cellRect.left + window.scrollX}px`;
            autocompleteSuggestionsDiv.style.top = `${cellRect.bottom + window.scrollY}px`;
            autocompleteSuggestionsDiv.style.minWidth = `${cellRect.width}px`;
            autocompleteSuggestionsDiv.style.display = 'block';
            currentAutocompleteIndex = -1; // Reset selection index
        } else {
            hideCellAutocompleteSuggestions();
        }
    }

    function hideCellAutocompleteSuggestions() {
        if (autocompleteSuggestionsDiv) {
            autocompleteSuggestionsDiv.style.display = 'none';
        }
        activeCellForAutocomplete = null;
        currentAutocompleteIndex = -1;
    }

    function selectCellAutocompleteSuggestion(suggestionText) {
        if (activeCellForAutocomplete) {
            const targetCell = activeCellForAutocomplete; // This is the TD/TH
            const overlay = targetCell.querySelector('.merged-cell-overlay'); // Check if it's a merged cell
            const contentNode = overlay || targetCell; // Edit overlay if exists, else the cell itself

            const currentFullText = contentNode.textContent;
            const remarkPart = currentFullText.includes(' // ') ? currentFullText.substring(currentFullText.indexOf(' // ')) : '';
            const contentBeforeRemark = currentFullText.split(' // ')[0];
            
            // Preserve starred items from the original content before remark
            const starWordsBeforeRemark = contentBeforeRemark.split(/\s+/).filter(word => word.startsWith('*')).join(' ');

            let newText = suggestionText;
            if (starWordsBeforeRemark) { // Append existing starred items
                newText += ' ' + starWordsBeforeRemark;
            }
            newText = (newText.trim() + remarkPart).trim(); // Add remark back

            contentNode.textContent = newText;
            
            hideCellAutocompleteSuggestions();
            rebuildAndRenderSummary(); // Update summary

            // Set cursor to end of the cell
            contentNode.focus();
            const range = document.createRange();
            const sel = window.getSelection();
            if (contentNode.childNodes.length > 0) {
                range.selectNodeContents(contentNode);
                range.collapse(false); // false to collapse to end
            } else { // Handle empty cell case
                range.setStart(contentNode, 0);
                range.collapse(true);
            }
            sel.removeAllRanges();
            sel.addRange(range);
        }
    }
    
    function updateCellSuggestionHighlight() {
        if (!autocompleteSuggestionsDiv || autocompleteSuggestionsDiv.style.display === 'none') return;
        const items = autocompleteSuggestionsDiv.querySelectorAll('.suggestion-item');
        items.forEach((item, index) => {
            item.classList.toggle('active-suggestion', index === currentAutocompleteIndex);
        });
    }


    // --- DOMContentLoaded: Initialization and Event Listeners ---
    document.addEventListener('DOMContentLoaded', () => {
        // Cache DOM elements
        scheduleTitleElement = document.getElementById('scheduleTitle');
        tablesContainer = document.getElementById('tablesContainer');
        tableTabs = document.getElementById('tableTabs');
        nameModal = document.getElementById('nameModal');
        nameModalContent = document.getElementById('nameModalContent');
        nameModalHeader = document.getElementById('nameModalHeader');
        nameListContainer = document.getElementById('nameList');
        newNameInput = document.getElementById('newNameInput');
        sharedScheduleListContainerElement = document.getElementById('sharedScheduleListContainer');
        summaryTableElement = document.getElementById('summaryTable');
        summaryTableContainerElement = document.getElementById('summaryTableContainer');
        customMessageBox = document.getElementById('customMessageBox');
        fileInputElement = document.getElementById('fileInput');
        directCopyFullHtmlButtonElement = document.getElementById('directCopyFullHtmlBtn');
        closeNameModalButtonStandardElement = document.getElementById('closeNameModalBtnStandard');
        nameListImportFileInputElement = document.getElementById('nameListImportFile');
        searchNameInputElement = document.getElementById('searchNameInput');
        sharedScheduleImportFileInputElement = document.getElementById('sharedScheduleImportFile');
        userIdDisplayElement = document.getElementById('userIdDisplay');
        namePagiTabElement = document.getElementById('namePagiTab');
        namePetangTabElement = document.getElementById('namePetangTab');
        loadingIndicatorModalElement = document.getElementById('loadingIndicatorModal');
        nameModalTitleElement = document.getElementById('nameModalTitle');
        generalLoadingIndicatorElement = document.getElementById('generalLoadingIndicator');
        controlsTogglerElement = document.getElementById('controlsToggler');
        collapsibleButtonBarsElement = document.getElementById('collapsibleButtonBars');
        downloadPdfButtonElement = document.getElementById('downloadPdfBtn');
        pdfContentElement = document.getElementById('pdfContent');

        // Create autocomplete suggestions div and append to body
        autocompleteSuggestionsDiv = document.createElement('div');
        autocompleteSuggestionsDiv.id = 'autocompleteSuggestions';
        document.body.appendChild(autocompleteSuggestionsDiv);
        
        // Ensure controls are hidden by default
        if (controlsTogglerElement && collapsibleButtonBarsElement) {
            collapsibleButtonBarsElement.classList.remove('open'); // Ensure it's closed
            controlsTogglerElement.setAttribute('aria-expanded', 'false');
            const textSpan = controlsTogglerElement.querySelector('span');
            if (textSpan) textSpan.textContent = 'Show Controls'; // Set initial text
        }


        // Critical DOM elements check
        if (!tablesContainer || !tableTabs || !nameModal || !summaryTableElement || !scheduleTitleElement || !sharedScheduleListContainerElement || !generalLoadingIndicatorElement || !summaryTableContainerElement || !controlsTogglerElement || !collapsibleButtonBarsElement || !downloadPdfButtonElement || !pdfContentElement) {
            console.error("CRITICAL DOM elements missing. App cannot initialize correctly. Please check HTML structure.");
            document.body.innerHTML = "<p style='color:red; text-align:center; font-size:1.2em;'>Error: Application failed to initialize due to missing critical page elements. Please check the console for details.</p>";
            return;
        }

        // Firebase Authentication State Change Listener
        if (fbAuth) {
            onAuthStateChanged(fbAuth, async (user) => {
                if (user) {
                    fbUserId = user.uid;
                    fbIsAuthReady = true;
                    if(userIdDisplayElement) userIdDisplayElement.textContent = `User ID: ${fbUserId}`;
                    console.log("Firebase Auth: User is signed in.", fbUserId);

                    // Unsubscribe from previous listeners if they exist
                    if (unsubscribePagiShared) unsubscribePagiShared();
                    if (unsubscribePetangShared) unsubscribePetangShared();
                    // Listen to shared name lists
                    unsubscribePagiShared = listenToSharedNameList('pagi');
                    unsubscribePetangShared = listenToSharedNameList('petang');

                    // Re-render name list if modal is open
                    if (nameModal && nameModal.style.display === 'flex' && searchNameInputElement) {
                        renderNameListFromFirestore(searchNameInputElement.value);
                    }
                    
                    // Attempt to load the latest shared schedule as default
                    const loadedDefault = await loadLatestSharedScheduleAsDefault();
                    if (!loadedDefault) {
                        // If no default shared schedule was loaded, set up initial table state from HTML or create new
                        setupInitialTableState(); 
                    }
                    // currentWorkingScheduleDocId will be set if a default is loaded, otherwise it's null.
                    // The autoSaveCurrentSchedule will handle creating a draft if needed.

                    rebuildAndRenderSummary(); // Initial summary render

                    // Start auto-save interval
                    if (autoSaveIntervalId) clearInterval(autoSaveIntervalId); // Clear existing interval
                    autoSaveIntervalId = setInterval(autoSaveCurrentSchedule, AUTO_SAVE_INTERVAL);
                    console.log("Auto-save interval started.");

                } else {
                    // User is signed out or not yet signed in
                    fbIsAuthReady = false; fbUserId = null;
                    if(userIdDisplayElement) userIdDisplayElement.textContent = "User ID: Authenticating...";
                    console.log("Firebase Auth: User is signed out. Attempting to sign in...");
                    try {
                        // Try to sign in with custom token if provided by environment (e.g., Canvas)
                        if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token && __initial_auth_token.trim() !== '') {
                            console.log("Firebase Auth: Attempting signInWithCustomToken.");
                            await signInWithCustomToken(fbAuth, __initial_auth_token);
                        } else {
                            // Fallback to anonymous sign-in if no custom token
                            console.log("Firebase Auth: Attempting signInAnonymously.");
                            await signInAnonymously(fbAuth);
                        }
                        // onAuthStateChanged will be called again with the new user
                    } catch (error) {
                        console.error("Firebase Auth: Error during sign-in:", error);
                        showMessage(`Firebase Auth failed. Cloud features may not work. Error: ${error.message}`, "error", 7000);
                        if(userIdDisplayElement) userIdDisplayElement.textContent = `User ID: Auth Error`;
                        // Setup basic table state even if auth fails, so app is usable locally
                        setupInitialTableState();
                        rebuildAndRenderSummary();
                    }
                }
            });
        } else {
             // Firebase Auth service itself failed to initialize
             if(userIdDisplayElement) userIdDisplayElement.textContent = "User ID: Firebase Auth Not Initialized";
             console.error("Firebase Auth: fbAuth object is not available. Firebase did not initialize correctly.");
             showMessage("Critical Error: Firebase Auth service could not be initialized. Cloud features are disabled.", "error", 10000);
             setupInitialTableState(); // Setup basic table state for local use
             rebuildAndRenderSummary();
        }

        loadScheduleTitleFromLocalStorage(); // Load and handle main schedule title
        initializeEventListeners(); // Setup all other event listeners
        handleNameListSessionSwitch('pagi'); // Set initial name list session
    });

    function setupInitialTableState() {
        console.log("Running setupInitialTableState...");
        const existingTables = tablesContainer.querySelectorAll('table');

        // If a schedule is already loaded (currentWorkingScheduleDocId is set) and tables are present,
        // ensure the activeTableId is valid and switch to it.
        if (currentWorkingScheduleDocId && existingTables.length > 0 && document.getElementById(activeTableId)) {
            console.log("setupInitialTableState: A schedule is already loaded and active.");
            switchTable(activeTableId); // Ensure UI consistency for the loaded active table
            return;
        }
        
        console.log("setupInitialTableState: No specific schedule loaded via Firestore default. Initializing from HTML or creating new.");
        tableTabs.innerHTML = ''; // Clear any existing tabs
        // currentWorkingScheduleDocId remains null here, auto-save will handle draft creation if changes occur.
        activeTableId = null; // Reset activeTableId

        // Check for tables defined in the initial HTML
        const table1 = document.getElementById('tbl_1');
        const table2 = document.getElementById('tbl_2');

        if (existingTables.length > 0) {
            // If tables exist in HTML, create tabs for them
            existingTables.forEach((table, index) => {
                const id = table.id || `tbl_html_${index + 1}`; // Ensure table has an ID
                if (!table.id) table.id = id;
                const name = table.dataset.tableName || `Sheet ${index + 1}`;
                table.dataset.tableName = name; // Ensure dataset has name
                addTabButton(id, name);
                if (index === 0) { // Make the first HTML table active by default
                    activeTableId = id;
                }
                // Ensure cells are editable
                table.querySelectorAll('td, th, .merged-cell-overlay').forEach(cell => cell.contentEditable = 'true');
            });
            if (activeTableId) {
                switchTable(activeTableId);
            } else if (existingTables[0]) { // Fallback if activeTableId somehow wasn't set
                switchTable(existingTables[0].id);
            }
        } else {
            // No tables in HTML, add a new default one
            console.warn("setupInitialTableState: No tables found in HTML, adding a new default table.");
            addNewTable(true); // true for initial/silent add
        }
        
        // Final check for activeTableId
        if (!activeTableId && tablesContainer.querySelector('table')) {
            activeTableId = tablesContainer.querySelector('table').id;
            switchTable(activeTableId);
            console.warn("setupInitialTableState: Fallback to first table in DOM as active after initial setup.");
        } else if (!activeTableId) {
            console.error("setupInitialTableState: Critical error, no active table could be established even after attempting to add one.");
        }
        updateAllMergeOverlays(); // Ensure overlays are correct for initial HTML tables
    }


    function loadScheduleTitleFromLocalStorage() {
        const savedTitle = localStorage.getItem(SCHEDULE_TITLE_KEY);
        if (savedTitle && scheduleTitleElement) scheduleTitleElement.textContent = savedTitle;
        // Add blur event listener to save title when edited
        if (scheduleTitleElement) {
            scheduleTitleElement.addEventListener('blur', () => {
                localStorage.setItem(SCHEDULE_TITLE_KEY, scheduleTitleElement.textContent);
                showMessage('Schedule title saved (locally)!', 'success');
            });
        }
    }

    function initializeEventListeners() {
        // --- Main Controls ---
        if(controlsTogglerElement) controlsTogglerElement.addEventListener('click', toggleButtonBarsVisibility);
        if(directCopyFullHtmlButtonElement) directCopyFullHtmlButtonElement.addEventListener('click', attemptDirectCopyToClipboard);
        if(downloadPdfButtonElement) downloadPdfButtonElement.addEventListener('click', generateSchedulePdf);
        
        // --- Name Modal ---
        if(closeNameModalButtonStandardElement) closeNameModalButtonStandardElement.addEventListener('click', closeNameModal);
        if(nameModalHeader) { // Drag functionality for name modal
            nameModalHeader.addEventListener('mousedown', startDragModal);
            nameModalHeader.addEventListener('touchstart', startDragModal, { passive: false }); // Passive false to allow preventDefault
        }
        document.addEventListener('mousemove', dragModal);
        document.addEventListener('mouseup', stopDragModal);
        document.addEventListener('touchmove', dragModal, { passive: false });
        document.addEventListener('touchend', stopDragModal);

        // --- Excel and File I/O ---
        document.getElementById('excelBtnTrigger')?.addEventListener('click', exportActiveTableToExcel);
        document.getElementById('importExcelBtn')?.addEventListener('click', () => fileInputElement?.click());
        if(fileInputElement) fileInputElement.addEventListener('change', handleExcelFileImport);

        // --- Shared Schedule (Firestore) Buttons ---
        document.getElementById('saveSharedScheduleBtn')?.addEventListener('click', saveSharedScheduleToFirestore);
        document.getElementById('loadSharedScheduleBtn')?.addEventListener('click', loadAndRenderSharedSchedulesFromFirestore);
        document.getElementById('exportSharedSchedulesBtn')?.addEventListener('click', exportAllSharedSchedulesFromFirestore);
        document.getElementById('importSharedSchedulesBtn')?.addEventListener('click', () => sharedScheduleImportFileInputElement?.click());
        if(sharedScheduleImportFileInputElement) sharedScheduleImportFileInputElement.addEventListener('change', handleSharedSchedulesImport);
        
        // Event delegation for loading/deleting shared schedules from the list
        if(sharedScheduleListContainerElement) sharedScheduleListContainerElement.addEventListener('click', async (e) => {
            const targetSpan = e.target.closest('.shared-schedule-item span[data-schedule-id]');
            const targetButton = e.target.closest('.shared-schedule-item button[data-schedule-id]');
            if (targetSpan) { // Click on schedule name to load
                loadSelectedSharedScheduleFromFirestore(targetSpan.dataset.scheduleId);
            } else if (targetButton) { // Click on delete button
                const scheduleId = targetButton.dataset.scheduleId;
                const scheduleNameElement = targetButton.parentElement.querySelector('span[data-schedule-id]');
                const scheduleName = scheduleNameElement ? scheduleNameElement.textContent.split(' (by')[0] : 'this schedule'; // Get name for confirm dialog
                await confirmAndDeleteSharedScheduleFromFirestore(scheduleId, scheduleName);
            }
        });

        // --- Table Manipulation Buttons ---
        document.getElementById('clearActiveTableContentBtn')?.addEventListener('click', confirmAndClearActiveTableContent);
        document.getElementById('selectBtn')?.addEventListener('click', toggleCellSelectionMode);
        document.getElementById('mergeBtn')?.addEventListener('click', mergeSelectedTableCells);
        document.getElementById('deselectBtn')?.addEventListener('click', deselectAllTableCells);
        document.getElementById('unmergeBtn')?.addEventListener('click', unmergeActiveCellIfMerged);
        document.getElementById('addTableBtn')?.addEventListener('click', () => addNewTable());
        document.getElementById('renameTableBtn')?.addEventListener('click', promptAndRenameActiveTable);
        document.getElementById('deleteTableBtn')?.addEventListener('click', confirmAndDeleteActiveTable);

        // --- Row/Column Manipulation Buttons ---
        document.getElementById('addRowAboveBtn')?.addEventListener('click', addRowAboveToActiveTable);
        document.getElementById('addRowBelowBtn')?.addEventListener('click', addRowBelowToActiveTable);
        document.getElementById('addColLeftBtn')?.addEventListener('click', addColumnLeftToActiveTable);
        document.getElementById('addColRightBtn')?.addEventListener('click', addColumnRightToActiveTable);
        document.getElementById('deleteRowBtn')?.addEventListener('click', deleteClickedRowFromActiveTable);
        document.getElementById('deleteColBtn')?.addEventListener('click', deleteClickedColumnFromActiveTable);

        // --- Shared Name List Buttons & Inputs ---
        document.getElementById('nameListBtn')?.addEventListener('click', toggleNameListModalVisibility);
        document.getElementById('addNameBtnInModal')?.addEventListener('click', () => {
            if(newNameInput) addNameToSharedSessionInFirestore(newNameInput.value);
        });
        document.getElementById('importNameListBtn')?.addEventListener('click', () => nameListImportFileInputElement?.click());
        if(nameListImportFileInputElement) nameListImportFileInputElement.addEventListener('change', handleNameListImportFirestore);
        if(searchNameInputElement) searchNameInputElement.addEventListener('input', (e) => renderNameListFromFirestore(e.target.value));
        if(namePagiTabElement) namePagiTabElement.addEventListener('click', () => handleNameListSessionSwitch('pagi'));
        if(namePetangTabElement) namePetangTabElement.addEventListener('click', () => handleNameListSessionSwitch('petang'));
        
        // Event delegation for selecting/deleting names from the shared list
        if(nameListContainer) nameListContainer.addEventListener('click', async (e) => {
            const nameItemSpan = e.target.closest('.name-item span[data-name]');
            const deleteButton = e.target.closest('.name-item button[data-name-delete]');
            if (nameItemSpan) { // Click on name to select for insertion
                selectNameForCellInsertion(nameItemSpan.dataset.name);
            } else if (deleteButton) { // Click on delete button for a name
                await deleteNameFromSharedSessionInFirestore(deleteButton.dataset.nameDelete);
            }
        });

        // --- Table Cell Event Listeners (Input, Click, Blur for Autocomplete and Summary) ---
        if(tablesContainer) {
            // Click listener for cell selection and name insertion
            tablesContainer.addEventListener('click', handleTableCellClick);

            // Input listener for autocomplete and summary updates
            tablesContainer.addEventListener('input', (e) => {
                const cell = e.target; // Could be TD, TH, or .merged-cell-overlay
                const targetElement = cell.classList.contains('merged-cell-overlay') ? cell.parentElement : cell;

                if (targetElement && (targetElement.tagName === 'TD' || (targetElement.tagName === 'TH' && targetElement.closest('tbody'))) && targetElement.isContentEditable !== false) {
                    const text = cell.textContent; // Use cell.textContent which is the div if overlay, or td/th itself
                    // Only show autocomplete for data cells (not first column if it's 'Class', and not header cells in thead)
                    const isHeaderCellInTHead = targetElement.tagName === 'TH' && targetElement.closest('thead');
                    const isFirstColumnClassHeader = targetElement.closest('table')?.querySelector('thead th:first-child')?.textContent?.toLowerCase() === 'class' && targetElement.cellIndex === 0;

                    if (!isHeaderCellInTHead && !isFirstColumnClassHeader) {
                         showCellAutocompleteSuggestions(targetElement, text); // Pass the TD/TH as the anchor
                    } else {
                        hideCellAutocompleteSuggestions();
                    }
                    setTimeout(rebuildAndRenderSummary, 300); // Debounce summary update slightly
                }
            });

            // Blur listener for summary updates and hiding autocomplete
            tablesContainer.addEventListener('blur', (e) => {
                const cell = e.target;
                const targetElement = cell.classList.contains('merged-cell-overlay') ? cell.parentElement : cell;

                if (targetElement && (targetElement.tagName === 'TD' || targetElement.tagName === 'TH' || cell.classList.contains('merged-cell-overlay')) && targetElement.isContentEditable !== false) {
                    setTimeout(rebuildAndRenderSummary, 0); // Update summary immediately on blur
                    // Hide autocomplete if focus moves outside
                    setTimeout(() => {
                        if (autocompleteSuggestionsDiv && autocompleteSuggestionsDiv.style.display === 'block' &&
                            !autocompleteSuggestionsDiv.contains(document.activeElement) && // Not focusing on suggestions
                            activeCellForAutocomplete !== document.activeElement && // Not focusing back on the cell
                            (!activeCellForAutocomplete || activeCellForAutocomplete.querySelector('.merged-cell-overlay') !== document.activeElement) // Not focusing on overlay
                           ) {
                           hideCellAutocompleteSuggestions();
                        }
                    }, 150); // Delay to allow click on suggestion
                }
            }, true); // Use capture phase for blur
        }
        
        // --- Window/Document Level Event Listeners ---
        window.addEventListener('resize', () => { // Update merge overlays and hide autocomplete on resize
            updateAllMergeOverlays();
            hideCellAutocompleteSuggestions();
        });

        // Keyboard navigation for autocomplete suggestions
        document.addEventListener('keydown', (e) => {
            if (autocompleteSuggestionsDiv && autocompleteSuggestionsDiv.style.display === 'block' && activeCellForAutocomplete) {
                const items = autocompleteSuggestionsDiv.querySelectorAll('.suggestion-item');
                if (items.length === 0 && e.key !== 'Escape') return; 

                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    currentAutocompleteIndex = (currentAutocompleteIndex + 1) % items.length;
                    updateCellSuggestionHighlight();
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    currentAutocompleteIndex = (currentAutocompleteIndex - 1 + items.length) % items.length;
                    updateCellSuggestionHighlight();
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    if (currentAutocompleteIndex >= 0 && currentAutocompleteIndex < items.length) {
                        selectCellAutocompleteSuggestion(items[currentAutocompleteIndex].textContent);
                    } else { // If no suggestion selected, Enter might just confirm cell edit
                        hideCellAutocompleteSuggestions();
                        if(activeCellForAutocomplete) activeCellForAutocomplete.blur(); // Or handle as needed
                    }
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    hideCellAutocompleteSuggestions();
                } else if (e.key === 'Tab') { // Hide on Tab out
                    hideCellAutocompleteSuggestions();
                }
            }
        });

        // Global click listener to hide autocomplete if clicked outside
        document.addEventListener('click', (event) => {
            if (autocompleteSuggestionsDiv && autocompleteSuggestionsDiv.style.display === 'block') {
                const isClickInsideCell = activeCellForAutocomplete && activeCellForAutocomplete.contains(event.target);
                const isClickInsideOverlay = activeCellForAutocomplete && activeCellForAutocomplete.querySelector('.merged-cell-overlay')?.contains(event.target);
                const isClickInsideSuggestions = autocompleteSuggestionsDiv.contains(event.target);

                if (!isClickInsideCell && !isClickInsideSuggestions && !isClickInsideOverlay) {
                    hideCellAutocompleteSuggestions();
                }
            }
        });
    }

    // --- Modal Drag Functionality ---
    function startDragModal(e) {
        // Don't drag if clicking the close button
        if (e.target.closest('.modal-close-btn')) { isDraggingModal = false; return; }
        
        isDraggingModal = true;
        if(nameModalContent) nameModalContent.classList.add('dragging'); // Optional: style for dragging state
        
        const clientX = e.clientX || (e.touches && e.touches[0].clientX);
        const clientY = e.clientY || (e.touches && e.touches[0].clientY);
        
        // Temporarily fix position for smooth dragging calculations
        const rect = nameModalContent.getBoundingClientRect();
        nameModalContent.style.position = 'fixed'; // Ensure it's fixed for viewport-relative positioning
        nameModalContent.style.left = `${rect.left}px`;
        nameModalContent.style.top = `${rect.top}px`;
        nameModalContent.style.transform = 'none'; // Reset transform if it was centered using transform
        
        modalDragOffsetX = clientX - nameModalContent.offsetLeft;
        modalDragOffsetY = clientY - nameModalContent.offsetTop;

        if (e.type === 'touchstart') e.preventDefault(); // Prevent page scroll on touch
    }

    function dragModal(e) {
        if (!isDraggingModal || !nameModalContent) return;
        
        const clientX = e.clientX || (e.touches && e.touches[0].clientX);
        const clientY = e.clientY || (e.touches && e.touches[0].clientY);
        
        let newLeft = clientX - modalDragOffsetX;
        let newTop = clientY - modalDragOffsetY;

        // Constrain modal within viewport
        const modalRect = nameModalContent.getBoundingClientRect(); // Get current dimensions
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;

        if (newLeft < 0) newLeft = 0;
        if (newTop < 0) newTop = 0;
        if (newLeft + modalRect.width > viewportWidth) newLeft = viewportWidth - modalRect.width;
        if (newTop + modalRect.height > viewportHeight) newTop = viewportHeight - modalRect.height;
        
        nameModalContent.style.left = `${newLeft}px`;
        nameModalContent.style.top = `${newTop}px`;

        if (e.type === 'touchmove') e.preventDefault(); // Prevent page scroll on touch
    }

    function stopDragModal() {
        if (isDraggingModal && nameModalContent) {
            isDraggingModal = false;
            nameModalContent.classList.remove('dragging');
            // Optional: Re-center modal or revert position style if it was initially centered differently
            // For now, it stays where dragged.
        }
    }

    // --- Clipboard and Table Content ---
    async function attemptDirectCopyToClipboard() {
        const fullHtml = document.documentElement.outerHTML;
        try {
            await navigator.clipboard.writeText(fullHtml);
            showMessage('Full HTML copied to clipboard!', 'success');
        } catch (err) {
            console.warn('Direct copy to clipboard failed, trying fallback (document.execCommand):', err);
            const textarea = document.createElement('textarea');
            textarea.value = fullHtml;
            textarea.style.position = 'fixed'; textarea.style.left = '-9999px'; // Off-screen
            document.body.appendChild(textarea);
            textarea.select();
            try {
                const success = document.execCommand('copy');
                if (success) {
                    showMessage('Full HTML copied! (fallback method)', 'success');
                } else {
                    showMessage('Direct copy using execCommand failed. Could not copy.', 'error', 5000);
                }
            } catch (execErr) {
                console.error('execCommand copy failed:', execErr);
                showMessage('Direct copy failed completely. Could not copy.', 'error', 5000);
            }
            document.body.removeChild(textarea);
        }
    }

    async function confirmAndClearActiveTableContent() {
        const activeTableElement = document.getElementById(activeTableId);
        if (!activeTableElement) { showMessage('No active table to clear.', 'error'); return; }
        
        const tableName = activeTableElement.dataset.tableName || `Table ${activeTableId.split('_').pop()}`;
        if (await customConfirm(`Are you sure you want to clear all content and unmerge cells in "${tableName}"? This will not delete saved shared schedules.`)) {
            // Unmerge all cells in the active table first
            activeTableElement.querySelectorAll('.merged-cell-container').forEach(containerCell => {
                const mergeId = containerCell.dataset.mergeId;
                if(mergeId){
                    const cellsInGroup = activeTableElement.querySelectorAll(`[data-merge-id="${mergeId}"]`);
                    cellsInGroup.forEach(c => {
                        c.removeAttribute('data-merge-id');
                        c.classList.remove('merged-cell-container', 'subsumed-cell');
                        const overlay = c.querySelector('.merged-cell-overlay');
                        if (overlay) c.textContent = overlay.textContent; // Keep text from overlay
                        else c.innerHTML = ''; // Clear if no overlay
                        const overlayChild = c.querySelector('.merged-cell-overlay'); // Remove overlay div itself
                        if(overlayChild) overlayChild.remove();
                    });
                }
            });

            // Clear content from all data cells (tbody td and tbody th)
            activeTableElement.querySelectorAll('tbody td, tbody th').forEach(cell => {
                cell.innerHTML = ''; // Clear content
                cell.classList.remove('selected'); // Remove selection highlight
            });
            
            selectedCells = []; // Clear selection array
            rebuildAndRenderSummary(); // Update summary table
            updateAllMergeOverlays(); // Recalculate overlays (though all should be gone)
            showMessage(`Content of "${tableName}" cleared.`, 'success');
        }
    }

    // --- Tab Management ---
    function addTabButton(id, label) {
        if (!tableTabs) return null;
        const button = document.createElement('button');
        button.textContent = label; button.dataset.tableId = id;
        button.title = `Switch to table: ${label}`;
        button.onclick = () => switchTable(id);
        tableTabs.appendChild(button);
        return button;
    }

    function switchTable(id) {
        const targetTable = document.getElementById(id);
        // If target table doesn't exist, try to find the first table in the container
        if (!targetTable && tablesContainer) {
            const firstTableInDOM = tablesContainer.querySelector('table');
            if (firstTableInDOM) {
                id = firstTableInDOM.id; // Switch to the first available table
                console.warn(`SwitchTable: Target table for original ID not found, falling back to first table in DOM: ${id}.`);
            } else {
                // No tables exist at all
                if (tablesContainer && tablesContainer.children.length === 0) {
                    console.log("SwitchTable: No tables exist, adding a new one.");
                    addNewTable(true); // Add a new table if none exist (true for initial/silent)
                    return; // addNewTable will call switchTable
                }
                console.error(`SwitchTable: Target table for original ID not found and no fallback available.`);
                return;
            }
        } else if (!targetTable) {
             // This case should ideally not be reached if the above fallback works or addNewTable is called
             console.error(`SwitchTable: Target table for ID ${id} not found and tablesContainer is also missing.`);
             return;
        }

        console.log(`Switching to table: ${id}`);
        activeTableId = id;
        // Toggle 'active' class for tables and tabs
        if(tablesContainer) tablesContainer.querySelectorAll('table').forEach(t => t.classList.toggle('active', t.id === id));
        if(tableTabs) tableTabs.querySelectorAll('button').forEach(b => { b.classList.toggle('active', b.dataset.tableId === id); });
        
        deselectAllTableCells(); // Clear any cell selections from the previous table
        rebuildAndRenderSummary(); // Update summary for the new active table
        updateAllMergeOverlays(); // Update merge overlays for the new active table
        hideCellAutocompleteSuggestions(); // Hide any open autocomplete
    }

    function addNewTable(isInitial = false) {
        if (!tablesContainer || !tableTabs) {
            console.error("addNewTable: Critical DOM elements missing (tablesContainer or tableTabs).");
            return;
        }
        tableCount++; // Increment global table counter for unique IDs
        const defaultTableName = `Schedule ${tableTabs.children.length + 1}`;
        const label = isInitial ? defaultTableName : customPrompt('Enter new table name:', defaultTableName);

        if (!label && !isInitial) { // User cancelled prompt and not an initial setup
            showMessage('Table creation cancelled.', 'info');
            return;
        }

        const newTable = document.createElement('table');
        newTable.id = `tbl_${Date.now()}_${tableCount}`; // Unique ID
        newTable.dataset.tableName = label || defaultTableName; // Store name in dataset

        // Create table header
        const thead = newTable.createTHead();
        const headerRow = thead.insertRow();
        const defaultHeaders = ['Class/Time', '08:00-09:00', '09:00-10:00', '10:00-11:00', '11:00-12:00', '12:00-13:00'];
        defaultHeaders.forEach(headerText => {
            const th = document.createElement('th');
            th.contentEditable = 'true'; th.textContent = headerText;
            headerRow.appendChild(th);
        });

        // Create table body with a couple of sample rows
        const tbody = newTable.createTBody();
        for (let r = 0; r < 2; r++) { // Add 2 sample data rows
            const dataRow = tbody.insertRow();
            for (let c = 0; c < headerRow.cells.length; c++) {
                const td = dataRow.insertCell(); td.contentEditable = 'true';
                if (c === 0) td.textContent = `Sample Class ${String.fromCharCode(65 + r)}`; // e.g., Sample Class A
            }
        }

        tablesContainer.appendChild(newTable);
        addTabButton(newTable.id, label || defaultTableName);
        switchTable(newTable.id); // Make the new table active

        if (!isInitial) {
            showMessage(`Table "${label || defaultTableName}" added.`, 'success');
        } else {
            console.log(`Initial table "${label || defaultTableName}" created with ID ${newTable.id}.`);
        }
    }

    async function promptAndRenameActiveTable() {
        if (!tableTabs) return;
        const currentTab = tableTabs.querySelector('button.active');
        if (!currentTab) { showMessage('No active table to rename.', 'error'); return; }

        let tableIdToRename = currentTab.dataset.tableId;
        // Fallback if dataset.tableId is not set (e.g. older HTML structure)
        if (!tableIdToRename) {
            const match = currentTab.getAttribute('onclick')?.match(/'(tbl_.*?)'/);
            if (match && match[1]) tableIdToRename = match[1];
            else { showMessage('Could not identify table ID for renaming.', 'error'); return; }
        }
        
        const tableElement = document.getElementById(tableIdToRename);
        if (!tableElement) { showMessage(`Table element for ID ${tableIdToRename} not found.`, 'error'); return; }

        const oldName = tableElement.dataset.tableName || currentTab.textContent;
        const newName = customPrompt('Enter new table name:', oldName);

        if (newName && newName.trim() && newName.trim() !== oldName) {
            const trimmedNewName = newName.trim();
            currentTab.textContent = trimmedNewName; currentTab.title = `Switch to table: ${trimmedNewName}`;
            tableElement.dataset.tableName = trimmedNewName; // Update dataset
            showMessage(`Table renamed to "${trimmedNewName}".`, 'success');
        } else if (newName && newName.trim() === oldName) {
            showMessage('Name unchanged.', 'info');
        } else if (newName === null) { // User cancelled prompt
            showMessage('Rename cancelled.', 'info');
        } else { // Empty or invalid name
            showMessage('Invalid new name.', 'error');
        }
    }

    async function confirmAndDeleteActiveTable() {
        if (!tablesContainer || !tableTabs || tablesContainer.children.length <= 1) {
            showMessage('Cannot delete the last table.', 'error'); return;
        }
        const activeTab = tableTabs.querySelector('button.active');
        const tableIdToDelete = activeTab?.dataset.tableId;
        const tableElement = tableIdToDelete ? document.getElementById(tableIdToDelete) : null;
        const tableName = tableElement?.dataset.tableName || activeTab?.textContent || 'the active table';

        if (await customConfirm(`Delete table "${tableName}"? This cannot be undone.`)) {
            if (tableElement) tableElement.remove(); // Remove table from DOM
            else if (document.getElementById(activeTableId)) document.getElementById(activeTableId).remove(); // Fallback
            activeTab?.remove(); // Remove tab from tab bar

            // Switch to the first remaining tab, or add a new table if none are left (shouldn't happen due to check above)
            const firstRemainingTab = tableTabs.querySelector('button');
            if (firstRemainingTab) {
                const nextActiveId = firstRemainingTab.dataset.tableId || firstRemainingTab.getAttribute('onclick').match(/'(tbl_.*?)'/)[1];
                switchTable(nextActiveId);
            } else {
                // This case should be prevented by the initial check (tablesContainer.children.length <= 1)
                activeTableId = null;
                console.log("Last table deleted. Adding a new default table.");
                addNewTable(true); // true for initial/silent add
            }
            showMessage(`Table "${tableName}" deleted.`, 'success');
        }
    }

    // --- Row and Column Operations ---
    function addRowToTable(tableBody, rowIndex, numCols) {
        const row = tableBody.insertRow(rowIndex); // Insert at specified index, or append if -1
        for (let i = 0; i < numCols; i++) {
            const cell = row.insertCell(); cell.contentEditable = 'true';
        }
    }
    function addRowAboveToActiveTable() {
        const table = document.getElementById(activeTableId);
        if (!table || !table.tBodies[0] || table.rows.length === 0) return;
        const numCols = table.rows[0].cells.length; // Number of columns from header or first row
        // Determine insert index: above clicked row, or at the top if no cell clicked or clicked cell is header
        let insertAtIndex = (lastClickedCell && lastClickedCell.closest('tbody') && lastClickedCell.parentElement.rowIndex >= 0) 
                            ? lastClickedCell.parentElement.rowIndex 
                            : 0;
        addRowToTable(table.tBodies[0], insertAtIndex, numCols);
        rebuildAndRenderSummary(); updateAllMergeOverlays();
    }
    function addRowBelowToActiveTable() {
        const table = document.getElementById(activeTableId);
        if (!table || !table.tBodies[0] || table.rows.length === 0) return;
        const numCols = table.rows[0].cells.length;
        // Determine insert index: below clicked row, or at the end if no cell clicked or clicked cell is header
        let insertAtIndex = (lastClickedCell && lastClickedCell.closest('tbody') && lastClickedCell.parentElement.rowIndex >= 0) 
                            ? lastClickedCell.parentElement.rowIndex + 1 
                            : -1; // -1 appends to end of tbody
        addRowToTable(table.tBodies[0], insertAtIndex, numCols);
        rebuildAndRenderSummary(); updateAllMergeOverlays();
    }

    function addColumnToTable(table, colIndex) { // colIndex: -1 to append
        for (const row of table.rows) {
            const isHeaderRow = row.parentElement.tagName === 'THEAD';
            const cell = isHeaderRow ? document.createElement('th') : row.insertCell(colIndex === -1 ? row.cells.length : colIndex);
            cell.contentEditable = 'true';
            if (isHeaderRow) {
                cell.textContent = "New Header";
                // If inserting into header and not appending, use insertBefore for TH
                if (colIndex !== -1 && row.cells[colIndex] && isHeaderRow) {
                     row.insertBefore(cell, row.cells[colIndex]);
                } else if (isHeaderRow && colIndex === -1) { // Appending to header
                    row.appendChild(cell);
                }
                // For tbody rows, insertCell(colIndex) handles it correctly.
            }
        }
    }
    function addColumnLeftToActiveTable() {
        const table = document.getElementById(activeTableId);
        if (!table) return;
        // Determine insert index: left of clicked column, or at the beginning if no cell clicked
        let insertAtIndex = (lastClickedCell && lastClickedCell.cellIndex >= 0) 
                            ? lastClickedCell.cellIndex 
                            : 0;
        addColumnToTable(table, insertAtIndex);
        rebuildAndRenderSummary(); updateAllMergeOverlays();
    }
    function addColumnRightToActiveTable() {
        const table = document.getElementById(activeTableId);
        if (!table) return;
        // Determine insert index: right of clicked column, or at the end if no cell clicked
        let insertAtIndex = (lastClickedCell && lastClickedCell.cellIndex >= 0) 
                            ? lastClickedCell.cellIndex + 1 
                            : -1; // -1 appends
        addColumnToTable(table, insertAtIndex);
        rebuildAndRenderSummary(); updateAllMergeOverlays();
    }

    async function deleteClickedRowFromActiveTable() {
        if (!lastClickedCell) { showMessage('Click a cell in the row to delete.', 'info'); return; }
        const table = document.getElementById(activeTableId);
        if (!table || !table.tBodies[0]) { showMessage('No active table body.', 'error'); return; }
        
        const rowToDelete = lastClickedCell.closest('tr');
        if (!rowToDelete || rowToDelete.parentElement.tagName !== 'TBODY') { // Cannot delete header row this way
            showMessage('Cannot delete header. Click a data row cell.', 'error'); return;
        }
        if (table.tBodies[0].rows.length <= 1) { // Prevent deleting the last data row
            showMessage('Cannot delete the last data row.', 'error'); return;
        }
        if (await customConfirm('Delete this row?')) {
            rowToDelete.remove(); lastClickedCell = null; // Clear last clicked cell context
            deselectAllTableCells(); // Clear any selections
            rebuildAndRenderSummary(); updateAllMergeOverlays();
            showMessage('Row deleted.', 'success');
        }
    }
    async function deleteClickedColumnFromActiveTable() {
        if (!lastClickedCell) { showMessage('Click a cell in the column to delete.', 'info'); return; }
        const table = document.getElementById(activeTableId);
        if (!table) { showMessage('No active table.', 'error'); return; }
        if (table.rows[0] && table.rows[0].cells.length <= 1) { // Prevent deleting the last column
            showMessage('Cannot delete the last column.', 'error'); return;
        }
        
        const colIndexToDelete = lastClickedCell.cellIndex;
        if (await customConfirm('Delete this column?')) {
            for (const row of table.rows) {
                if (row.cells[colIndexToDelete]) row.cells[colIndexToDelete].remove();
            }
            lastClickedCell = null; deselectAllTableCells(); // Clear context and selections
            rebuildAndRenderSummary(); updateAllMergeOverlays();
            showMessage('Column deleted.', 'success');
        }
    }

    // --- Cell Selection and Merging ---
    function toggleCellSelectionMode() {
        selectionMode = !selectionMode;
        const btn = document.getElementById('selectBtn');
        if(btn) {
            btn.classList.toggle('active', selectionMode);
            btn.textContent = selectionMode ? '✨ Selecting...' : '✨ Select Cells';
        }
        if (!selectionMode) deselectAllTableCells(); // Clear selection when turning off mode
        hideCellAutocompleteSuggestions(); // Hide autocomplete when toggling mode
    }

    function handleTableCellClick(event) {
        const cell = event.target.closest('td, th'); // Get the TD or TH element
        if (!cell || !cell.closest(`#${activeTableId}`)) return; // Ensure click is within active table

        lastClickedCell = cell; // Update last clicked cell context

        // Hide autocomplete if it's open and click is not on suggestion or current cell
        if (autocompleteSuggestionsDiv && autocompleteSuggestionsDiv.style.display === 'block' &&
            !autocompleteSuggestionsDiv.contains(event.target) && activeCellForAutocomplete !== cell) {
            hideCellAutocompleteSuggestions();
        }

        // Handle name insertion from shared list
        if (selectedNameFromList) {
            // Allow insertion into data cells (tbody td or tbody th)
            if (cell.tagName === 'TD' || (cell.tagName === 'TH' && cell.closest('tbody'))) {
                const overlay = cell.querySelector('.merged-cell-overlay');
                const contentNode = overlay || cell; // Target overlay if exists, else cell itself
                
                const currentCellText = contentNode.textContent;
                const remarkPart = currentCellText.includes(' // ') ? currentCellText.substring(currentCellText.indexOf(' // ')) : '';
                const contentBeforeRemark = currentCellText.split(' // ')[0];
                // Preserve starred items from existing content
                const starWords = contentBeforeRemark.split(/\s+/).filter(w => w.startsWith('*')).join(' ');

                let newText = selectedNameFromList;
                if (starWords) { // Append existing starred items
                    newText += ' ' + starWords;
                }
                newText = (newText.trim() + remarkPart).trim(); // Add remark back

                contentNode.textContent = newText;
                
                rebuildAndRenderSummary(); // Update summary table
                showMessage(`Inserted "${selectedNameFromList}".`, 'success', 2500);
                clearNameSelection(); // Clear selected name after insertion
            } else {
                showMessage('Click an editable data cell to insert name.', 'info');
            }
            return; // Stop further processing for this click
        }

        // Handle cell selection mode
        if (selectionMode) {
            // Prevent selecting subsumed cells or mixing merge groups in selection
            if (cell.classList.contains('subsumed-cell') ||
                (cell.classList.contains('merged-cell-container') && selectedCells.some(sc => sc !== cell && sc.dataset.mergeId !== cell.dataset.mergeId))) {
                showMessage('Cannot select subsumed cells or mix merge groups.', 'warning'); return;
            }
            cell.classList.toggle('selected'); // Toggle 'selected' class
            if (cell.classList.contains('selected')) selectedCells.push(cell);
            else selectedCells = selectedCells.filter(c => c !== cell); // Update selectedCells array
        }
    }

    function deselectAllTableCells() {
        selectedCells.forEach(c => c.classList.remove('selected'));
        selectedCells = [];
    }

    function mergeSelectedTableCells() {
        if (selectedCells.length < 2) { showMessage('Select at least two cells to merge.', 'error'); return; }
        // Prevent merging already merged cells
        if (selectedCells.some(cell => cell.dataset.mergeId)) {
            showMessage('Cannot merge already merged cells. Unmerge first.', 'warning'); return;
        }

        // Determine the primary cell (top-leftmost) for content and overlay
        let primaryCell = selectedCells[0];
        let minRowGUI = primaryCell.parentElement.getBoundingClientRect().top;
        let minColGUI = primaryCell.getBoundingClientRect().left;
        selectedCells.forEach(cell => { // Find the actual top-left cell based on visual position
            const cellRowRect = cell.parentElement.getBoundingClientRect();
            const cellRect = cell.getBoundingClientRect();
            if (cellRowRect.top < minRowGUI || (cellRowRect.top === minRowGUI && cellRect.left < minColGUI)) {
                primaryCell = cell; minRowGUI = cellRowRect.top; minColGUI = cellRect.left;
            }
        });

        // Calculate total width and height of the merge area
        let minLeft = Infinity, maxRight = -Infinity, minTop = Infinity, maxBottom = -Infinity;
        selectedCells.forEach(cell => {
            const rect = cell.getBoundingClientRect();
            minLeft = Math.min(minLeft, rect.left); maxRight = Math.max(maxRight, rect.right);
            minTop = Math.min(minTop, rect.top); maxBottom = Math.max(maxBottom, rect.bottom);
        });
        const totalWidth = maxRight - minLeft; const totalHeight = maxBottom - minTop;

        const mergeId = `merge-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`; // Unique ID for the merge group

        // Create and configure the overlay div
        const overlay = document.createElement('div');
        overlay.className = 'merged-cell-overlay';
        overlay.textContent = primaryCell.textContent; // Content from primary cell
        overlay.contentEditable = 'true';
        overlay.style.setProperty('--merged-width', `${totalWidth}px`);
        overlay.style.setProperty('--merged-height', `${totalHeight}px`);
        overlay.addEventListener('blur', () => { rebuildAndRenderSummary(); }); // Update summary on blur
        overlay.addEventListener('input', (e) => { // Handle input for autocomplete
            const text = e.target.textContent;
            const parentCellForOverlay = e.target.parentElement; // This is the primaryCell
            if (parentCellForOverlay && (parentCellForOverlay.cellIndex > 0 || parentCellForOverlay.closest('table')?.querySelector('thead th:first-child')?.textContent?.toLowerCase() !== 'class')) {
                 showCellAutocompleteSuggestions(parentCellForOverlay, text);
            } else {
                 hideCellAutocompleteSuggestions();
            }
        });

        // Apply merge to primary cell
        primaryCell.innerHTML = ''; // Clear primary cell
        primaryCell.appendChild(overlay); // Add overlay
        primaryCell.classList.add('merged-cell-container');
        primaryCell.setAttribute('data-merge-id', mergeId);

        // Mark other selected cells as subsumed
        selectedCells.forEach(cell => {
            if (cell !== primaryCell) {
                cell.textContent = ''; // Clear content
                cell.classList.add('subsumed-cell');
                cell.setAttribute('data-merge-id', mergeId);
            }
        });

        deselectAllTableCells(); // Clear selection array
        if (selectionMode) toggleCellSelectionMode(); // Turn off selection mode
        showMessage('Cells visually merged.', 'success');
    }

    function unmergeActiveCellIfMerged() {
        const cell = lastClickedCell; // Use the last clicked cell as context
        if (!cell) { showMessage('Click a merged cell to unmerge.', 'info'); return; }

        const containerCell = cell.closest('[data-merge-id]'); // Find the merge container (could be cell itself or parent)
        if (!containerCell) { showMessage('Clicked cell is not part of a merge.', 'error'); return; }

        const mergeId = containerCell.dataset.mergeId;
        const table = containerCell.closest('table');
        if (!table) return;

        const cellsInGroup = table.querySelectorAll(`[data-merge-id="${mergeId}"]`);
        let originalText = '';
        // Find the cell that was the container (had the overlay) to retrieve its text
        const primaryCellInGroup = Array.from(cellsInGroup).find(c => c.classList.contains('merged-cell-container'));
        if (primaryCellInGroup) {
            const overlay = primaryCellInGroup.querySelector('.merged-cell-overlay');
            if (overlay) originalText = overlay.textContent;
            else originalText = primaryCellInGroup.textContent; // Fallback if overlay somehow missing
        }

        // Reset all cells in the merge group
        cellsInGroup.forEach(c => {
            c.removeAttribute('data-merge-id');
            c.classList.remove('merged-cell-container', 'subsumed-cell');
            const overlayChild = c.querySelector('.merged-cell-overlay'); // Remove overlay div
            if (overlayChild) overlayChild.remove();
            c.innerHTML = ''; // Clear content
        });

        // Restore text to the primary cell (or first cell if primary not clearly identified)
        if (primaryCellInGroup) primaryCellInGroup.textContent = originalText;
        else if (cellsInGroup.length > 0) cellsInGroup[0].textContent = originalText; // Fallback

        rebuildAndRenderSummary(); // Update summary
        showMessage('Cells unmerged.', 'success');
    }

    function updateAllMergeOverlays() {
        const activeTable = document.getElementById(activeTableId);
        if (!activeTable) return;

        const mergedContainers = activeTable.querySelectorAll('.merged-cell-container');
        mergedContainers.forEach(containerCell => {
            const mergeId = containerCell.dataset.mergeId; if (!mergeId) return;
            const overlay = containerCell.querySelector('.merged-cell-overlay'); if (!overlay) return;

            const cellsInGroup = Array.from(activeTable.querySelectorAll(`[data-merge-id="${mergeId}"]`));
            if (cellsInGroup.length === 0) return; // Should not happen if container exists

            // Recalculate bounds based on all cells in the group
            let minLeft = Infinity, maxRight = -Infinity, minTop = Infinity, maxBottom = -Infinity;
            cellsInGroup.forEach(cellInvolved => {
                const rect = cellInvolved.getBoundingClientRect();
                minLeft = Math.min(minLeft, rect.left); maxRight = Math.max(maxRight, rect.right);
                minTop = Math.min(minTop, rect.top); maxBottom = Math.max(maxBottom, rect.bottom);
            });

            if (minLeft === Infinity) return; // No valid cells found for bounds

            // Update overlay size CSS variables
            overlay.style.setProperty('--merged-width', `${maxRight - minLeft}px`);
            overlay.style.setProperty('--merged-height', `${maxBottom - minTop}px`);
        });
    }

    // --- Shared Name List Modal and Operations ---
    function handleNameListSessionSwitch(session) {
        currentNameListSession = session;
        // Update tab active states
        if(namePagiTabElement) namePagiTabElement.classList.toggle('active', session === 'pagi');
        if(namePetangTabElement) namePetangTabElement.classList.toggle('active', session === 'petang');
        // Update modal title
        if(nameModalTitleElement) nameModalTitleElement.textContent = `Shared Name List Manager (${session === 'pagi' ? 'Pagi' : 'Petang'})`;
        // Clear search and re-render list
        if(searchNameInputElement) searchNameInputElement.value = '';
        renderNameListFromFirestore();
        hideCellAutocompleteSuggestions(); // Hide autocomplete when switching context
    }

    function highlightSelectedNameInList(nameToHighlight) {
        if (!nameListContainer) return;
        const nameToHighlightStr = String(nameToHighlight || '');
        nameListContainer.querySelectorAll('.name-item span').forEach(span => {
            span.classList.toggle('highlighted', String(span.dataset.name || '') === nameToHighlightStr);
        });
    }

    function clearNameSelection() {
        selectedNameFromList = null;
        // Remove highlight from list
        if (nameListContainer) {
            nameListContainer.querySelectorAll('.name-item span.highlighted').forEach(span => {
                span.classList.remove('highlighted');
            });
        }
    }

    function closeNameModal() {
        if (nameModal) nameModal.style.display = 'none';
        clearNameSelection(); // Clear any selected name
        if(searchNameInputElement) searchNameInputElement.value = ''; // Reset search
    }

    function toggleNameListModalVisibility() {
        if (!nameModal || !nameModalContent || !newNameInput) return;
        const isDisplayed = nameModal.style.display === 'flex';
        if (isDisplayed) {
            closeNameModal();
        } else {
            // Reset modal position before showing (if it was dragged)
            nameModalContent.style.position = 'relative'; // Or your default centering styles
            nameModalContent.style.left = 'auto'; nameModalContent.style.top = 'auto';
            nameModalContent.style.transform = 'none'; // Or your default centering transform

            nameModal.style.display = 'flex';
            if(searchNameInputElement) searchNameInputElement.value = ''; // Clear search on open
            handleNameListSessionSwitch(currentNameListSession); // Ensure correct session is shown
            if(newNameInput) newNameInput.focus(); // Focus on add name input
            clearNameSelection(); // Clear any previously selected name
        }
        hideCellAutocompleteSuggestions(); // Hide autocomplete when opening/closing modal
    }

    function renderNameListFromFirestore(filterText = '') {
        if (!nameListContainer) return;
        if (!fbIsAuthReady) { // Show loading/message if Firebase not ready
            nameListContainer.innerHTML = '<p style="text-align:center; grid-column: 1 / -1;">Loading shared names...</p>'; return;
        }

        nameListContainer.innerHTML = ''; // Clear previous list
        const namesToRender = currentNameListSession === 'pagi' ? namesPagiShared : namesPetangShared;
        const normalizedFilterText = String(filterText || '').toLowerCase().trim();

        if (!Array.isArray(namesToRender)) { // Should be an array
            nameListContainer.innerHTML = '<p style="text-align:center; color:red;">Error: Shared name list data invalid.</p>'; return;
        }

        const filteredNames = namesToRender.filter(name => String(name || '').toLowerCase().trim().includes(normalizedFilterText));

        if (filteredNames.length === 0) {
            nameListContainer.innerHTML = `<p style="text-align:center; grid-column: 1 / -1;">${normalizedFilterText ? 'No names match.' : `No names in shared ${currentNameListSession} session.`}</p>`; return;
        }

        filteredNames.forEach(name => {
            const itemDiv = document.createElement('div'); itemDiv.className = 'name-item';
            const nameStr = String(name || '');
            const safeNameAttr = nameStr.replace(/"/g, '&quot;'); // Escape quotes for attribute
            itemDiv.innerHTML = `<span data-name="${safeNameAttr}" title="Select '${safeNameAttr}'">${nameStr}</span><button data-name-delete="${safeNameAttr}" title="Delete '${safeNameAttr}' from shared list">Delete</button>`;
            nameListContainer.appendChild(itemDiv);
        });
        highlightSelectedNameInList(selectedNameFromList); // Re-apply highlight if a name is selected
    }

    function selectNameForCellInsertion(name) {
        selectedNameFromList = String(name || '');
        highlightSelectedNameInList(selectedNameFromList); // Highlight in the list
        showMessage(`Selected "${selectedNameFromList}". Click a cell to insert.`, 'info', 4000);
    }

    function handleNameListImportFirestore(event) {
        const file = event.target.files[0];
        if (!file) { showMessage('No file selected.', 'info'); return; }
        if (file.type !== 'text/plain') { // Expect .txt file
            showMessage('Invalid file type (.txt only).', 'error');
            event.target.value = ''; // Clear file input
            return;
        }
        const reader = new FileReader();
        reader.onload = async (e) => {
            try {
                // Split by newline, trim, and filter empty lines
                const importedNames = e.target.result.split(/\r?\n/).map(n => String(n||'').trim()).filter(n => n);
                if (importedNames.length === 0) { showMessage('No names in file.', 'info'); return; }
                
                // Merge with existing names for the current session, ensuring uniqueness
                const currentSessionNames = (currentNameListSession === 'pagi' ? namesPagiShared : namesPetangShared).map(n => String(n||'').trim());
                const combinedNames = [...new Set([...currentSessionNames, ...importedNames])];
                
                await saveSharedNameListToFirestore(currentNameListSession, combinedNames); // Save merged list
            } catch (error) { showMessage('Error processing name list file.', 'error'); }
            finally { event.target.value = ''; } // Clear file input
        };
        reader.onerror = () => { showMessage('Failed to read name list file.', 'error'); event.target.value = ''; };
        reader.readAsText(file);
    }

    // --- Excel Import/Export ---
    function handleExcelFileImport(event) {
        const file = event.target.files[0];
        if (!file || !tablesContainer) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const workbook = XLSX.read(new Uint8Array(e.target.result), { type: 'array' });
                const sheetName = workbook.SheetNames[0]; // Use the first sheet
                const worksheet = workbook.Sheets[sheetName];
                const htmlTableString = XLSX.utils.sheet_to_html(worksheet, { raw: false }); // Convert sheet to HTML table string

                tableCount++; // Increment for unique ID
                const newTableId = `tbl_imported_${Date.now()}_${tableCount}`;
                const importedTableName = file.name.replace(/\.xlsx?$/i, '') || `Imported ${tableCount}`; // Use file name as table name

                const tempDiv = document.createElement('div'); tempDiv.innerHTML = htmlTableString;
                const importedTableElement = tempDiv.querySelector('table');

                if (importedTableElement) {
                    importedTableElement.id = newTableId;
                    importedTableElement.dataset.tableName = importedTableName;
                    // Make all cells editable
                    importedTableElement.querySelectorAll('td, th, .merged-cell-overlay').forEach(cell => cell.contentEditable = 'true');
                    
                    tablesContainer.appendChild(importedTableElement);
                    addTabButton(newTableId, importedTableName);
                    switchTable(newTableId); // Make imported table active
                    showMessage('Excel data imported!', 'success');
                } else showMessage('Could not parse table from Excel.', 'error');
            } catch (error) { showMessage('Error processing Excel file.', 'error'); console.error("Excel import error:", error); }
            finally { event.target.value = ''; } // Clear file input
        };
        reader.readAsArrayBuffer(file);
    }

    function exportActiveTableToExcel() {
        const tableToExport = document.getElementById(activeTableId);
        if (!tableToExport) { showMessage('No active table to export.', 'error'); return; }

        // Temporarily replace merged cell overlays with their text content for export
        const overlaysData = [];
        tableToExport.querySelectorAll('.merged-cell-overlay').forEach(overlay => {
            const parentCell = overlay.parentElement;
            overlaysData.push({ parent: parentCell, originalHTML: parentCell.innerHTML }); // Store original HTML to restore
            parentCell.textContent = overlay.textContent; // Replace with text
        });

        const tableName = tableToExport.dataset.tableName || activeTableId;
        const wb = XLSX.utils.table_to_book(tableToExport, { sheet: tableName });
        XLSX.writeFile(wb, `${tableName}_${new Date().toISOString().split('T')[0]}.xlsx`); // Generate and download Excel file

        // Restore merged cell overlays
        overlaysData.forEach(data => {
            data.parent.innerHTML = data.originalHTML;
            // Re-attach event listeners if necessary (not strictly needed if they are on parent or delegated)
            const newOverlay = data.parent.querySelector('.merged-cell-overlay');
            if (newOverlay) { // Re-add listeners for the new overlay element
                newOverlay.addEventListener('blur', () => rebuildAndRenderSummary());
                newOverlay.addEventListener('input', (e) => {
                    const text = e.target.textContent;
                    const parentCellForOverlay = e.target.parentElement;
                    if (parentCellForOverlay && (parentCellForOverlay.cellIndex > 0 || parentCellForOverlay.closest('table')?.querySelector('thead th:first-child')?.textContent?.toLowerCase() !== 'class')) {
                        showCellAutocompleteSuggestions(parentCellForOverlay, text);
                    } else {
                        hideCellAutocompleteSuggestions();
                    }
                });
            }
        });
        if(overlaysData.length > 0) updateAllMergeOverlays(); // Ensure sizes are correct after restoration

        showMessage(`Table "${tableName}" exported.`, 'success');
    }

    // --- PDF Generation ---
    async function generateSchedulePdf() {
        if (!pdfContentElement || !tablesContainer || !scheduleTitleElement) {
            showMessage('PDF generation elements not found.', 'error');
            return;
        }

        showGeneralLoading(true);
        showMessage('Generating PDF, please wait...', 'info', 15000); // Long duration message
        pdfContentElement.innerHTML = ''; // Clear previous PDF content

        const tablesToPrint = tablesContainer.querySelectorAll('table'); // Get all tables
        const numTables = tablesToPrint.length;

        if (numTables === 0) {
            // Handle case with no tables
            const pageWrapper = document.createElement('div');
            pageWrapper.className = 'pdf-page-wrapper';
            const mainTitleText = scheduleTitleElement.textContent || 'Weekly Schedule';
            const mainTitleH2 = document.createElement('h2');
            mainTitleH2.textContent = mainTitleText;
            pageWrapper.appendChild(mainTitleH2);
            const noTablesMessage = document.createElement('p');
            noTablesMessage.textContent = "No tables available to print.";
            noTablesMessage.style.textAlign = "center";
            pageWrapper.appendChild(noTablesMessage);
            // Add footnote even for empty page
            const footnoteDiv = document.createElement('div');
            footnoteDiv.className = 'pdf-footnote';
            const today = new Date();
            const dateOptions = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
            footnoteDiv.textContent = `Generated on: ${today.toLocaleDateString(undefined, dateOptions)}`;
            pageWrapper.appendChild(footnoteDiv);
            pdfContentElement.appendChild(pageWrapper);
        } else {
            // Process each table for PDF
            tablesToPrint.forEach((tableElement, index) => {
                const pageWrapper = document.createElement('div');
                pageWrapper.className = 'pdf-page-wrapper';

                // Add main "Jadual Anjal" title only to the first page wrapper
                if (index === 0) {
                    const mainTitleText = scheduleTitleElement.textContent || 'Weekly Schedule';
                    const mainTitleH2 = document.createElement('h2');
                    mainTitleH2.textContent = mainTitleText;
                    pageWrapper.appendChild(mainTitleH2);
                }

                const tableId = tableElement.id;
                const tableName = tableElement.dataset.tableName || tableId || `Table ${index + 1}`;
                
                const tableTitleH3 = document.createElement('h3');
                tableTitleH3.textContent = tableName;
                pageWrapper.appendChild(tableTitleH3);

                const clonedTable = cloneTableForPdf(tableElement); // Clone and prepare table for PDF
                if (clonedTable) {
                    pageWrapper.appendChild(clonedTable);
                } else {
                    const errorMsg = document.createElement('p');
                    errorMsg.textContent = `Error: Table "${tableName}" could not be generated.`;
                    pageWrapper.appendChild(errorMsg);
                }

                // Add footnote to each page wrapper
                const footnoteDiv = document.createElement('div');
                footnoteDiv.className = 'pdf-footnote';
                const today = new Date();
                const dateOptions = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
                footnoteDiv.textContent = `Generated on: ${today.toLocaleDateString(undefined, dateOptions)}`;
                pageWrapper.appendChild(footnoteDiv);

                pdfContentElement.appendChild(pageWrapper);
            });
        }

        pdfContentElement.style.display = 'block'; // Make content visible for html2pdf

        const pdfOptions = {
            margin: [8, 5, 8, 5], // Margins [top, left, bottom, right] in mm
            filename: `${(scheduleTitleElement.textContent || 'schedule').replace(/[^a-z0-9]/gi, '_').toLowerCase()}_complete.pdf`,
            image: { type: 'jpeg', quality: 0.92 },
            html2canvas: {
                scale: 1.8, // Increased scale for better quality
                useCORS: true,
                logging: true, // Enable logging for debugging
                scrollX: 0, 
                scrollY: -window.scrollY, // Account for page scroll
                windowWidth: pdfContentElement.scrollWidth, // Use content width
                windowHeight: pdfContentElement.scrollHeight, // Use content height
                removeContainer: true // Clean up temporary canvas
            },
            jsPDF: { unit: 'mm', format: 'a4', orientation: 'landscape' },
            // Page break handling: 'css' for respecting CSS page-break properties,
            // 'before' to break before elements with class '.pdf-page-wrapper' (except the first)
            pagebreak: { mode: ['css', 'legacy'], before: '.pdf-page-wrapper:not(:first-child)', avoid: ['h2', 'h3', 'table', '.pdf-footnote'] }
        };

        try {
            await html2pdf().from(pdfContentElement).set(pdfOptions).save();
            showMessage('PDF downloaded successfully!', 'success');
        } catch (error) {
            console.error('Error generating PDF with html2pdf:', error);
            showMessage(`Failed to generate PDF. Error: ${error.message}. Check console.`, 'error', 10000);
        } finally {
            pdfContentElement.style.display = 'none'; // Hide PDF content container after generation
            showGeneralLoading(false);
        }
    }

    function cloneTableForPdf(originalTable) {
        if (!originalTable || typeof originalTable.cloneNode !== 'function') {
            console.error("cloneTableForPdf Error: Invalid originalTable provided:", originalTable);
            return null;
        }
        const tableIdForLog = originalTable.id || 'Unknown ID';
        // console.log(`cloneTableForPdf: Starting clone for table: ${tableIdForLog}, Name: ${originalTable.dataset.tableName || 'N/A'}`);

        const clonedTable = originalTable.cloneNode(true); // Deep clone
        clonedTable.removeAttribute('id'); // Remove original ID
        clonedTable.classList.remove('active'); // Remove active class
        clonedTable.style.width = '100%'; // Ensure full width for PDF
        clonedTable.style.tableLayout = 'fixed'; // Use fixed layout for PDF consistency

        // Remove contenteditable attribute from all elements in the cloned table
        clonedTable.querySelectorAll('[contenteditable="true"]').forEach(el => {
            el.removeAttribute('contenteditable');
        });

        // --- Process merged cells for PDF (convert overlays to rowspan/colspan) ---
        // 1. Identify all merge groups from the original table
        const mergeGroups = {}; // Stores info about each mergeId
        Array.from(originalTable.rows).forEach((originalRow, rowIndex) => {
            Array.from(originalRow.cells).forEach((originalCell, colIndex) => {
                const mergeId = originalCell.dataset.mergeId;
                if (!mergeId) return; // Not part of a merge

                if (!mergeGroups[mergeId]) { // Initialize group if first time seeing this mergeId
                    mergeGroups[mergeId] = {
                        minRow: rowIndex, maxRow: rowIndex,
                        minCol: colIndex, maxCol: colIndex,
                        primaryCellOriginal: null, // The cell that originally contained the .merged-cell-overlay
                        allOriginalCellsInGroup: [] // All original TD/TH elements in this merge group
                    };
                }
                const group = mergeGroups[mergeId];
                group.allOriginalCellsInGroup.push(originalCell);
                // Expand bounds of the merge group
                group.minRow = Math.min(group.minRow, rowIndex);
                group.maxRow = Math.max(group.maxRow, rowIndex);
                group.minCol = Math.min(group.minCol, colIndex);
                group.maxCol = Math.max(group.maxCol, colIndex);

                if (originalCell.classList.contains('merged-cell-container')) {
                    group.primaryCellOriginal = originalCell;
                }
            });
        });

        // 2. Apply rowspan/colspan to the cloned primary cell and remove subsumed cells from cloned table
        for (const mergeId in mergeGroups) {
            const group = mergeGroups[mergeId];
            if (!group.primaryCellOriginal) {
                console.warn(`cloneTableForPdf (${tableIdForLog}): No primary cell found for mergeId: ${mergeId}. Skipping this merge group.`);
                continue;
            }

            const rowSpan = group.maxRow - group.minRow + 1;
            const colSpan = group.maxCol - group.minCol + 1;

            // Find the corresponding primary cell in the cloned table
            // This requires knowing its original row/col index
            let primaryCellOriginalRowIndex = -1;
            let primaryCellOriginalColIndex = -1;
            Array.from(originalTable.rows).forEach((r, rIdx) => {
                Array.from(r.cells).forEach((c, cIdx) => {
                     if (c === group.primaryCellOriginal) {
                        primaryCellOriginalRowIndex = rIdx;
                        primaryCellOriginalColIndex = cIdx;
                    }
                });
            });
            
            if (primaryCellOriginalRowIndex === -1 || primaryCellOriginalColIndex === -1) {
                console.warn(`cloneTableForPdf (${tableIdForLog}): Could not find original primary cell's indices for mergeId ${mergeId}. Skipping.`);
                continue;
            }
            
            const clonedPrimaryCell = clonedTable.rows[primaryCellOriginalRowIndex]?.cells[primaryCellOriginalColIndex];

            if (clonedPrimaryCell) {
                // Get text from the original overlay
                const overlayOriginal = group.primaryCellOriginal.querySelector('.merged-cell-overlay');
                clonedPrimaryCell.textContent = overlayOriginal ? overlayOriginal.textContent : group.primaryCellOriginal.textContent;

                // Remove the overlay div from the cloned cell
                const overlayCloned = clonedPrimaryCell.querySelector('.merged-cell-overlay');
                if (overlayCloned) overlayCloned.remove();
                clonedPrimaryCell.classList.remove('merged-cell-container'); // Clean up class

                // Apply rowspan and colspan
                if (rowSpan > 1) clonedPrimaryCell.rowSpan = rowSpan;
                if (colSpan > 1) clonedPrimaryCell.colSpan = colSpan;

                // Identify and remove other (subsumed) cells in this merge group from the cloned table
                const cellsToRemoveFromClonedTable = [];
                group.allOriginalCellsInGroup.forEach(originalSubsumedCell => {
                    if (originalSubsumedCell === group.primaryCellOriginal) return; // Don't remove the primary cell itself

                    // Find this subsumed cell in the original table to get its indices
                    let subsumedOriginalRowIndex = -1;
                    let subsumedOriginalColIndex = -1;
                     Array.from(originalTable.rows).forEach((r, rIdx) => {
                        Array.from(r.cells).forEach((c, cIdx) => {
                             if (c === originalSubsumedCell) {
                                subsumedOriginalRowIndex = rIdx;
                                subsumedOriginalColIndex = cIdx;
                            }
                        });
                    });

                    if (subsumedOriginalRowIndex !== -1 && subsumedOriginalColIndex !== -1) {
                         const clonedSubsumedCell = clonedTable.rows[subsumedOriginalRowIndex]?.cells[subsumedOriginalColIndex];
                         if (clonedSubsumedCell && clonedSubsumedCell !== clonedPrimaryCell) { // Ensure it's not the primary cell again
                            cellsToRemoveFromClonedTable.push(clonedSubsumedCell);
                         }
                    }
                });
                cellsToRemoveFromClonedTable.forEach(cell => cell.remove());
            } else {
                 console.warn(`cloneTableForPdf (${tableIdForLog}): Cloned primary cell not found for mergeId: ${mergeId} at original cloned indices [${primaryCellOriginalRowIndex},${primaryCellOriginalColIndex}]`);
            }
        }
        // console.log(`cloneTableForPdf: Finished cloning table ID: ${tableIdForLog}.`);
        return clonedTable;
    }


    // --- Summary Table Logic ---
    function getTextForSummary(cellText) { // Extracts main content for summary, excluding remarks and starred items
        if (typeof cellText !== 'string') return '';
        let textForSummary = cellText.split(' // ')[0]; // Get content before remarks
        const words = textForSummary.split(/\s+/);
        // Filter out words starting with '*' (special markers)
        const filteredWords = words.filter(word => !word.startsWith('*'));
        return filteredWords.join(' ').trim();
    }

    function rebuildAndRenderSummary() {
        const scheduledNames = new Set(); // Collect all unique names scheduled
        if (tablesContainer) {
            tablesContainer.querySelectorAll('table').forEach(scheduleTable => { // Iterate through all tables
                if (!scheduleTable.tBodies[0]) return; // Skip if no tbody
                scheduleTable.tBodies[0].querySelectorAll('tr').forEach(row => {
                    Array.from(row.cells).forEach((cell, cellIndex) => {
                        if (cellIndex > 0) { // Skip first column (usually class/time labels)
                            const overlay = cell.querySelector('.merged-cell-overlay');
                            const nameFromCell = String(overlay ? overlay.textContent : cell.textContent || '').trim();
                            const actualNameForSummary = getTextForSummary(nameFromCell); // Process text for summary
                            if (actualNameForSummary) {
                                scheduledNames.add(actualNameForSummary);
                            }
                        }
                    });
                });
            });
        }
        const allSummaryNames = [...scheduledNames].sort((a, b) => String(a).localeCompare(String(b), undefined, { sensitivity: 'base' }));
        
        buildSummaryTableSkeleton(allSummaryNames); // Create the structure of the summary table
        updateSummaryTableData(allSummaryNames); // Populate it with data
    }

    function parseTimeToMinutes(timeStr) { // Helper to sort time slots correctly
        if (typeof timeStr !== 'string') return Infinity; // Non-strings sort last
        const match = timeStr.match(/^(\d{1,2})\s*[:.]\s*(\d{2})/); // Matches HH:MM or HH.MM
        if (match) return parseInt(match[1], 10) * 60 + parseInt(match[2], 10);
        return Infinity; // If no match, sort last
    }

    function buildSummaryTableSkeleton(allAvailableNames) {
        if (!summaryTableElement) {
            console.error("buildSummaryTableSkeleton: summaryTableElement not found.");
            return;
        }
        summaryTableElement.innerHTML = ''; // Clear existing summary table

        // Get headers from the currently active table to form columns in summary
        let activeTableHeaders = [];
        const activeTableElement = document.getElementById(activeTableId);
        if (activeTableElement && activeTableElement.tHead && activeTableElement.tHead.rows.length > 0) {
            // Start from index 1 to skip the first header (usually "Class/Time")
            for (let hIdx = 1; hIdx < activeTableElement.tHead.rows[0].cells.length; hIdx++) {
                const headerText = String(activeTableElement.tHead.rows[0].cells[hIdx].textContent || '').trim();
                if (headerText) activeTableHeaders.push(headerText);
            }
        }

        // Special rule for "LAU" / "LISAH" requiring a "10.15-10.30" slot if they are in "10.30-12.00"
        let laulisahRuleRequiresSpecialSlot = false;
        const specialNamesForRule = ["LAU", "LISAH"]; // Names that trigger the rule
        const targetSlotForSpecialNamesRule = "10.15-10.30"; // The slot to add/ensure exists
        const sourceSlotToShiftRule = "10.30-12.00"; // The slot that, if containing special names, triggers the rule

        if (tablesContainer) {
            for (const scheduleTable of tablesContainer.querySelectorAll('table')) { // Check all tables
                if (laulisahRuleRequiresSpecialSlot) break; // Stop if rule already triggered
                if (!scheduleTable.tHead?.rows.length > 0 || !scheduleTable.tBodies[0]) continue;
                
                const currentScheduleTableHeaders = Array.from(scheduleTable.tHead.rows[0].cells).map(th => String(th.textContent||'').trim());
                
                Array.from(scheduleTable.tBodies[0].rows).forEach((scheduleDataRow) => {
                    if (laulisahRuleRequiresSpecialSlot) return;
                    for (let cellIdx = 1; cellIdx < scheduleDataRow.cells.length; cellIdx++) {
                         const scheduleCell = scheduleDataRow.cells[cellIdx];
                         let entryInScheduleCellFull = String(scheduleCell.querySelector('.merged-cell-overlay')?.textContent || scheduleCell.textContent||'').trim();
                         let entryInScheduleCellForRule = getTextForSummary(entryInScheduleCellFull); // Get clean name
                         
                         if (specialNamesForRule.includes(entryInScheduleCellForRule)) { // If name is special
                            const headerText = currentScheduleTableHeaders[cellIdx];
                            // Compare normalized time slots (remove spaces, use . for consistency)
                            if (headerText && headerText.replace(/\s/g, "").replace(/:/g,".") === sourceSlotToShiftRule.replace(/\s/g, "").replace(/:/g,".")) {
                                laulisahRuleRequiresSpecialSlot = true; return; // Rule triggered
                            }
                         }
                    }
                });
            }
        }
        
        let combinedHeaders = new Set(activeTableHeaders); // Use a Set for unique headers
        if (laulisahRuleRequiresSpecialSlot) {
            combinedHeaders.add(targetSlotForSpecialNamesRule); // Add the special slot if rule triggered
        }

        // Sort headers by time
        let sortedUniqueHeaders = Array.from(combinedHeaders).sort((a, b) => {
            const timeA = parseTimeToMinutes(a); const timeB = parseTimeToMinutes(b);
            if (timeA !== Infinity && timeB !== Infinity) return timeA - timeB; // Numeric sort for times
            if (timeA !== Infinity) return -1; // Times before non-times
            if (timeB !== Infinity) return 1;  // Non-times after times
            return String(a).localeCompare(String(b)); // Alphabetical for non-times
        });

        const finalSummaryColumnHeaders = ['Nama/Masa', ...sortedUniqueHeaders]; // Final headers for summary table

        // Create summary table header row
        const thead = summaryTableElement.createTHead();
        const headerRowForSummary = thead.insertRow();
        finalSummaryColumnHeaders.forEach(headerText => {
            const th = document.createElement('th'); th.textContent = headerText;
            headerRowForSummary.appendChild(th);
        });

        // Create summary table body
        const tbody = summaryTableElement.createTBody();
        if (allAvailableNames.length === 0 && sortedUniqueHeaders.length === 0) { // No data at all
            const tr = tbody.insertRow(); const td = tr.insertCell();
            td.textContent = "No names scheduled and no time slots defined in active table.";
            td.colSpan = finalSummaryColumnHeaders.length || 1;
            td.style.textAlign = 'center'; td.style.fontStyle = 'italic';
        } else if (allAvailableNames.length === 0) { // No names, but maybe time slots
            const tr = tbody.insertRow(); const td = tr.insertCell();
            td.textContent = "No names scheduled yet.";
            td.colSpan = finalSummaryColumnHeaders.length || 1;
            td.style.textAlign = 'center'; td.style.fontStyle = 'italic';
        } else { // Create rows for each name
            allAvailableNames.forEach(name => {
                const tr = tbody.insertRow();
                tr.insertCell().textContent = String(name || ''); // First cell is the name
                for (let i = 1; i < finalSummaryColumnHeaders.length; i++) tr.insertCell().textContent = ''; // Empty cells for time slots
            });
        }
    }

    function updateSummaryTableData(allAvailableNames) {
        if (!summaryTableElement?.tBodies?.[0] || !summaryTableElement.tHead?.rows?.[0]) {
            // console.warn("updateSummaryTableData: Summary table structure not ready.");
            return;
        }
        const summaryBody = summaryTableElement.tBodies[0];
        // If only the placeholder "No names/slots" row exists, don't try to update data cells
        if (summaryBody.rows.length === 0 && !(summaryBody.rows[0]?.cells[0]?.colSpan > 1)) {
            // console.warn("updateSummaryTableData: Summary table body is empty or has placeholder, skipping data update.");
            return;
        }

        // Get summary table headers for mapping
        const summaryTableDisplayHeaders = Array.from(summaryTableElement.tHead.rows[0].cells).map(th => String(th.textContent||'').trim());
        // Normalize headers for lookup (remove spaces, use . for time separator)
        const normalizedSummaryHeadersForLookup = summaryTableDisplayHeaders.map(h => h.replace(/\s/g, "").replace(/:/g,"."));

        // Clear previous data from summary cells (but not names in first column)
        Array.from(summaryBody.rows).forEach(summaryRow => {
            if (summaryRow.cells.length > 1) Array.from(summaryRow.cells).slice(1).forEach(cell => {
                cell.textContent = ''; cell.classList.remove('highlight-conflict'); // Clear text and conflict class
            });
        });

        // Iterate through all schedule tables to populate summary
        if (tablesContainer) {
            tablesContainer.querySelectorAll('table').forEach(scheduleTable => {
                if (!scheduleTable.tHead?.rows.length > 0 || !scheduleTable.tBodies[0]) return; // Skip if no header/body
                
                const scheduleHeaders = Array.from(scheduleTable.tHead.rows[0].cells).map(th => String(th.textContent||'').trim());
                
                Array.from(scheduleTable.tBodies[0].rows).forEach((scheduleDataRow) => {
                    const classIdentifier = String(scheduleDataRow.cells[0]?.textContent||'').trim(); // Get class/group from first cell
                    if (!classIdentifier) return; // Skip if no class identifier

                    for (let cellIdx = 1; cellIdx < scheduleDataRow.cells.length; cellIdx++) { // Iterate through time slots
                        const scheduleCell = scheduleDataRow.cells[cellIdx];
                        let entryInScheduleCellFull = String(scheduleCell.querySelector('.merged-cell-overlay')?.textContent || scheduleCell.textContent||'').trim();
                        let actualEntryForSummary = getTextForSummary(entryInScheduleCellFull); // Get clean name

                        if (actualEntryForSummary) { // If there's a name in the cell
                            let scheduleColumnHeaderForThisCell = scheduleHeaders[cellIdx];
                            if (!scheduleColumnHeaderForThisCell) continue; // Skip if no header for this column

                            let summaryColumnToUse = scheduleColumnHeaderForThisCell; // Default summary column is same as schedule column
                            // Apply special LAU/LISAH rule for time slot shifting
                            const specialNamesForRule = ["LAU", "LISAH"];
                            const targetSlotForSpecialNamesRule = "10.15-10.30";
                            const sourceSlotToShiftRule = "10.30-12.00";
                            if (specialNamesForRule.includes(actualEntryForSummary) && 
                                scheduleColumnHeaderForThisCell.replace(/\s/g, "").replace(/:/g,".") === sourceSlotToShiftRule.replace(/\s/g, "").replace(/:/g,".")) {
                                summaryColumnToUse = targetSlotForSpecialNamesRule; // Shift to the special slot
                            }

                            // Find the row in summary table for this name
                            const targetSummaryRow = Array.from(summaryBody.rows).find(sr => String(sr.cells[0]?.textContent||'') === actualEntryForSummary);
                            if (targetSummaryRow?.cells.length > 1) { // If row found and has data cells
                                // Find the column index in summary table for this time slot
                                const targetSummaryColumnCellIndex = normalizedSummaryHeadersForLookup.indexOf(summaryColumnToUse.replace(/\s/g, "").replace(/:/g,"."));
                                if (targetSummaryColumnCellIndex > 0) { // If column found
                                    const summaryCellToUpdate = targetSummaryRow.cells[targetSummaryColumnCellIndex];
                                    // Append class identifier, handling multiple classes in one slot
                                    let existingClasses = summaryCellToUpdate.textContent.trim() ? summaryCellToUpdate.textContent.trim().split(',').map(s => s.trim()) : [];
                                    if (!existingClasses.includes(classIdentifier)) {
                                        existingClasses.push(classIdentifier);
                                        summaryCellToUpdate.textContent = existingClasses.sort((a,b) => String(a).localeCompare(String(b), undefined, { sensitivity: 'base' })).join(', ');
                                    }
                                }
                            }
                        }
                    }
                });
            });
        }

        // Highlight cells in summary where a name is scheduled in multiple classes at the same time
        Array.from(summaryBody.rows).forEach(summaryRow => {
            if (summaryRow.cells.length > 1) Array.from(summaryRow.cells).forEach((cell, cellIndex) => {
                if (cellIndex > 0 && cell.textContent.includes(',')) cell.classList.add('highlight-conflict');
            });
        });
    }
</script>
</body>
</html>
