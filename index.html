<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>Weekly Schedule</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        body {
            font-family: Arial, Helvetica, sans-serif;
            margin: 20px;
            background-color: #f9f9f9;
        }
        h2, h3 {
            color: #333;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin-top: 15px;
            margin-bottom: 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            background-color: #fff;
            table-layout: auto;
        }
        #tablesContainer {
            overflow-x: auto;
        }
        #tablesContainer > table {
            display: none;
        }
        #tablesContainer > table.active {
            display: table;
        }
        #summaryTable {
            display: table;
            margin-top: 20px;
        }
        th, td {
            border: 1px solid #ccc;
            padding: 10px;
            text-align: center;
            min-width: 100px;
        }
        table th {
            background-color: #e9ecef;
            color: #495057;
            font-weight: bold;
            white-space: nowrap;
        }
        td.selected, th.selected {
            outline: 3px solid #007bff;
            background-color: #cfe2ff;
        }
        .merged {
            font-style: italic;
            background-color: #f8f9fa;
        }
        .bar {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 15px;
            align-items: center;
        }
        .bar button, .table-tabs button {
            padding: 10px 15px;
            font-size: 14px;
            border-radius: 5px;
            cursor: pointer;
            border: 1px solid #adb5bd;
            background-color: #fff;
            transition: background-color 0.2s ease, box-shadow 0.2s ease, transform 0.1s ease;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }
        .bar button:hover, .table-tabs button:hover {
            background-color: #f1f3f5;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .bar button:active, .table-tabs button:active {
            transform: translateY(1px);
            box-shadow: 0 1px 1px rgba(0,0,0,0.1);
        }

        #rowColManipulationBar button {
            background-image: linear-gradient(to bottom, #fdfbfb 0%, #ebedee 100%);
            border: 1px solid #ced4da;
            color: #343a40;
            box-shadow: 0 2px 3px rgba(0,0,0,0.1), inset 0 1px 0 rgba(255,255,255,0.2);
            padding: 8px 12px;
        }
        #rowColManipulationBar button:hover {
            background-image: linear-gradient(to bottom, #e2e6ea 0%, #d4d9df 100%);
            border-color: #b8c0c6;
            box-shadow: 0 2px 5px rgba(0,0,0,0.15), inset 0 1px 0 rgba(255,255,255,0.1);
        }
         #rowColManipulationBar button.delete-btn {
            background-image: linear-gradient(to bottom, #f8d7da 0%, #f1c6cb 100%);
            border-color: #f5c6cb;
            color: #721c24;
        }
        #rowColManipulationBar button.delete-btn:hover {
            background-image: linear-gradient(to bottom, #f5c6cb 0%, #ebaeb3 100%);
            border-color: #f1b0b7;
        }


        #directCopyFullHtmlBtn { background-color: #545b62; color: white;
            border-color: #545b62; }
        #excelBtnTrigger, #importExcelBtn { background-color: #28a745; color: white;
            border-color: #28a745;}
        #saveDraftBtn { background-color: #007bff; color: white;
            border-color: #007bff;}
        #loadDraftBtn { background-color: #ffc107; color: #212529;
            border-color: #ffc107;}
        #clearActiveTableContentBtn { background-color: #fd7e14; color: white;
            border-color: #fd7e14;}
        #selectBtn { background-color: #17a2b8; color: white;
            border-color: #17a2b8;}
        #selectBtn.active { background-color: #fd7e14;
            border-color: #fd7e14;}
        #mergeBtn { background-color: #6f42c1; color: white;
            border-color: #6f42c1;}
        #unmergeBtn { background-color: #e83e8c; color: white;
            border-color: #e83e8c;}
        #addTableBtn { background-color: #20c997; color: white;
            border-color: #20c997;}
        #renameTableBtn { background-color: #6c757d; color: white;
            border-color: #6c757d;}
        #deleteTableBtn { background-color: #dc3545; color: white;
            border-color: #dc3545;}
        #nameListBtn { background-color: #fd7e14; color: white;
            border-color: #fd7e14;}
        #deselectBtn { background-color: #6c757d; color: white;
            border-color: #6c757d;}
        #exportDraftsBtn { background-color: #4e54c8; color: white; border-color: #4e54c8;}
        #importDraftsBtn { background-color: #8f94fb; color: white; border-color: #8f94fb;}

        .table-tabs { margin-bottom: 10px;
        }
        .table-tabs button { background-color: #f8f9fa; border-bottom-left-radius: 0; border-bottom-right-radius: 0;
        }
        .table-tabs button.active { background-color: #007bff; color: white; border-color: #007bff;
        }
        #summaryTable th { background-color: #ffeeba;
        }
        #summaryTable td { background-color: #fff3cd;
        }
        .highlight-conflict {
            background-color: #ffcdd2 !important;
            font-weight: bold;
            color: #c62828 !important;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: rgba(0,0,0,0.4);
            align-items: center;
            justify-content: center;
            pointer-events: none;
        }

        .modal-content {
            background-color: #fff;
            padding: 20px;
            border: 1px solid #888;
            width: 90%;
            max-width: 500px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            position: relative;
            pointer-events: auto;
        }

        .modal-content.dragging {
            transform: none;
        }
        .modal-header {
            padding-bottom: 10px;
            border-bottom: 1px solid #eee; margin-bottom: 15px;
            font-size: 1.2em; color: #333; display: flex; justify-content: space-between; align-items: center;
            cursor: move;
            user-select: none;
        }
        .modal-close-btn {
            font-size: 1.5rem;
            font-weight: bold; line-height: 1; color: #000;
            text-shadow: 0 1px 0 #fff; opacity: .5; background: transparent; border: 0; cursor: pointer;
        }
        .modal-close-btn:hover { opacity: .75;
        }
        .name-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 5px;
            border-bottom: 1px solid #eee;
            break-inside: avoid-column;
            page-break-inside: avoid;
        }
        .name-item:last-child { border-bottom: none;
        }
        .name-item span { flex-grow: 1; cursor: pointer; color: #007bff;
        }
        .name-item span:hover { text-decoration: underline;
        }
        .name-item button { background-color: #dc3545; color: white; border: none; border-radius: 4px;
            padding: 5px 10px; font-size: 0.9em;
        }
        .highlighted { background-color: #cfe2ff !important; font-weight: bold;
        }
        #draftList { border: 1px solid #ddd; padding: 10px; margin-bottom: 15px; border-radius: 5px;
            background-color: #fff;
        }
        .draft-item { display: flex; justify-content: space-between; align-items: center;
            padding: 8px 5px; border-bottom: 1px solid #eee;
        }
        .draft-item:last-child { border-bottom: none;
        }
        .draft-item span { cursor: pointer; color: #007bff;
        }
        .draft-item span:hover { text-decoration: underline;
        }
        .draft-item button { background-color: #dc3545; color: white; border: none; border-radius: 4px;
            padding: 5px 10px; font-size: 0.9em;
        }
        #newNameInput, #searchNameInput {
            padding: 8px;
            margin-right: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
            flex-grow: 1;
            width: calc(100% - 100px);
        }
         #searchNameInput {
            margin-bottom: 10px;
            width: 100%;
            box-sizing: border-box;
        }
        .input-group { display: flex;
            margin-bottom: 10px;
        }
        .input-group button, #importNameListBtn {
            background-color: #28a745;
            color: white;
            border-color: #28a745;
            padding: 8px 12px;
            font-size: 1em;
            border-radius: 4px;
            cursor: pointer;
            flex-shrink: 0;
        }
        #importNameListBtn {
             margin-top: 10px;
             width: 100%;
        }
        #nameList {
            margin-top:10px;
            max-height:250px;
            overflow-y:auto;
            column-count: 2;
            column-gap: 20px;
        }
        .custom-message-box {
            display: none;
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            background-color: #333; color: white; padding: 15px 25px; border-radius: 5px;
            z-index: 2000;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2); font-size: 1em;
        }
        .custom-message-box.success { background-color: #28a745;
        }
        .custom-message-box.error { background-color: #dc3545;
        }
        .custom-message-box.info { background-color: #007bff;
        }
    </style>
</head>
<body>
    <h2 contenteditable="true" id="scheduleTitle">Weekly Schedule</h2>
    <div class="bar">
        <button id="directCopyFullHtmlBtn">üìã Copy Full HTML (Direct)</button>
    </div>
    <div class="bar">
        <button id="excelBtnTrigger">üíæ Export Active Table to Excel</button>
        <button id="importExcelBtn">üìÇ Import from Excel</button>
        <input type="file" id="fileInput" accept=".xlsx" style="display:none">
    </div>
    <div class="bar">
        <button id="saveDraftBtn">üí† Save All as Draft</button>
        <button id="loadDraftBtn">üìÇ Load Draft</button>
        <button id="exportDraftsBtn">üì§ Export All Drafts</button> <button id="importDraftsBtn">üì• Import Drafts File</button> <input type="file" id="draftImportFile" accept=".json" style="display:none;"> <button id="clearActiveTableContentBtn">üßπ Clear Active Table</button>
    </div>
    <div class="bar">
        <button id="selectBtn">‚ú® Select Cells</button>
        <button id="mergeBtn">üîó Merge Cells</button>
        <button id="deselectBtn">üö´ Deselect All</button>
        <button id="unmergeBtn">üíî Unmerge Cell</button>
    </div>
    <div class="bar">
        <button id="addTableBtn">‚ûï Add New Table</button>
        <button id="renameTableBtn">üìù Rename Active Table</button>
        <button id="deleteTableBtn">‚ùå Delete Active Table</button>
        <button id="nameListBtn">üë• Manage Names</button>
    </div>
    <div id="draftList" style="display:none;"></div>
    <div class="bar table-tabs" id="tableTabs"></div>
    <div id="tablesContainer">
        <table id="tbl_1" class="active" data-table-name="Table 1">
            <thead>
                <tr>
                    <th contenteditable="true">Class</th> <th contenteditable="true">08:00</th>
                    <th contenteditable="true">09:00</th>
                    <th contenteditable="true">10:00</th>
                    <th contenteditable="true">11:00</th> <th contenteditable="true">12:00</th>
                    <th contenteditable="true">13:00</th>
                </tr>
            </thead>
            <tbody>
                 <tr> <td contenteditable="true">5S1</td>
                    <td contenteditable="true"></td><td contenteditable="true">JAMES</td><td contenteditable="true"></td>
                    <td contenteditable="true"></td><td contenteditable="true"></td><td contenteditable="true"></td>
                </tr>
                 <tr> <td contenteditable="true">5S2</td>
                    <td contenteditable="true"></td><td contenteditable="true"></td><td contenteditable="true">LILY</td>
                    <td contenteditable="true"></td><td contenteditable="true"></td><td contenteditable="true"></td>
                </tr>
            </tbody>
               </table>
    </div>
    <div class="bar" id="rowColManipulationBar">
        <button id="addRowAboveBtn">‚¨ÜÔ∏è Add Row Above</button>
        <button id="addRowBelowBtn">‚¨áÔ∏è Add Row Below</button>
        <button id="addColLeftBtn">‚¨ÖÔ∏è Add Column Left</button>
        <button id="addColRightBtn">‚û°Ô∏è Add Column Right</button>
        <button id="deleteRowBtn" class="delete-btn">üóëÔ∏è Delete Row</button>
        <button id="deleteColBtn" class="delete-btn">üóëÔ∏è Delete Column</button>
    </div>
    <div id="nameModal" class="modal">
        <div class="modal-content" id="nameModalContent">
            <div class="modal-header" id="nameModalHeader">
                <h3>Name List</h3> <button type="button" class="modal-close-btn" id="closeNameModalBtnStandard">√ó</button>
            </div>
            <div class="input-group">
                <input id="newNameInput" placeholder="Add new name">
                <button id="addNameBtnInModal">Add</button>
            </div>
            <button id="importNameListBtn">üìÇ Import Names (.txt)</button>
            <input type="file" id="nameListImportFile" accept=".txt" style="display:none;">
            <input type="text" id="searchNameInput" placeholder="üîç Search names..." style="margin-top: 10px;">
            <div id="nameList" style="margin-top:10px;max-height:250px;overflow-y:auto;"></div>
        </div>
    </div>
    <h3 style="margin-top:32px">Teacher/Subject Attendance Summary</h3>
    <table id="summaryTable"></table>
    <div id="customMessageBox" class="custom-message-box"></div>

<script>
    // --- Global State and Configuration ---
    const DRAFTS_KEY = 'jadual_drafts_v3';
    const NAMES_KEY = 'jadual_names_v3';
    const SCHEDULE_TITLE_KEY = 'jadual_title_v3';
    let activeTableId = 'tbl_1';
    let tableCount = 1;
    let selectionMode = false;
    let selectedCells = [];
    let lastClickedCell = null;
    let selectedNameFromList = null;
    let names = [];
    let isDraggingModal = false;
    let modalDragOffsetX, modalDragOffsetY;
    let scheduleTitleElement, tablesContainer, tableTabs, nameModal, nameModalContent, nameModalHeader, nameListContainer, newNameInput, draftListElement, summaryTableElement, customMessageBox, fileInputElement, directCopyFullHtmlButtonElement, closeNameModalButtonStandardElement, nameListImportFileInputElement, searchNameInputElement, draftImportFileInputElement; // Added draftImportFileInputElement

    // --- Utility Functions ---
    function showMessage(message, type = 'info', duration = 3000) {
        if (!customMessageBox) return;
        customMessageBox.textContent = message;
        customMessageBox.className = `custom-message-box ${type}`;
        customMessageBox.style.display = 'block';
        setTimeout(() => { if (customMessageBox) customMessageBox.style.display = 'none'; }, duration);
    }
    function customPrompt(message, defaultValue = "") { return prompt(message, defaultValue);
    }
    // MODIFIED: Using a custom confirm modal instead of window.confirm
    function customConfirm(message) {
        return new Promise((resolve) => {
            const confirmModalId = 'customConfirmModal';
            let existingModal = document.getElementById(confirmModalId);
            if (existingModal) existingModal.remove();

            const modal = document.createElement('div');
            modal.id = confirmModalId;
            modal.style.cssText = `
                display: flex; position: fixed; z-index: 2001; left: 0; top: 0; width: 100%; height: 100%;
                overflow: auto; background-color: rgba(0,0,0,0.5); align-items: center; justify-content: center;
            `;

            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background-color: #fff; padding: 25px; border-radius: 8px; text-align: center;
                box-shadow: 0 5px 15px rgba(0,0,0,0.3); min-width: 300px; max-width: 90%;
            `;

            const messageP = document.createElement('p');
            messageP.textContent = message;
            messageP.style.marginBottom = '20px';
            messageP.style.fontSize = '1.1em';

            const yesButton = document.createElement('button');
            yesButton.textContent = 'Yes';
            yesButton.style.cssText = `
                padding: 10px 20px; margin: 0 10px; border-radius: 5px; cursor: pointer;
                background-color: #28a745; color: white; border: none; font-size: 1em;
            `;

            const noButton = document.createElement('button');
            noButton.textContent = 'No';
            noButton.style.cssText = `
                padding: 10px 20px; margin: 0 10px; border-radius: 5px; cursor: pointer;
                background-color: #dc3545; color: white; border: none; font-size: 1em;
            `;

            const closeModal = (value) => {
                modal.remove();
                resolve(value);
            };

            yesButton.onclick = () => closeModal(true);
            noButton.onclick = () => closeModal(false);

            modalContent.appendChild(messageP);
            modalContent.appendChild(yesButton);
            modalContent.appendChild(noButton);
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
        });
    }


    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', () => {
        scheduleTitleElement = document.getElementById('scheduleTitle');
        tablesContainer = document.getElementById('tablesContainer');
        tableTabs = document.getElementById('tableTabs');
        nameModal = document.getElementById('nameModal');
        nameModalContent = document.getElementById('nameModalContent');
        nameModalHeader = document.getElementById('nameModalHeader');
        nameListContainer = document.getElementById('nameList');
        newNameInput = document.getElementById('newNameInput');
        draftListElement = document.getElementById('draftList');
        summaryTableElement = document.getElementById('summaryTable');
        customMessageBox = document.getElementById('customMessageBox');
        fileInputElement = document.getElementById('fileInput');
        directCopyFullHtmlButtonElement = document.getElementById('directCopyFullHtmlBtn');
        closeNameModalButtonStandardElement = document.getElementById('closeNameModalBtnStandard');
        nameListImportFileInputElement = document.getElementById('nameListImportFile');
        searchNameInputElement = document.getElementById('searchNameInput');
        draftImportFileInputElement = document.getElementById('draftImportFile'); // Initialize new element

        if (!tablesContainer || !tableTabs || !nameModal || !nameModalContent || !nameModalHeader || !summaryTableElement || !customMessageBox || !scheduleTitleElement || !fileInputElement || !directCopyFullHtmlButtonElement || !closeNameModalButtonStandardElement || !nameListImportFileInputElement || !searchNameInputElement || !draftImportFileInputElement) {
            console.error("Critical DOM elements missing. Application might not function correctly.");
            document.body.innerHTML = "<p style='color:red; text-align:center; font-size:1.2em; padding:20px;'>Error: Application failed to initialize due to missing page elements.</p>";
            return;
        }

        loadScheduleTitle();
        loadNames();
        initializeEventListeners();
        setupInitialTableState();
        renderNameList();
        rebuildAndRenderSummary();
    });

    function setupInitialTableState() {
        const existingTables = tablesContainer.querySelectorAll('table');
        if (existingTables.length > 0) {
            tableTabs.innerHTML = '';
            existingTables.forEach((table, index) => {
                const tableId = table.id || `tbl_init_${Date.now()}_${index + 1}`;
                table.id = tableId;
                const tableName = table.dataset.tableName || `Table ${index + 1}`;
                table.dataset.tableName = tableName;
                addTabButton(tableId, tableName);
                if (index === 0) activeTableId = tableId;
            });
        } else { addNewTable(true); }

        if (activeTableId && document.getElementById(activeTableId)) {
            switchTable(activeTableId);
        } else if (tablesContainer.querySelector('table')) {
            switchTable(tablesContainer.querySelector('table').id);
        }
    }

    function loadScheduleTitle() {
        const savedTitle = localStorage.getItem(SCHEDULE_TITLE_KEY);
        if (savedTitle && scheduleTitleElement) scheduleTitleElement.textContent = savedTitle;
        if (scheduleTitleElement) {
            scheduleTitleElement.addEventListener('blur', () => {
                localStorage.setItem(SCHEDULE_TITLE_KEY, scheduleTitleElement.textContent);
                showMessage('Schedule title saved!', 'success');
            });
        }
    }
    // --- Event Listener Initialization ---
    function initializeEventListeners() {
        directCopyFullHtmlButtonElement.addEventListener('click', attemptDirectCopyToClipboard);
        closeNameModalButtonStandardElement.addEventListener('click', closeNameModal);

        nameModalHeader.addEventListener('mousedown', startDragModal);
        document.addEventListener('mousemove', dragModal);
        document.addEventListener('mouseup', stopDragModal);
        nameModalHeader.addEventListener('touchstart', startDragModal, { passive: false });
        document.addEventListener('touchmove', dragModal, { passive: false });
        document.addEventListener('touchend', stopDragModal);

        document.getElementById('excelBtnTrigger').addEventListener('click', exportActiveTableToExcel);
        document.getElementById('importExcelBtn').addEventListener('click', () => fileInputElement.click());
        fileInputElement.addEventListener('change', handleExcelFileImport);

        document.getElementById('saveDraftBtn').addEventListener('click', promptAndSaveDraft);
        document.getElementById('loadDraftBtn').addEventListener('click', toggleDraftListVisibility);
        document.getElementById('exportDraftsBtn').addEventListener('click', exportAllDrafts); // New listener
        document.getElementById('importDraftsBtn').addEventListener('click', () => draftImportFileInputElement.click()); // New listener
        draftImportFileInputElement.addEventListener('change', handleDraftsFileImport); // New listener


        document.getElementById('clearActiveTableContentBtn').addEventListener('click', confirmAndClearActiveTableContent);

        document.getElementById('selectBtn').addEventListener('click', toggleCellSelectionMode);
        document.getElementById('mergeBtn').addEventListener('click', mergeSelectedTableCells);
        document.getElementById('deselectBtn').addEventListener('click', deselectAllTableCells);
        document.getElementById('unmergeBtn').addEventListener('click', unmergeActiveCellIfMerged);

        document.getElementById('addTableBtn').addEventListener('click', () => addNewTable());
        document.getElementById('renameTableBtn').addEventListener('click', promptAndRenameActiveTable);
        document.getElementById('deleteTableBtn').addEventListener('click', confirmAndDeleteActiveTable);
        document.getElementById('nameListBtn').addEventListener('click', toggleNameListModalVisibility);

        document.getElementById('addRowAboveBtn').addEventListener('click', addRowAboveToActiveTable);
        document.getElementById('addRowBelowBtn').addEventListener('click', addRowBelowToActiveTable);
        document.getElementById('addColLeftBtn').addEventListener('click', addColumnLeftToActiveTable);
        document.getElementById('addColRightBtn').addEventListener('click', addColumnRightToActiveTable);
        document.getElementById('deleteRowBtn').addEventListener('click', deleteClickedRowFromActiveTable);
        document.getElementById('deleteColBtn').addEventListener('click', deleteClickedColumnFromActiveTable);


        document.getElementById('addNameBtnInModal').addEventListener('click', addNewNameToList);
        document.getElementById('importNameListBtn').addEventListener('click', () => nameListImportFileInputElement.click());
        nameListImportFileInputElement.addEventListener('change', handleNameListImport);
        searchNameInputElement.addEventListener('input', () => renderNameList(searchNameInputElement.value));


        draftListElement.addEventListener('click', async (e) => { // Made async for customConfirm
            const targetSpan = e.target.closest('.draft-item span');
            const targetButton = e.target.closest('.draft-item button');
            if (targetSpan) loadSelectedDraft(targetSpan.textContent);
            else if (targetButton) await confirmAndDeleteDraft(targetButton.parentElement.querySelector('span').textContent); // await customConfirm
        });
        nameListContainer.addEventListener('click', async (e) => { // Made async for customConfirm
            const nameItemSpan = e.target.closest('.name-item span[data-name]');
            const deleteButton = e.target.closest('.name-item button');
            if (nameItemSpan) selectNameForCellInsertion(nameItemSpan.dataset.name);
            else if (deleteButton) await deleteNameFromListAndStorage(deleteButton.parentElement.querySelector('span[data-name]').dataset.name); // await customConfirm
        });
        tablesContainer.addEventListener('click', handleTableCellClick);
        tablesContainer.addEventListener('blur', (e) => {
            if ((e.target.tagName === 'TD' || e.target.tagName === 'TH') && e.target.isContentEditable) {
                setTimeout(rebuildAndRenderSummary, 0);
            }
        }, true);
        tablesContainer.addEventListener('input', (e) => {
            if ((e.target.tagName === 'TD' || e.target.tagName === 'TH') && e.target.isContentEditable) {
                // Using a small delay to allow DOM to update, especially if pasting multiple cells
                setTimeout(rebuildAndRenderSummary, 300); 
            }
        });
    }

    // --- Draggable Modal Functionality ---
    function startDragModal(e) {
        if (e.target.closest('.modal-close-btn')) {
            isDraggingModal = false;
            return;
        }
        isDraggingModal = true;
        const clientX = e.clientX || (e.touches && e.touches[0].clientX);
        const clientY = e.clientY || (e.touches && e.touches[0].clientY);
        const rect = nameModalContent.getBoundingClientRect();
        nameModalContent.style.position = 'fixed'; // Ensure it's fixed for viewport-relative positioning
        nameModalContent.style.left = `${rect.left}px`;
        nameModalContent.style.top = `${rect.top}px`;
        nameModalContent.style.transform = 'none'; // Reset transform if any
        modalDragOffsetX = clientX - nameModalContent.offsetLeft;
        modalDragOffsetY = clientY - nameModalContent.offsetTop;
        if (e.type === 'touchstart') e.preventDefault(); // Prevent page scroll on touch
    }
    function dragModal(e) {
        if (!isDraggingModal) return;
        const clientX = e.clientX || (e.touches && e.touches[0].clientX);
        const clientY = e.clientY || (e.touches && e.touches[0].clientY);
        let newLeft = clientX - modalDragOffsetX;
        let newTop = clientY - modalDragOffsetY;
        // Boundary checks
        const modalRect = nameModalContent.getBoundingClientRect();
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        if (newLeft < 0) newLeft = 0;
        if (newTop < 0) newTop = 0;
        if (newLeft + modalRect.width > viewportWidth) newLeft = viewportWidth - modalRect.width;
        if (newTop + modalRect.height > viewportHeight) newTop = viewportHeight - modalRect.height;
        nameModalContent.style.left = `${newLeft}px`;
        nameModalContent.style.top = `${newTop}px`;
        if (e.type === 'touchmove') e.preventDefault(); // Prevent page scroll on touch
    }
    function stopDragModal() {
        if (isDraggingModal) {
            isDraggingModal = false;
            // No need to revert position to relative if it's meant to stay where dragged
        }
    }
    // --- Direct Copy Full HTML Functionality ---
    async function attemptDirectCopyToClipboard() {
        const fullHtml = document.documentElement.outerHTML;
        try {
            await navigator.clipboard.writeText(fullHtml);
            showMessage('Full HTML copied to clipboard!', 'success');
        } catch (err) {
            console.warn('navigator.clipboard.writeText failed, trying execCommand: ', err);
            const textarea = document.createElement('textarea');
            textarea.value = fullHtml;
            textarea.style.position = 'fixed'; textarea.style.left = '-9999px'; // Move off-screen
            document.body.appendChild(textarea);
            textarea.select();
            try {
                const successful = document.execCommand('copy');
                if (successful) showMessage('Full HTML copied! (using fallback method)', 'success');
                else showMessage('Direct copy failed. Please try copying manually.', 'error', 5000);
            } catch (execErr) {
                console.error('execCommand copy failed: ', execErr);
                showMessage('Direct copy failed. Please try copying manually.', 'error', 5000);
            }
            document.body.removeChild(textarea);
        }
    }

    // --- Draft Management ---
    function promptAndSaveDraft() {
        if (tablesContainer.children.length === 0) { showMessage('No schedule data to save.', 'error');
        return; }
        const allTablesData = tablesContainer.innerHTML;
        const allTableMeta = {};
        tablesContainer.querySelectorAll('table').forEach(table => {
            allTableMeta[table.id] = { name: table.dataset.tableName || table.id };
        });
        const draftName = customPrompt('Enter draft name:', `Draft ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString()}`);
        if (draftName) {
            const drafts = JSON.parse(localStorage.getItem(DRAFTS_KEY) || '{}');
            drafts[draftName] = { html: allTablesData, meta: allTableMeta, active: activeTableId };
            localStorage.setItem(DRAFTS_KEY, JSON.stringify(drafts));
            showMessage(`Draft "${draftName}" saved!`, 'success');
            if (draftListElement.style.display === 'block') renderDraftList();
        }
    }
    function toggleDraftListVisibility() {
        const isVisible = draftListElement.style.display === 'block';
        draftListElement.style.display = isVisible ? 'none' : 'block';
        if (!isVisible) renderDraftList();
    }
    function renderDraftList() {
        draftListElement.innerHTML = '';
        const drafts = JSON.parse(localStorage.getItem(DRAFTS_KEY) || '{}');
        if (Object.keys(drafts).length === 0) { draftListElement.innerHTML = '<p>No drafts saved yet.</p>'; return;
        }
        for (const name in drafts) {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'draft-item';
            itemDiv.innerHTML = `<span>${name}</span><button>Delete</button>`;
            draftListElement.appendChild(itemDiv);
        }
    }
    function loadSelectedDraft(draftName) {
        const drafts = JSON.parse(localStorage.getItem(DRAFTS_KEY) || '{}');
        if (drafts[draftName]) {
            tablesContainer.innerHTML = drafts[draftName].html;
            const tableMeta = drafts[draftName].meta || {};
            tableTabs.innerHTML = ''; // Clear existing tabs
            tablesContainer.querySelectorAll('table').forEach(table => {
                const id = table.id;
                const metaInfo = tableMeta[id] || {}; // Get meta info for this specific table
                const name = metaInfo.name || `Table ${tableTabs.children.length + 1}`; // Fallback name
                table.dataset.tableName = name; // Ensure dataset is updated
                addTabButton(id, name);
                // Make all cells editable again after loading
                table.querySelectorAll('td, th').forEach(cell => cell.contentEditable = 'true');
            });
            activeTableId = drafts[draftName].active || tablesContainer.querySelector('table')?.id || 'tbl_1'; // Sensible fallback
            if (document.getElementById(activeTableId)) switchTable(activeTableId);
            else if (tablesContainer.querySelector('table')) switchTable(tablesContainer.querySelector('table').id); // Fallback to first table if active one is gone
            else addNewTable(true); // Add a new table if container is empty
            showMessage(`Draft "${draftName}" loaded!`, 'success');
            draftListElement.style.display = 'none';
            rebuildAndRenderSummary(); // Rebuild summary based on loaded data
        } else { showMessage(`Draft "${draftName}" not found.`, 'error'); }
    }
    async function confirmAndDeleteDraft(draftName) { // Made async
        if (await customConfirm(`Are you sure you want to delete saved draft "${draftName}"?`)) { // await customConfirm
            const drafts = JSON.parse(localStorage.getItem(DRAFTS_KEY) || '{}');
            delete drafts[draftName];
            localStorage.setItem(DRAFTS_KEY, JSON.stringify(drafts));
            showMessage(`Saved draft "${draftName}" deleted.`, 'success');
            renderDraftList(); // Re-render the list
        }
    }

    async function confirmAndClearActiveTableContent() { // Made async
        const activeTableElement = document.getElementById(activeTableId);
        if (!activeTableElement) {
            showMessage('No active table to clear.', 'error');
            return;
        }
        const tableName = activeTableElement.dataset.tableName || `Table ${activeTableId.split('_').pop()}`;
        if (await customConfirm(`Are you sure you want to clear all content and unmerge cells in "${tableName}"? This will not delete saved drafts.`)) { // await customConfirm
            activeTableElement.querySelectorAll('thead th, tbody td, tbody th').forEach(cell => {
                cell.innerHTML = ''; // Clear content
                if (cell.tagName === 'TH') cell.textContent = ''; // Specifically for headers if they only had text
                cell.rowSpan = 1; // Reset spans
                cell.colSpan = 1;
                cell.classList.remove('merged'); // Remove merged class
                cell.classList.remove('selected'); // Remove selection class
            });
            selectedCells = []; // Clear selection array
            rebuildAndRenderSummary(); // Update the summary table
            showMessage(`Content of "${tableName}" cleared.`, 'success');
        }
    }

    // --- Draft Import/Export Functions ---
    function exportAllDrafts() {
        const drafts = localStorage.getItem(DRAFTS_KEY);
        if (!drafts || drafts === '{}') {
            showMessage('No drafts to export.', 'info');
            return;
        }
        try {
            const blob = new Blob([drafts], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'all_schedule_drafts.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showMessage('All drafts exported successfully!', 'success');
        } catch (error) {
            console.error("Error exporting drafts:", error);
            showMessage('Failed to export drafts.', 'error');
        }
    }

    async function handleDraftsFileImport(event) { // Made async
        const file = event.target.files[0];
        if (!file) {
            showMessage('No file selected for import.', 'info');
            return;
        }
        if (file.type !== 'application/json') {
            showMessage('Invalid file type. Please select a .json file.', 'error');
            event.target.value = ''; // Reset file input
            return;
        }

        const reader = new FileReader();
        reader.onload = async (e) => { // Made async
            try {
                const importedDraftsText = e.target.result;
                const importedDraftsData = JSON.parse(importedDraftsText);

                if (typeof importedDraftsData !== 'object' || importedDraftsData === null) {
                    showMessage('Invalid draft file format.', 'error');
                    return;
                }

                let localDrafts = JSON.parse(localStorage.getItem(DRAFTS_KEY) || '{}');
                let importedCount = 0;
                let overwrittenCount = 0;
                let skippedCount = 0;

                for (const draftName in importedDraftsData) {
                    if (Object.prototype.hasOwnProperty.call(importedDraftsData, draftName)) {
                        const draftData = importedDraftsData[draftName];
                        // Basic validation of draft structure
                        if (draftData && typeof draftData.html === 'string' && typeof draftData.meta === 'object' && typeof draftData.active === 'string') {
                            if (localDrafts[draftName]) {
                                if (await customConfirm(`Draft "${draftName}" already exists. Overwrite?`)) { // await customConfirm
                                    localDrafts[draftName] = draftData;
                                    overwrittenCount++;
                                } else {
                                    skippedCount++;
                                }
                            } else {
                                localDrafts[draftName] = draftData;
                                importedCount++;
                            }
                        } else {
                            console.warn(`Skipping invalid draft data for "${draftName}" during import.`);
                            skippedCount++;
                        }
                    }
                }

                localStorage.setItem(DRAFTS_KEY, JSON.stringify(localDrafts));
                showMessage(`Drafts import complete: ${importedCount} new, ${overwrittenCount} overwritten, ${skippedCount} skipped.`, 'success', 5000);
                if (draftListElement.style.display === 'block' || importedCount > 0 || overwrittenCount > 0) {
                    renderDraftList();
                }
            } catch (error) {
                console.error("Error importing drafts:", error);
                showMessage('Error processing draft file. Ensure it is a valid JSON export from this tool.', 'error', 5000);
            } finally {
                event.target.value = ''; // Reset file input
            }
        };
        reader.onerror = () => {
            showMessage('Failed to read the draft file.', 'error');
            event.target.value = ''; // Reset file input
        };
        reader.readAsText(file);
    }


    // --- Table Management ---
    function addTabButton(id, label) {
        const button = document.createElement('button');
        button.textContent = label;
        button.dataset.tableId = id; // Use dataset for easier retrieval
        button.onclick = () => switchTable(id);
        tableTabs.appendChild(button);
        return button;
    }
    function switchTable(id) {
        const targetTable = document.getElementById(id);
        if (!targetTable) {
            // If target table doesn't exist (e.g. after a delete), try to switch to the first available one
            const firstTableInDOM = tablesContainer.querySelector('table');
            if (firstTableInDOM) {
                id = firstTableInDOM.id;
            } else {
                showMessage('Cannot switch: Target table not found.', 'error');
                if (tablesContainer.children.length === 0) addNewTable(true); // If no tables, add one
                return;
            }
        }
        activeTableId = id;
        tablesContainer.querySelectorAll('table').forEach(t => t.classList.toggle('active', t.id === id));
        tableTabs.querySelectorAll('button').forEach(b => {
            b.classList.toggle('active', b.dataset.tableId === id);
        });
        deselectAllTableCells(); // Deselect cells when switching tables
        rebuildAndRenderSummary(); // Update summary for the new active table context
    }
    function addNewTable(isInitial = false) {
        tableCount++;
        const defaultTableName = `Schedule ${tableTabs.children.length + 1}`;
        const label = isInitial ? defaultTableName : customPrompt('Enter new table name:', defaultTableName);
        if (!label && !isInitial) return; // User cancelled prompt
        const newTable = document.createElement('table');
        const newTableId = `tbl_${Date.now()}_${tableCount}`; // More unique ID
        newTable.id = newTableId;
        newTable.dataset.tableName = label || defaultTableName; // Store name in dataset
        const thead = newTable.createTHead();
        const headerRow = thead.insertRow();
        // Default headers
        for (let i = 0; i < 7; i++) {
            const th = document.createElement('th');
            th.contentEditable = 'true';
            th.textContent = i === 0 ? 'Class/Time' : `Header ${i}`;
            headerRow.appendChild(th);
        }
        const tbody = newTable.createTBody();
        // Default rows
        for (let r = 0; r < 2; r++) {
            const dataRow = tbody.insertRow();
            for (let c = 0; c < headerRow.cells.length; c++) {
                const td = dataRow.insertCell();
                td.contentEditable = 'true';
                if (c === 0 && r === 0) td.textContent = `Sample A`;
                if (c === 0 && r === 1) td.textContent = `Sample B`;
            }
        }
        tablesContainer.appendChild(newTable);
        addTabButton(newTableId, label || defaultTableName);
        switchTable(newTableId); // Make the new table active
        if (!isInitial) showMessage(`Table "${label || defaultTableName}" added.`, 'success');
    }

    async function promptAndRenameActiveTable() { // Made async
        const currentTab = tableTabs.querySelector('button.active');
        if (!currentTab) {
            showMessage('No active table to rename. Please select a table.', 'error');
            return;
        }

        let tableIdToRename = currentTab.dataset.tableId; // Prefer dataset
        if (!tableIdToRename) { // Fallback for older structures if dataset isn't there
            const onclickAttr = currentTab.getAttribute('onclick');
            const match = onclickAttr ? onclickAttr.match(/'(tbl_.*?)'/) : null;
            if (match && match[1]) {
                tableIdToRename = match[1];
                if(!currentTab.dataset.tableId) currentTab.dataset.tableId = tableIdToRename; // Retroactively add dataset
            } else {
                showMessage('Could not identify table ID for renaming. Try switching tabs and trying again.', 'error');
                return;
            }
        }
        
        const tableElement = document.getElementById(tableIdToRename);
        if (!tableElement) {
            showMessage(`Error: Table element for ID ${tableIdToRename} not found.`, 'error');
            return;
        }

        const oldName = tableElement.dataset.tableName || currentTab.textContent; // Use dataset name or tab text
        const newName = customPrompt('Enter new table name:', oldName); // window.prompt is fine here

        if (newName && newName.trim() !== "" && newName.trim() !== oldName) {
            const trimmedNewName = newName.trim();
            currentTab.textContent = trimmedNewName;
            tableElement.dataset.tableName = trimmedNewName; // Update dataset
            // No need to switch activeTableId if it's already the active one being renamed
            if (activeTableId !== tableIdToRename) { // This case should ideally not happen if UI is consistent
                activeTableId = tableIdToRename; // Ensure consistency if it was somehow different
            }
            showMessage(`Table renamed to "${trimmedNewName}".`, 'success');
        } else if (newName && newName.trim() === oldName) {
            showMessage('New name is the same as the old name. No changes made.', 'info');
        } else if (newName === null) { // User cancelled
            showMessage('Rename cancelled.', 'info');
        } else { // Empty name submitted
            showMessage('Invalid new name. Please enter a valid name.', 'error');
        }
    }

    async function confirmAndDeleteActiveTable() { // Made async
        if (tablesContainer.children.length <= 1) { showMessage('Cannot delete the last table.', 'error'); return;
        }
        const activeTab = tableTabs.querySelector('button.active');
        const tableIdToDelete = activeTab ? activeTab.dataset.tableId : null;
        const tableElement = tableIdToDelete ? document.getElementById(tableIdToDelete) : null;
        const tableName = tableElement ? tableElement.dataset.tableName : (activeTab ? activeTab.textContent : 'the active table');


        if (await customConfirm(`Delete table "${tableName}"?`)) { // await customConfirm
            if (tableElement) tableElement.remove(); else document.getElementById(activeTableId)?.remove(); // Remove from DOM
            activeTab?.remove(); // Remove tab
            // Switch to the first remaining tab or add a new one if all are gone
            const firstRemainingTab = tableTabs.querySelector('button');
            if (firstRemainingTab) {
                const nextActiveId = firstRemainingTab.dataset.tableId || firstRemainingTab.getAttribute('onclick').match(/'(tbl_.*?)'/)[1]; // Fallback for onclick
                switchTable(nextActiveId);
            } else { // Should not happen if we prevent deleting the last table, but as a safeguard
                activeTableId = null;
                addNewTable(true);
            }
            showMessage(`Table "${tableName}" deleted.`, 'success');
        }
    }

    // --- Row/Column Operations ---
    function addRowToTable(tableBody, rowIndex, numCols) {
        const row = tableBody.insertRow(rowIndex); // rowIndex -1 appends
        for (let i = 0; i < numCols; i++) { const cell = row.insertCell(); cell.contentEditable = 'true';
        }
    }
    function addRowAboveToActiveTable() {
        const table = document.getElementById(activeTableId);
        if (!table || !table.tBodies[0] || table.rows.length === 0) return; // Check table and tbody
        const numCols = table.rows[0].cells.length; // Number of columns from first row (header or data)
        addRowToTable(table.tBodies[0], 0, numCols); // Insert at the beginning of tbody
        rebuildAndRenderSummary();
    }
    function addRowBelowToActiveTable() {
        const table = document.getElementById(activeTableId);
        if (!table || !table.tBodies[0] || table.rows.length === 0) return;
        const numCols = table.rows[0].cells.length;
        addRowToTable(table.tBodies[0], -1, numCols); // Append to tbody
        rebuildAndRenderSummary();
    }
    function addColumnToTable(table, colIndex) { // colIndex 0 for left, -1 for right
        for (const row of table.rows) {
            const isHeaderRow = row.parentElement.tagName === 'THEAD';
            const cell = isHeaderRow ? document.createElement('th') : row.insertCell(colIndex === -1 ? row.cells.length : colIndex);
            cell.contentEditable = 'true';
            if (isHeaderRow) { // If it's a header row and we created a TH, we need to append/insert it correctly
                if (colIndex === -1 || colIndex >= row.cells.length) row.appendChild(cell); // Append if TH was created for rightmost
                else row.insertBefore(cell, row.cells[colIndex]); // Insert if TH was for leftmost
                cell.textContent = ""; // New header cells are blank
            }
            // For TD, insertCell already places it correctly.
        }
    }
    function addColumnLeftToActiveTable() {
        const table = document.getElementById(activeTableId);
        if (table) { addColumnToTable(table, 0); rebuildAndRenderSummary(); }
    }
    function addColumnRightToActiveTable() {
        const table = document.getElementById(activeTableId);
        if (table) { addColumnToTable(table, -1); rebuildAndRenderSummary(); }
    }

    async function deleteClickedRowFromActiveTable() { // Made async
        if (!lastClickedCell) {
            showMessage('Please click a cell in the row you want to delete.', 'info');
            return;
        }
        const table = document.getElementById(activeTableId);
        if (!table || !table.tBodies[0]) {
            showMessage('No active table or table body found.', 'error');
            return;
        }
        const rowToDelete = lastClickedCell.closest('tr');
        if (!rowToDelete || !rowToDelete.parentElement || rowToDelete.parentElement.tagName !== 'TBODY') {
            showMessage('Cannot delete header row or invalid selection. Click a cell in a data row.', 'error');
            return;
        }
        if (table.tBodies[0].rows.length <= 1) {
            showMessage('Cannot delete the last data row.', 'error');
            return;
        }

        if (await customConfirm('Are you sure you want to delete this row?')) { // await customConfirm
            rowToDelete.remove();
            lastClickedCell = null; // Reset last clicked cell
            deselectAllTableCells(); // Clear any selections
            rebuildAndRenderSummary();
            showMessage('Row deleted.', 'success');
        }
    }

    async function deleteClickedColumnFromActiveTable() { // Made async
        if (!lastClickedCell) {
            showMessage('Please click a cell in the column you want to delete.', 'info');
            return;
        }
        const table = document.getElementById(activeTableId);
        if (!table) {
            showMessage('No active table found.', 'error');
            return;
        }

        // Check if it's the last visual column (considering colSpans)
        let visualCols = 0;
        if (table.rows.length > 0 && table.rows[0]) { // Use first row for colSpan check
            for (let i = 0; i < table.rows[0].cells.length; i++) {
                visualCols += table.rows[0].cells[i].colSpan || 1;
            }
        }
        if (visualCols <= 1) {
            showMessage('Cannot delete the last column.', 'error');
            return;
        }

        // Determine the visual index of the clicked column
        let clickedCellVisualIndex = 0;
        const clickedRow = lastClickedCell.parentNode;
        for (let i = 0; i < clickedRow.cells.length; i++) {
            if (clickedRow.cells[i] === lastClickedCell) break;
            clickedCellVisualIndex += clickedRow.cells[i].colSpan || 1;
        }

        // Confirm deletion
        if (await customConfirm('Are you sure you want to delete this column?')) { // await customConfirm
            for (const row of table.rows) {
                let currentVisualCol = 0;
                for (let i = 0; i < row.cells.length; i++) {
                    const cell = row.cells[i];
                    const cellColSpan = cell.colSpan || 1;
                    // Check if the current cell (or part of it, if spanned) falls into the clicked column's visual index
                    if (currentVisualCol <= clickedCellVisualIndex && clickedCellVisualIndex < currentVisualCol + cellColSpan) {
                        if (cellColSpan > 1) {
                            cell.colSpan -= 1; // Reduce colspan
                        } else {
                            cell.remove(); // Remove the cell
                        }
                        break; // Move to the next row once the column part is handled for this row
                    }
                    currentVisualCol += cellColSpan;
                }
            }
            lastClickedCell = null; // Reset
            deselectAllTableCells();
            rebuildAndRenderSummary();
            showMessage('Column deleted.', 'success');
        }
    }


    // --- Cell Selection, Merging, Unmerging ---
    function toggleCellSelectionMode() {
        selectionMode = !selectionMode;
        const btn = document.getElementById('selectBtn');
        btn.classList.toggle('active', selectionMode);
        btn.textContent = selectionMode ? '‚ú® Selecting...' : '‚ú® Select Cells';
        if (!selectionMode) deselectAllTableCells(); // Clear selection when turning off mode
    }
    function handleTableCellClick(event) {
        const cell = event.target.closest('td, th'); // Get the cell (TD or TH)
        if (!cell || !cell.closest(`#${activeTableId}`)) return; // Ensure click is on a cell within the active table

        lastClickedCell = cell; // Update last clicked cell regardless of mode

        if (selectedNameFromList) { // If a name is selected from the list for insertion
            if (cell.tagName === 'TD' || (cell.tagName === 'TH' && cell.closest('tbody'))) { // Allow insertion in data cells or body headers
                cell.textContent = selectedNameFromList;
                rebuildAndRenderSummary();
                showMessage(`Inserted "${selectedNameFromList}". Select another name or close list.`, 'success', 2500);
                clearNameSelection(); // Clear selection after insertion
            } else {
                showMessage('Click an editable data cell (or row header in body) to insert name.', 'info');
            }
            return; // Exit after handling name insertion
        }

        if (selectionMode) { // If in cell selection mode
            cell.classList.toggle('selected');
            if (cell.classList.contains('selected')) selectedCells.push(cell);
            else selectedCells = selectedCells.filter(c => c !== cell);
        }
    }
    function deselectAllTableCells() {
        selectedCells.forEach(c => c.classList.remove('selected'));
        selectedCells = [];
    }
    function mergeSelectedTableCells() {
        if (selectedCells.length < 2) { showMessage('Select at least two cells to merge.', 'error');
        return; }
        const table = document.getElementById(activeTableId);
        // Determine bounds of selection
        let minR = Infinity, maxR = -Infinity, minC = Infinity, maxC = -Infinity;
        selectedCells.forEach(cell => {
            const r = cell.parentNode.rowIndex; const c = cell.cellIndex; // Actual cell index in its row
            minR = Math.min(minR, r); maxR = Math.max(maxR, r + (cell.rowSpan || 1) - 1);
            minC = Math.min(minC, c); maxC = Math.max(maxC, c + (cell.colSpan || 1) - 1);
            // Note: This simple minC/maxC might not be perfectly accurate for complex tables with existing colSpans.
            // A more robust approach would map to a virtual grid. For now, this is a common simplification.
        });
        const firstCell = table.rows[minR]?.cells[minC]; // Top-left cell of the merge area
        if (!firstCell) { showMessage('Error finding merge starting cell.', 'error'); return;
        }
        let contentToKeep = firstCell.innerHTML; // Keep content from the first cell
        let cellsToRemove = [];
        // Iterate over the bounding box of selected cells to identify cells to remove
        for (let r = minR; r <= maxR; r++) {
            for (let c = minC; c <= maxC; c++) { // This loop is conceptual; actual cell removal needs care
                // This part needs to be smarter if cells within the rect are not selected or already part of other merges
                if (table.rows[r]?.cells[c]) { // Check if cell exists at this conceptual coordinate
                    const currentCell = table.rows[r].cells[c];
                    if (currentCell !== firstCell && selectedCells.includes(currentCell)) cellsToRemove.push(currentCell);
                }
            }
        }
        cellsToRemove.forEach(cell => cell.remove());
        firstCell.rowSpan = maxR - minR + 1; firstCell.colSpan = maxC - minC + 1; // This needs careful calculation
        firstCell.innerHTML = contentToKeep; firstCell.classList.add('merged');
        deselectAllTableCells();
        if (selectionMode) toggleCellSelectionMode(); // Optionally turn off selection mode
        rebuildAndRenderSummary(); showMessage('Cells merged.', 'success');
    }

    function unmergeActiveCellIfMerged() {
        let cellToUnmerge = null;
        // Prefer a single selected cell if it's merged
        if (selectedCells.length === 1 && (selectedCells[0].rowSpan > 1 || selectedCells[0].colSpan > 1)) {
            cellToUnmerge = selectedCells[0];
        }
        // Fallback to the last clicked cell if it's merged and part of the active table
        else if (lastClickedCell && (lastClickedCell.rowSpan > 1 || lastClickedCell.colSpan > 1) && lastClickedCell.closest(`#${activeTableId}`)) {
            cellToUnmerge = lastClickedCell;
        }

        if (cellToUnmerge) {
            unmergeGivenCell(cellToUnmerge);
        } else {
            showMessage('Click a merged cell to unmerge it, or select a single merged cell.', 'error');
        }
    }

    function unmergeGivenCell(cellToUnmerge) {
        const table = cellToUnmerge.closest('table');
        if (!table) {
            showMessage('No table found for cell.', 'error');
            return;
        }
        const rowIndex = cellToUnmerge.parentNode.rowIndex;
        const cellIndex = cellToUnmerge.cellIndex; // Actual index in the row's cells collection
        const rowSpan = cellToUnmerge.rowSpan || 1;
        const colSpan = cellToUnmerge.colSpan || 1;
        if (rowSpan === 1 && colSpan === 1) {
            showMessage('Cell is not merged.', 'info');
            return; }
        const content = cellToUnmerge.innerHTML; // Preserve content
        // Reset the original cell
        cellToUnmerge.rowSpan = 1;
        cellToUnmerge.colSpan = 1;
        cellToUnmerge.classList.remove('merged');
        cellToUnmerge.innerHTML = content; // Put content back into the now unmerged top-left cell

        // Add back the other cells that were covered by the span
        for (let r = rowIndex; r < rowIndex + rowSpan; r++) {
            const row = table.rows[r];
            if (!row) continue; // Should not happen in a well-formed table

            // Determine the correct insertion point for new cells in this row
            // This needs to account for existing cells and their colSpans to find the true visual column.
            let currentVisualColIndex = 0;
            let insertAtIndex = 0; // This will be the physical cell index to insert before
            for(insertAtIndex = 0; insertAtIndex < row.cells.length; insertAtIndex++) {
                if(currentVisualColIndex >= cellIndex) break; // Found the physical spot corresponding to the original merged cell's start
                currentVisualColIndex += (row.cells[insertAtIndex].colSpan || 1);
            }


            for (let c = 0; c < colSpan; c++) {
                if (r === rowIndex && c === 0) continue; // Skip the original cell itself

                // For cells in the first row of the unmerged block (but not the very first cell)
                if (r === rowIndex && c > 0) {
                     const newCell = row.insertCell(insertAtIndex + c); // Insert at correct physical index
                     newCell.contentEditable = 'true'; newCell.innerHTML = ''; // New cells are blank
                }
                // For cells in subsequent rows of the unmerged block
                else if (r > rowIndex) {
                     // For subsequent rows, new cells are inserted starting from the calculated insertAtIndex
                     const newCell = row.insertCell(insertAtIndex + c);
                     newCell.contentEditable = 'true'; newCell.innerHTML = '';
                }
            }
        }
        deselectAllTableCells();
        rebuildAndRenderSummary();
        showMessage('Cell unmerged.', 'success');
    }

    // --- Name List Management (Modal) ---
    function highlightSelectedNameInList(nameToHighlight) {
        if (!nameListContainer) return;
        nameListContainer.querySelectorAll('.name-item span').forEach(span => {
            if (span.dataset.name === nameToHighlight) {
                span.classList.add('highlighted');
            } else {
                span.classList.remove('highlighted');
            }
        });
    }

    function clearNameSelection() {
        selectedNameFromList = null;
        if (nameListContainer) {
            nameListContainer.querySelectorAll('.name-item span.highlighted').forEach(span => {
                span.classList.remove('highlighted');
            });
        }
    }

    function loadNames() { names = JSON.parse(localStorage.getItem(NAMES_KEY) || '["Teacher A", "Subject B", "Class C", "LAU", "LISAH"]');
    }
    function saveNames() { localStorage.setItem(NAMES_KEY, JSON.stringify(names)); }

    function closeNameModal() {
        if (nameModal) {
            nameModal.style.display = 'none';
        }
        clearNameSelection(); // Clear any visual selection in the list
        if(searchNameInputElement) searchNameInputElement.value = ''; // Clear search input
    }

    function toggleNameListModalVisibility() {
        if (!nameModal || !nameModalContent || !newNameInput) return;
        const isDisplayed = nameModal.style.display === 'flex';
        if (isDisplayed) {
            nameModal.style.display = 'none';
            clearNameSelection();
            if(searchNameInputElement) searchNameInputElement.value = '';
        } else {
            // Reset modal position before showing for better centering if it was dragged
            nameModalContent.style.position = 'relative'; // Or 'static' if it's centered by flexbox
            nameModalContent.style.left = 'auto';
            nameModalContent.style.top = 'auto';
            nameModalContent.style.transform = 'none'; // Remove any transform from dragging

            nameModal.style.display = 'flex'; // Show modal
            if(searchNameInputElement) searchNameInputElement.value = ''; // Clear search
            renderNameList(); // Populate list
            newNameInput.focus(); // Focus on add name input
            clearNameSelection(); // Ensure no name is pre-selected
        }
    }

    function renderNameList(filterText = '') {
        if (!nameListContainer) return;
        nameListContainer.innerHTML = ''; // Clear current list

        const normalizedFilterText = filterText.toLowerCase().trim();
        const filteredNames = names.filter(name => name.toLowerCase().includes(normalizedFilterText));

        if (filteredNames.length === 0) {
            nameListContainer.innerHTML = `<p style="text-align:center; grid-column: 1 / -1;">${normalizedFilterText ? 'No names match your search.' : 'No names. Add some!'}</p>`;
            return;
        }

        filteredNames.sort((a,b) => a.localeCompare(b)); // Sort names alphabetically

        filteredNames.forEach(name => {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'name-item';
            itemDiv.innerHTML = `<span data-name="${name}">${name}</span><button>Delete</button>`;
            nameListContainer.appendChild(itemDiv);
        });
    }
    function addNewNameToList() {
        if (!newNameInput) return;
        const newName = newNameInput.value.trim();
        if (!newName) { showMessage('Enter a name.', 'error'); return;
        }
        if (names.includes(newName)) { showMessage('Name already exists.', 'error'); return; }
        names.push(newName); saveNames();
        renderNameList(searchNameInputElement.value); // Re-render list with current filter
        newNameInput.value = ''; newNameInput.focus(); // Clear input and refocus
        rebuildAndRenderSummary(); // Update summary as names list changed
        showMessage(`"${newName}" added.`, 'success');
    }

    async function deleteNameFromListAndStorage(nameToDelete) { // Made async
        if (await customConfirm(`Delete "${nameToDelete}"? This will also remove the name from all schedule tables.`)) { // await customConfirm
            names = names.filter(n => n !== nameToDelete);
            saveNames();

            // Remove the name from all cells in all tables
            tablesContainer.querySelectorAll('table').forEach(table => {
                table.querySelectorAll('tbody td, tbody th').forEach(cell => { // Check data cells and body headers
                    // Only clear if it's not the first column (typically class/subject identifier)
                    if (cell.cellIndex > 0 && cell.textContent.trim() === nameToDelete) {
                        cell.textContent = ''; // Clear the cell
                    }
                });
            });
            renderNameList(searchNameInputElement.value); // Update displayed name list
            rebuildAndRenderSummary(); // Update summary table
            showMessage(`"${nameToDelete}" removed from list and all schedules.`, 'success');
            if (selectedNameFromList === nameToDelete) { // If the deleted name was selected for insertion
                clearNameSelection();
            }
        }
    }

    function selectNameForCellInsertion(name) {
        selectedNameFromList = name;
        highlightSelectedNameInList(name); // Visually indicate selection
        showMessage(`Selected "${name}". Click a cell to insert.`, 'info', 4000);
    }

    function handleNameListImport(event) {
        const file = event.target.files[0];
        if (!file) {
            showMessage('No file selected for import.', 'info');
            return;
        }
        if (file.type !== 'text/plain') {
            showMessage('Invalid file type. Please select a .txt file.', 'error');
            event.target.value = ''; // Reset file input
            return;
        }

        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const content = e.target.result;
                const importedNames = content.split(/\r?\n/) // Split by newline
                                          .map(name => name.trim()) // Trim whitespace
                                          .filter(name => name !== ''); // Remove empty lines

                if (importedNames.length === 0) {
                    showMessage('No names found in the selected file.', 'info');
                    return;
                }

                let newNamesAddedCount = 0;
                importedNames.forEach(importedName => {
                    if (!names.includes(importedName)) { // Add only if not already present
                        names.push(importedName);
                        newNamesAddedCount++;
                    }
                });

                if (newNamesAddedCount > 0) {
                    saveNames();
                    renderNameList(searchNameInputElement.value); // Update display
                    rebuildAndRenderSummary(); // Update summary
                    showMessage(`${newNamesAddedCount} new name(s) imported successfully!`, 'success');
                } else {
                    showMessage('All names from the file already exist in the list.', 'info');
                }
            } catch (error) {
                console.error("Error importing name list:", error);
                showMessage('Error processing the name list file.', 'error');
            } finally {
                event.target.value = ''; // Reset file input
            }
        };
        reader.onerror = () => {
            showMessage('Failed to read the name list file.', 'error');
            event.target.value = ''; // Reset file input
        };
        reader.readAsText(file);
    }


    // --- Excel Export/Import ---
    function handleExcelFileImport(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const workbook = XLSX.read(new Uint8Array(e.target.result), { type: 'array' });
                const sheetName = workbook.SheetNames[0]; const worksheet = workbook.Sheets[sheetName];
                // Generate HTML table from sheet, making cells editable
                const htmlTableString = XLSX.utils.sheet_to_html(worksheet, { editable: true, raw: false });
                tableCount++; // Increment global table counter
                const newTableId = `tbl_imported_${Date.now()}_${tableCount}`;
                const importedTableName = file.name.replace(/\.xlsx?/i, '') || `Imported ${tableCount}`; // Use filename as table name
                const tempDiv = document.createElement('div'); tempDiv.innerHTML = htmlTableString;
                const importedTableElement = tempDiv.querySelector('table');
                if (importedTableElement) {
                    importedTableElement.id = newTableId;
                    importedTableElement.dataset.tableName = importedTableName;
                    // Ensure all imported cells are contenteditable
                    importedTableElement.querySelectorAll('td, th').forEach(cell => cell.contentEditable = 'true');
                    tablesContainer.appendChild(importedTableElement);
                    addTabButton(newTableId, importedTableName); switchTable(newTableId); // Add tab and switch
                    showMessage('Excel data imported into a new table!', 'success');
                } else { showMessage('Could not parse table from Excel.', 'error');
                }
            } catch (error) { console.error("Excel import error:", error);
                showMessage('Error processing Excel file.', 'error'); }
            finally { event.target.value = ''; // Reset file input
            }
        };
        reader.readAsArrayBuffer(file);
    }
    function exportActiveTableToExcel() {
        const tableToExport = document.getElementById(activeTableId);
        if (!tableToExport) { showMessage('No active table to export.', 'error'); return; }
        const tableName = tableToExport.dataset.tableName || activeTableId; // Use dataset name or ID
        const wb = XLSX.utils.table_to_book(tableToExport, { sheet: tableName });
        XLSX.writeFile(wb, `${tableName}_${new Date().toISOString().split('T')[0]}.xlsx`); // Filename with date
        showMessage(`Table "${tableName}" exported.`, 'success');
    }

    // --- Summary Table Logic ---
    function rebuildAndRenderSummary() {
        console.log("--- rebuildAndRenderSummary called ---");
        buildSummaryTableSkeleton(); // Build the structure (headers, rows for names)
        updateSummaryTableData();    // Populate with data from schedule tables
        console.log("--- rebuildAndRenderSummary finished ---");
    }

    function parseTimeToMinutes(timeStr) {
        if (typeof timeStr !== 'string') return Infinity; // Handle non-string inputs
        // Regex to match HH:MM or HH.MM, allowing for optional leading zero on hour
        const match = timeStr.match(/^(\d{1,2})\s*[:.]\s*(\d{2})/);
        if (match) {
            return parseInt(match[1], 10) * 60 + parseInt(match[2], 10);
        }
        return Infinity; // Return Infinity if format is not matched, for sorting non-time strings last
    }

    function buildSummaryTableSkeleton() {
        console.log("--- buildSummaryTableSkeleton starting ---");
        if (!summaryTableElement) {
            console.error("Summary table element not found in buildSummaryTableSkeleton.");
            return;
        }
        summaryTableElement.innerHTML = ''; // Clear previous summary content

        const summaryRowItems = new Set(names); // Names for rows (unique)
        const summaryColumnHeadersSet = new Set(); // Time slots for columns (unique)

        // Collect all unique time headers from all schedule tables
        tablesContainer.querySelectorAll('table').forEach(table => {
            if (table.tHead && table.tHead.rows.length > 0) {
                // Skip the first header cell (usually 'Class/Time')
                Array.from(table.tHead.rows[0].cells).slice(1).forEach(th => { 
                    const headerText = th.textContent.trim();
                    if (headerText) { // Add if not empty
                        summaryColumnHeadersSet.add(headerText);
                    }
                });
            }
        });
        
        // Ensure the special "10.15-10.30" slot is present for LAU/LISAH rule, if not already from tables
        const targetSlotForSpecialNamesInSkeleton = "10.15-10.30";
        if (!summaryColumnHeadersSet.has(targetSlotForSpecialNamesInSkeleton)) {
             summaryColumnHeadersSet.add(targetSlotForSpecialNamesInSkeleton);
             console.log(`BUILD: Added '${targetSlotForSpecialNamesInSkeleton}' to summary headers set because it was missing.`);
        }
        console.log("BUILD: Summary column headers before sort:", JSON.stringify(Array.from(summaryColumnHeadersSet)));

        const sortedSummaryRowHeaders = Array.from(summaryRowItems).sort((a,b) => a.localeCompare(b)); // Sort names alphabetically
        
        // Sort time headers chronologically, then alphabetically for non-time strings
        let rawColumnHeaders = Array.from(summaryColumnHeadersSet);
        rawColumnHeaders.sort((a, b) => {
            const timeA = parseTimeToMinutes(a);
            const timeB = parseTimeToMinutes(b);
            if (timeA !== Infinity && timeB !== Infinity) { return timeA - timeB; } // Both are times
            else if (timeA !== Infinity) { return -1; } // Only A is time, sort A first
            else if (timeB !== Infinity) { return 1; }  // Only B is time, sort B first
            return a.localeCompare(b); // Both are not times (or parse failed), sort alphabetically
        });

        // *** MODIFICATION: Set first column header to "Nama/Masa" ***
        const finalSummaryColumnHeaders = ['Nama/Masa', ...rawColumnHeaders]; 
        console.log("BUILD: Final sorted summary column headers:", JSON.stringify(finalSummaryColumnHeaders));

        // Create summary table header row
        const thead = summaryTableElement.createTHead();
        const headerRowForSummary = thead.insertRow();
        finalSummaryColumnHeaders.forEach(headerText => {
            const th = document.createElement('th');
            th.textContent = headerText;
            headerRowForSummary.appendChild(th);
        });

        // Create summary table body rows (one for each name)
        const tbody = summaryTableElement.createTBody();
        if (sortedSummaryRowHeaders.length === 0) {
            // Optional: Add a placeholder row if no names are present
            // const tr = tbody.insertRow();
            // const td = tr.insertCell();
            // td.textContent = "No names in the list to summarize.";
            // td.colSpan = finalSummaryColumnHeaders.length;
            // td.style.textAlign = 'center';
        } else {
            sortedSummaryRowHeaders.forEach(name => {
                const tr = tbody.insertRow();
                tr.insertCell().textContent = name; // First cell is the name
                // Add empty cells for each time slot column
                for (let i = 1; i < finalSummaryColumnHeaders.length; i++) {
                    tr.insertCell().textContent = ''; // Initialize with empty string
                }
            });
        }
        console.log("--- buildSummaryTableSkeleton finished ---");
    }

    function updateSummaryTableData() {
        console.log("--- updateSummaryTableData starting ---");
        if (!summaryTableElement || !summaryTableElement.tBodies || !summaryTableElement.tHead || !summaryTableElement.tHead.rows[0]) {
            console.error("UPDATE: Summary table element or its head/body not ready.");
            return;
        }
        // Check if the summary table body is empty or has a placeholder (e.g., "No items")
        if (summaryTableElement.tBodies.length === 0 || summaryTableElement.tBodies[0].rows.length === 0) {
            // If a placeholder row exists (usually one cell spanning all columns)
            if (summaryTableElement.tBodies[0]?.rows[0]?.cells[0]?.colSpan > 1) {
                 console.log("UPDATE: Summary table has placeholder 'no items' row, skipping update for now.");
                 return;
            }
            // If truly empty, might indicate an issue or that buildSummaryTableSkeleton needs to run first.
            console.log("UPDATE: Summary table body is empty, attempting to rebuild skeleton first.");
            buildSummaryTableSkeleton(); // Attempt to rebuild if it seems uninitialized
            // Re-check after attempting rebuild
            if (!summaryTableElement.tBodies[0] || summaryTableElement.tBodies[0].rows.length === 0 ||
                (summaryTableElement.tBodies[0].rows[0].cells.length === 1 && summaryTableElement.tBodies[0].rows[0].cells[0].colSpan > 1) ) {
                console.error("UPDATE: Summary table still not properly structured after rebuild attempt.");
                return;
            }
        }

        const summaryBody = summaryTableElement.tBodies[0];
        // Get actual headers from the DOM of the summary table (should include "Nama/Masa" as first)
        const summaryTableActualColumnHeaders = Array.from(summaryTableElement.tHead.rows[0].cells).map(th => th.textContent.trim());
        
        console.log("UPDATE: Names for summary rows:", JSON.stringify(names));
        console.log("UPDATE: Summary Table Headers (Raw from DOM):", JSON.stringify(Array.from(summaryTableElement.tHead.rows[0].cells).map(th => th.textContent)));
        console.log("UPDATE: Summary Table Headers (Trimmed for matching):", JSON.stringify(summaryTableActualColumnHeaders));
        // Normalize headers for robust lookup (remove spaces, convert : to .)
        const normalizedSummaryHeadersForLookup = summaryTableActualColumnHeaders.map(h => h.replace(/\s/g, "").replace(/:/g,"."));
        console.log("UPDATE: Summary Table Headers (Fully Normalized for findIndex):", JSON.stringify(normalizedSummaryHeadersForLookup));


        // Clear existing data and conflict highlights from summary cells (but not names in first col)
        Array.from(summaryBody.rows).forEach(summaryRow => {
            Array.from(summaryRow.cells).slice(1).forEach(cell => { // Start from 2nd cell
                cell.textContent = '';
                cell.classList.remove('highlight-conflict');
            });
        });

        // Iterate through each schedule table to populate the summary
        tablesContainer.querySelectorAll('table').forEach(scheduleTable => {
            console.log(`UPDATE: Processing Schedule Table: ${scheduleTable.id} (${scheduleTable.dataset.tableName || 'N/A'})`);
            if (!scheduleTable.tHead?.rows.length > 0 || !scheduleTable.tBodies[0]) {
                console.log("UPDATE: Skipping schedule table due to missing head/body.");
                return;
            }
            const currentScheduleTableHeaders = Array.from(scheduleTable.tHead.rows[0].cells).map(th => th.textContent.trim());
            console.log("UPDATE: Current Schedule Table Headers (Trimmed):", JSON.stringify(currentScheduleTableHeaders));

            // Iterate through data rows of the current schedule table
            Array.from(scheduleTable.tBodies[0].rows).forEach((scheduleDataRow, rowIndex) => {
                const classIdentifier = scheduleDataRow.cells[0]?.textContent.trim(); // e.g., "5S1"
                if (!classIdentifier) return; // Skip if no class identifier
                
                let visualColumnOffsetForDataCells = 0; // Tracks visual column index due to colSpans

                // Iterate through cells in the schedule row (skip first cell - classIdentifier)
                for (let physicalCellIndex = 1; physicalCellIndex < scheduleDataRow.cells.length; physicalCellIndex++) {
                    const scheduleCell = scheduleDataRow.cells[physicalCellIndex];
                    const entryInScheduleCell = scheduleCell.textContent.trim(); // Name found in schedule (e.g., "JAMES")
                    const cellColSpan = scheduleCell.colSpan || 1;

                    if (entryInScheduleCell && names.includes(entryInScheduleCell)) { // If cell has a recognized name
                        console.log(`  UPDATE: Found name '${entryInScheduleCell}' in schedule table '${scheduleTable.dataset.tableName}', class '${classIdentifier}', cell content '${scheduleCell.textContent}'`);
                        // Handle colSpans: the name applies to all visual columns covered by this cell
                        for (let k = 0; k < cellColSpan; k++) {
                            const actualHeaderIndexInScheduleTable = visualColumnOffsetForDataCells + k + 1; // +1 because schedule headers array includes the 'Class' col

                            if (actualHeaderIndexInScheduleTable < currentScheduleTableHeaders.length) {
                                const scheduleColumnHeaderForThisCell = currentScheduleTableHeaders[actualHeaderIndexInScheduleTable]; // e.g., "09:00"
                                console.log(`    UPDATE: Span part ${k}: Corresponds to schedule header '${scheduleColumnHeaderForThisCell}' (raw)`);

                                let summaryColumnToUse = scheduleColumnHeaderForThisCell; // Default to the schedule's header
                                const specialNames = ["LAU", "LISAH"];
                                const targetSlotForSpecialNames = "10.15-10.30"; 
                                const sourceSlotToShift = "10.30-12.00";   

                                // Normalize for comparison (remove spaces, convert : to .)
                                const normalizedScheduleColumnHeader = scheduleColumnHeaderForThisCell.replace(/\s/g, "").replace(/:/g,".");
                                const normalizedSourceSlotToShift = sourceSlotToShift.replace(/\s/g, "").replace(/:/g,".");

                                console.log(`      UPDATE: Normalized schedule header: '${normalizedScheduleColumnHeader}'. Comparing with normalized source slot: '${normalizedSourceSlotToShift}'`);

                                // Special rule for LAU/LISAH: if they are in "10.30-12.00", move them to "10.15-10.30" in summary
                                if (specialNames.includes(entryInScheduleCell) && normalizedScheduleColumnHeader === normalizedSourceSlotToShift) {
                                    summaryColumnToUse = targetSlotForSpecialNames; 
                                    console.log(`        UPDATE: SPECIAL RULE TRIGGERED for '${entryInScheduleCell}'. Original schedule slot '${scheduleColumnHeaderForThisCell}' matched source '${sourceSlotToShift}'. Shifting to summary slot '${targetSlotForSpecialNames}'.`);
                                }

                                // Find the target row in the summary table for this name
                                const targetSummaryRow = Array.from(summaryBody.rows).find(sr => sr.cells[0]?.textContent === entryInScheduleCell);

                                if (targetSummaryRow) {
                                    // Find the target column index in the summary table
                                    const normalizedSummaryColumnToUseForLookup = summaryColumnToUse.replace(/\s/g, "").replace(/:/g,".");
                                    const targetSummaryColumnCellIndex = normalizedSummaryHeadersForLookup.findIndex(h => h === normalizedSummaryColumnToUseForLookup);
                                    
                                    console.log(`        UPDATE: Target summary row for '${entryInScheduleCell}'. Attempting to use summary column '${summaryColumnToUse}' (normalized for lookup: '${normalizedSummaryColumnToUseForLookup}').`);
                                    console.log(`        UPDATE: Index found in summary headers: ${targetSummaryColumnCellIndex}. (Lookup was against: ${JSON.stringify(normalizedSummaryHeadersForLookup)})`);

                                    // targetSummaryColumnCellIndex > 0 because index 0 is "Nama/Masa"
                                    if (targetSummaryColumnCellIndex > 0) { 
                                        const summaryCellToUpdate = targetSummaryRow.cells[targetSummaryColumnCellIndex];
                                        console.log(`          UPDATE: Updating summary cell: Row='${entryInScheduleCell}', ColHeader='${summaryTableActualColumnHeaders[targetSummaryColumnCellIndex]}', CurrentContent='${summaryCellToUpdate.textContent}'`);
                                        let existingClassesInSummaryCell = [];
                                        if (summaryCellToUpdate.textContent.trim() !== '') {
                                            existingClassesInSummaryCell = summaryCellToUpdate.textContent.trim().split(',')
                                                                            .map(s => s.trim())
                                                                            .filter(s => s !== ''); // Remove empty strings from split
                                        }
                                        if (!existingClassesInSummaryCell.includes(classIdentifier)) {
                                            existingClassesInSummaryCell.push(classIdentifier);
                                            summaryCellToUpdate.textContent = existingClassesInSummaryCell.join(', ');
                                            console.log(`            UPDATE: New content for summary cell: '${summaryCellToUpdate.textContent}'`);
                                        } else {
                                            console.log(`            UPDATE: Class '${classIdentifier}' already present in summary cell.`);
                                        }
                                    } else {
                                         console.warn(`        UPDATE WARN: Could not find summary column for '${summaryColumnToUse}' (normalized for lookup: '${normalizedSummaryColumnToUseForLookup}') for name '${entryInScheduleCell}'. This might happen if a schedule header doesn't exist in the summary table after special rule processing or due to new headers.`);
                                    }
                                } else {
                                     console.warn(`      UPDATE WARN: Could not find summary row for name '${entryInScheduleCell}'. Ensure name exists in the managed name list.`);
                                }
                            }
                        }
                    }
                    visualColumnOffsetForDataCells += cellColSpan; // Advance by the colspan of the current schedule cell
                }
            });
        });

        // Highlight conflicts (multiple classes in one summary cell)
        Array.from(summaryBody.rows).forEach(summaryRow => {
            Array.from(summaryRow.cells).forEach((cell, cellIndex) => {
                if (cellIndex > 0) { // Skip the name column
                    const cellText = cell.textContent.trim();
                    if (cellText.includes(',')) { // If multiple classes are listed
                        const classesListed = cellText.split(',')
                                                .map(s => s.trim())
                                                .filter(s => s !== '');
                        const uniqueClasses = new Set(classesListed);
                        if (uniqueClasses.size > 1) { // More than one unique class means a conflict
                            cell.classList.add('highlight-conflict');
                        }
                    }
                }
            });
        });
        console.log("--- updateSummaryTableData finished ---");
    }
</script>
</body>
</html>