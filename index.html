<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>Weekly Schedule with Firestore Names</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', 'Roboto', Arial, sans-serif;
            margin: 0;
            background-color: #e9ecef; /* Slightly lighter background for better clarity */
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            box-sizing: border-box;
            font-size: 14px;
        }
        .main-container {
            width: 100%;
            max-width: 1400px;
            background-color: #ffffff;
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 6px 20px rgba(0,0,0,0.08);
            box-sizing: border-box;
        }
        h2, h3 {
            color: #1c1e21;
            text-align: center;
            margin-top: 15px;
            margin-bottom: 15px;
            font-size: 1.5em;
        }
        #scheduleTitle {
            font-size: 1.8em;
            color: #0056b3;
            border-bottom: 2px solid #0056b3;
            padding-bottom: 8px;
        }
        #userIdDisplay {
            text-align: center;
            font-size: 0.8em;
            color: #555;
            margin-bottom: 15px;
            min-height: 1.2em;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin-top: 15px;
            margin-bottom: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            background-color: #fff;
            table-layout: auto;
            font-size: 0.85em;
        }
        #tablesContainer {
            overflow-x: auto;
            position: relative;
            width: 100%;
            -webkit-overflow-scrolling: touch;
        }
        #tablesContainer > table {
            display: none;
        }
        #tablesContainer > table.active {
            display: table;
        }
        #summaryTable {
            display: table;
            margin-top: 20px;
            font-size: 0.8em;
        }
        th, td {
            border: 1px solid #dee2e6;
            padding: 6px 8px;
            text-align: center;
            min-width: 70px;
            box-sizing: border-box;
            word-break: break-word;
        }
        table th {
            background-color: #f8f9fa;
            color: #343a40;
            font-weight: 600;
            white-space: normal;
            padding: 8px 5px;
        }
        td.selected, th.selected {
            outline: 2px solid #007bff;
            background-color: #dbeafe;
        }
        .bar {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 15px;
            align-items: center;
            justify-content: center;
        }
        .bar button, .table-tabs button, .name-session-tabs button {
            padding: 8px 12px;
            font-size: 0.85em;
            border-radius: 6px;
            cursor: pointer;
            border: 1px solid #ced4da;
            background-color: #fff;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 1px 3px rgba(0,0,0,0.06);
            display: inline-flex;
            align-items: center;
            gap: 5px;
            flex-shrink: 0;
        }
        .bar button:hover, .table-tabs button:hover, .name-session-tabs button:hover {
            background-color: #f8f9fa;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            transform: translateY(-1px);
        }
        .bar button:active, .table-tabs button:active, .name-session-tabs button:active {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }

        #rowColManipulationBar button {
            padding: 6px 10px;
        }
        #directCopyFullHtmlBtn { background-color: #545b62; color: white; border-color: #545b62;}
        #excelBtnTrigger, #importExcelBtn { background-color: #28a745; color: white; border-color: #28a745;}
        #saveDraftBtn { background-color: #007bff; color: white; border-color: #007bff;}
        #loadDraftBtn { background-color: #ffc107; color: #212529; border-color: #ffc107;}
        #clearActiveTableContentBtn { background-color: #fd7e14; color: white; border-color: #fd7e14;}
        #selectBtn { background-color: #17a2b8; color: white; border-color: #17a2b8;}
        #selectBtn.active { background-color: #fd7e14; border-color: #fd7e14;}
        #mergeBtn { background-color: #6f42c1; color: white; border-color: #6f42c1;}
        #unmergeBtn { background-color: #e83e8c; color: white; border-color: #e83e8c;}
        #addTableBtn { background-color: #20c997; color: white; border-color: #20c997;}
        #renameTableBtn { background-color: #6c757d; color: white; border-color: #6c757d;}
        #deleteTableBtn { background-color: #dc3545; color: white; border-color: #dc3545;}
        #nameListBtn { background-color: #fd7e14; color: white; border-color: #fd7e14;}
        #deselectBtn { background-color: #6c757d; color: white; border-color: #6c757d;}
        #exportDraftsBtn { background-color: #4e54c8; color: white; border-color: #4e54c8;}
        #importDraftsBtn { background-color: #8f94fb; color: white; border-color: #8f94fb;}

        .table-tabs {
            margin-bottom: 10px;
            border-bottom: 2px solid #007bff;
            padding-bottom: 0;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }
        .table-tabs button {
            background-color: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            border-radius: 6px 6px 0 0;
            color: #0056b3;
            font-weight: 500;
            padding: 8px 10px;
        }
        .table-tabs button.active {
            background-color: #007bff;
            color: white;
            border-color: #007bff;
        }
        
        .name-session-tabs {
            margin-bottom: 15px;
            border-bottom: 2px solid #dee2e6;
            padding-bottom: 5px;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }
        .name-session-tabs button {
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
            border-bottom: none;
            margin-bottom: -2px;
            padding: 8px 10px;
            font-size: 0.9em;
        }
        .name-session-tabs button.active {
            background-color: #007bff;
            color: white;
            border-color: #007bff #007bff #fff;
            font-weight: bold;
        }

        #summaryTable th {
            background-color: #ffc107;
            color: #212529;
        }
        #summaryTable td {
            background-color: #fff9e6;
        }
        .highlight-conflict {
            background-color: #f8d7da !important;
            font-weight: bold;
            color: #721c24 !important;
        }

        .modal {
            display: none;
            position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%;
            overflow: hidden;
            background-color: rgba(0,0,0,0.35); /* Made overlay more transparent */
            align-items: center; justify-content: center;
            pointer-events: none;
        }
        .modal-content {
            background-color: #fff;
            padding: 20px;
            border: 1px solid #ccc; width: 90%; max-width: 500px;
            border-radius: 10px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.3); position: relative;
            pointer-events: auto;
            max-height: 85vh;
            overflow-y: auto;
            box-sizing: border-box;
        }
        .modal-content.dragging { transform: none; }
        .modal-header {
            padding-bottom: 10px;
            border-bottom: 1px solid #e9ecef; margin-bottom: 15px;
            font-size: 1.2em;
        }
        .modal-close-btn {
            font-size: 1.6rem;
        }

        .name-item {
            padding: 8px 6px;
            display: flex; /* Added for better alignment of span and button */
            justify-content: space-between; /* Positions name and delete button */
            align-items: center; /* Vertically aligns items */
            border-bottom: 1px solid #eee; /* Optional: separator for items */
        }
        .name-item:last-child {
            border-bottom: none; /* Optional: remove border from last item */
        }
        .name-item span {
            cursor: pointer; /* Indicates the name is clickable */
            flex-grow: 1; /* Allows span to take available space */
        }
        .name-item span.highlighted { /* Style for the highlighted name */
            background-color: #007bff;
            color: white;
            font-weight: bold;
            padding: 3px 6px;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        .name-item button {
            padding: 5px 10px;
            font-size: 0.8em;
            background-color: #f8f9fa;
            border: 1px solid #ced4da;
            color: #dc3545; /* Red color for delete */
        }
        .name-item button:hover {
            background-color: #e9ecef;
            border-color: #adb5bd;
        }


        #newNameInput, #searchNameInput {
            padding: 8px;
            width: calc(100% - 90px); /* Adjusted width */
        }
         #searchNameInput {
            margin-bottom: 10px;
         }
        .input-group button, #importNameListBtn {
            padding: 8px 12px;
            font-size: 0.9em;
        }
        #nameList {
            margin-top:10px;
            max-height:200px; /* Adjusted max height */
            overflow-y: auto; /* Ensure scrollability if content exceeds max-height */
            /* column-count and column-gap are removed to ensure single column for better item interaction */
        }
        
        .custom-message-box {
            padding: 12px 20px;
            font-size: 0.9em;
            max-width: 90%;
        }

        /* Desktop and larger screen adjustments */
        @media (min-width: 768px) {
            body {
                padding: 20px;
                font-size: 16px;
            }
            .main-container {
                padding: 25px;
            }
            h2, h3 {
                font-size: 2em;
            }
            #scheduleTitle {
                font-size: 2.2em;
            }
            #userIdDisplay {
                font-size: 0.9em;
            }
            table {
                font-size: 1em;
            }
            #summaryTable {
                font-size: 0.95em;
            }
            th, td {
                padding: 12px 15px;
                min-width: 100px;
            }
            table th {
                white-space: nowrap;
                 padding: 12px 15px;
            }
            .bar {
                gap: 10px;
            }
            .bar button, .table-tabs button, .name-session-tabs button {
                padding: 10px 18px;
                font-size: 14px;
                gap: 8px;
            }
            #rowColManipulationBar button {
                 padding: 8px 14px;
            }
            .table-tabs button { padding: 10px 15px; }
            .name-session-tabs button { padding: 10px 15px; font-size: 1em; }
             .modal-content {
                padding: 25px;
                max-width: 650px;
                max-height: 90vh;
            }
            .modal-header { padding-bottom: 15px; margin-bottom: 20px; font-size: 1.3em; }
            .modal-close-btn { font-size: 1.8rem; }
            /* .name-item adjustments for desktop if needed, but current mobile is fine */
            #newNameInput, #searchNameInput { padding: 10px; width: calc(100% - 120px); }
            #searchNameInput { margin-bottom: 15px; }
            .input-group button, #importNameListBtn { padding: 10px 15px; font-size: 1em; }
            #nameList { margin-top:15px; max-height:250px; /* column-count: 2; removed for consistency */ }
            .custom-message-box { padding: 15px 25px; font-size: 1.05em; max-width: 400px; }
        }
        @media (min-width: 480px) and (max-width: 767px) {
            /* Specific tweaks for small tablets / large phones if needed */
            /* #nameList { column-count: 2; } removed for consistency */
            table th {
                 white-space: normal;
            }
        }

        .merged-cell-container { position: relative; z-index: 2; vertical-align: top; }
        .merged-cell-overlay {
            position: absolute;
            top: 0; left: 0; width: var(--merged-width); height: var(--merged-height);
            background-color: rgba(240, 248, 255, 0.95); font-style: italic; border: 1px solid #add8e6;
            display: flex; align-items: center;
            justify-content: center; overflow: hidden;
            box-sizing: border-box; z-index: 5;
        }
        .subsumed-cell { visibility: hidden; }

        #loadingIndicatorModal {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(255, 255, 255, 0.85);
            display: flex; align-items: center; justify-content: center;
            z-index: 10;
            border-radius: 10px;
        }
        .spinner {
            border: 5px solid rgba(0, 0, 0, 0.1);
            width: 40px; height: 40px;
            border-radius: 50%;
            border-left-color: #007bff;
            animation: spin 1s ease infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        input[type="file"][style*="display:none"],
        input[type="file"][style*="display: none"] {
            position: absolute;
            left: -9999px;
            width: 1px;
            height: 1px;
            opacity: 0;
        }

    </style>
</head>
<body>
<div class="main-container">
    <h2 contenteditable="true" id="scheduleTitle">Weekly Schedule</h2>
    <div id="userIdDisplay">User ID: Loading...</div>

    <div class="bar">
        <button id="directCopyFullHtmlBtn" title="Copy the entire page's HTML to clipboard">📋 Copy Full HTML (Direct)</button>
    </div>
    <div class="bar">
        <button id="excelBtnTrigger" title="Export the currently active table to an Excel file">💾 Export Active Table to Excel</button>
        <button id="importExcelBtn" title="Import data from an Excel file into a new table">📂 Import from Excel</button>
        <input type="file" id="fileInput" accept=".xlsx, .xls" style="display:none">
    </div>
    <div class="bar">
        <button id="saveDraftBtn" title="Save all current tables and their state as a named draft">💠 Save All as Draft</button>
        <button id="loadDraftBtn" title="Show list of saved drafts to load">📂 Load Draft</button>
        <button id="exportDraftsBtn" title="Export all saved drafts to a JSON file">📤 Export All Drafts</button>
        <button id="importDraftsBtn" title="Import drafts from a JSON file">📥 Import Drafts File</button>
        <input type="file" id="draftImportFile" accept=".json" style="display:none;">
        <button id="clearActiveTableContentBtn" title="Clear all data from the cells of the active table">🧹 Clear Active Table</button>
    </div>
    <div class="bar">
        <button id="selectBtn" title="Toggle cell selection mode on/off">✨ Select Cells</button>
        <button id="mergeBtn" title="Merge the currently selected cells">🔗 Merge Cells</button>
        <button id="deselectBtn" title="Clear current cell selection">🚫 Deselect All</button>
        <button id="unmergeBtn" title="Unmerge the cell that was last clicked if it's part of a merge">💔 Unmerge Cell</button>
    </div>
    <div class="bar">
        <button id="addTableBtn" title="Add a new, empty table/sheet">➕ Add New Table</button>
        <button id="renameTableBtn" title="Rename the currently active table/sheet">📝 Rename Active Table</button>
        <button id="deleteTableBtn" title="Delete the currently active table/sheet">❌ Delete Active Table</button>
        <button id="nameListBtn" title="Open a dialog to manage a list of names for quick insertion">👥 Manage Names (Firestore)</button>
    </div>

    <div id="draftList" style="display:none;"></div>
    <div class="bar table-tabs" id="tableTabs"></div>
    <div id="tablesContainer">
        <table id="tbl_1" class="active" data-table-name="Table 1">
            <thead>
                <tr>
                    <th contenteditable="true">Class</th>
                    <th contenteditable="true">08:00</th>
                    <th contenteditable="true">09:00</th>
                    <th contenteditable="true">10:00</th>
                    <th contenteditable="true">11:00</th>
                    <th contenteditable="true">12:00</th>
                    <th contenteditable="true">13:00</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td contenteditable="true">5S1</td>
                    <td contenteditable="true"></td><td contenteditable="true">JAMES</td><td contenteditable="true"></td>
                    <td contenteditable="true"></td><td contenteditable="true"></td><td contenteditable="true"></td>
                </tr>
                 <tr>
                    <td contenteditable="true">5S2</td>
                    <td contenteditable="true"></td><td contenteditable="true"></td><td contenteditable="true">LILY</td>
                    <td contenteditable="true"></td><td contenteditable="true"></td><td contenteditable="true"></td>
                </tr>
            </tbody>
        </table>
    </div>

    <div class="bar" id="rowColManipulationBar">
        <button id="addRowAboveBtn" title="Add a new row above the currently selected/clicked row">⬆️ Add Row Above</button>
        <button id="addRowBelowBtn" title="Add a new row below the currently selected/clicked row">⬇️ Add Row Below</button>
        <button id="addColLeftBtn" title="Add a new column to the left of the currently selected/clicked column">⬅️ Add Column Left</button>
        <button id="addColRightBtn" title="Add a new column to the right of the currently selected/clicked column">➡️ Add Column Right</button>
        <button id="deleteRowBtn" class="delete-btn" title="Delete the currently selected/clicked row">🗑️ Delete Row</button>
        <button id="deleteColBtn" class="delete-btn" title="Delete the currently selected/clicked column">🗑️ Delete Column</button>
    </div>

    <div id="nameModal" class="modal">
        <div class="modal-content" id="nameModalContent">
            <div class="modal-header" id="nameModalHeader">
                <h3 id="nameModalTitle">Name List Manager</h3>
                <button type="button" class="modal-close-btn" id="closeNameModalBtnStandard" title="Close name manager">×</button>
            </div>
            <div class="name-session-tabs">
                <button id="namePagiTab" data-session="pagi" class="active">Pagi (Morning)</button>
                <button id="namePetangTab" data-session="petang">Petang (Afternoon)</button>
            </div>
             <div class="input-group">
                <input id="newNameInput" placeholder="Add new name to current session">
                <button id="addNameBtnInModal" title="Add the name to the list">Add</button>
            </div>
            <button id="importNameListBtn" title="Import names from a .txt file (one name per line) to current session">📂 Import Names (.txt) to Session</button>
            <input type="file" id="nameListImportFile" accept=".txt" style="display:none;">
            <input type="text" id="searchNameInput" placeholder="🔍 Search names in current session..." title="Filter the list of names">
            <div id="nameList">
                </div>
            <div id="loadingIndicatorModal" style="display:none;"><div class="spinner"></div></div>
        </div>
    </div>

    <h3 style="margin-top:32px">Teacher/Subject Attendance Summary</h3>
    <table id="summaryTable">
        </table>
    <div id="customMessageBox" class="custom-message-box" style="display:none;"></div>
</div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, setDoc, onSnapshot, collection, addDoc, getDocs, deleteDoc, updateDoc, query, where } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js"; // Added more imports for potential future use

    // --- User Provided Firebase Config (Fallback) ---
    const userProvidedFirebaseConfig = {
      apiKey: "AIzaSyBgvyb95-jujtCC2HPiHXLdYMJgQquIEx4", // Example, replace if necessary
      authDomain: "jadual-3f0aa.firebaseapp.com",
      projectId: "jadual-3f0aa",
      storageBucket: "jadual-3f0aa.appspot.com", // Corrected typical storage bucket format
      messagingSenderId: "496526436851",
      appId: "1:496526436851:web:78ff48b28bfc8c31f14a86"
    };

    // --- Firebase Initialization ---
    const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : userProvidedFirebaseConfig;
    const appId = typeof __app_id !== 'undefined' ? __app_id : (firebaseConfig.appId || 'default-app-id-jadual'); // More specific default

    let fbApp, fbAuth, fbDb;
    let fbUserId = null;
    let fbIsAuthReady = false;
    let unsubscribePagi = null;
    let unsubscribePetang = null;

    try {
        fbApp = initializeApp(firebaseConfig);
        fbAuth = getAuth(fbApp);
        fbDb = getFirestore(fbApp);
        // setLogLevel('debug'); // Uncomment for Firebase Firestore detailed logging
    } catch (e) {
        console.error("CRITICAL Error initializing Firebase services:", e);
        const userIdDisplayInitError = document.getElementById('userIdDisplay');
        if (userIdDisplayInitError) userIdDisplayInitError.textContent = "User ID: Firebase Init Error!";
        const mb = document.getElementById('customMessageBox');
        if(mb) {
            mb.textContent = "Critical Error: Firebase initialization failed. Check console.";
            mb.className = 'custom-message-box error';
            mb.style.display = 'block';
        }
    }

    // --- Global Variables & Constants ---
    const DRAFTS_KEY = 'jadual_drafts_v4'; // Incremented version for safety
    const SCHEDULE_TITLE_KEY = 'jadual_title_v4'; // Incremented version
    let activeTableId = 'tbl_1';
    let tableCount = 1; // Used for generating unique table IDs
    let selectionMode = false;
    let selectedCells = [];
    let lastClickedCell = null;
    let selectedNameFromList = null; // Stores the name selected from the modal list
    let currentNameListSession = 'pagi'; // 'pagi' or 'petang'
    let namesPagi = []; // Array to store names for 'pagi' session from Firestore
    let namesPetang = []; // Array to store names for 'petang' session from Firestore
    let isDraggingModal = false;
    let modalDragOffsetX, modalDragOffsetY;

    // --- DOM Element Cache ---
    let scheduleTitleElement, tablesContainer, tableTabs, nameModal, nameModalContent, nameModalHeader, nameListContainer, newNameInput, draftListElement, summaryTableElement, customMessageBox, fileInputElement, directCopyFullHtmlButtonElement, closeNameModalButtonStandardElement, nameListImportFileInputElement, searchNameInputElement, draftImportFileInputElement, userIdDisplayElement, namePagiTabElement, namePetangTabElement, loadingIndicatorModalElement, nameModalTitleElement;

    // --- Utility Functions ---
    function showMessage(message, type = 'info', duration = 3000) {
        if (!customMessageBox) {
            customMessageBox = document.getElementById('customMessageBox');
            if (!customMessageBox) {
                console.warn("showMessage called but customMessageBox element not found. Message:", message);
                return;
            }
        }
        customMessageBox.textContent = message;
        customMessageBox.className = `custom-message-box ${type}`; // Ensure base class is always present
        customMessageBox.style.display = 'block';
        setTimeout(() => { if (customMessageBox) customMessageBox.style.display = 'none'; }, duration);
    }

    function customPrompt(message, defaultValue = "") {
        // Using window.prompt as a fallback; consider a custom modal for better UX if window.prompt is problematic in the environment.
        return prompt(message, defaultValue);
    }

    function customConfirm(message) {
        return new Promise((resolve) => {
            const confirmModalId = 'customConfirmModal';
            let existingModal = document.getElementById(confirmModalId);
            if (existingModal) existingModal.remove();

            const modal = document.createElement('div');
            modal.id = confirmModalId;
            modal.style.cssText = `display: flex; position: fixed; z-index: 2001; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); align-items: center; justify-content: center; padding: 10px; box-sizing: border-box;`;
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `background-color: #fff; padding: 20px 25px; border-radius: 8px; text-align: center; box-shadow: 0 5px 15px rgba(0,0,0,0.3); min-width: 280px; max-width: 90%; box-sizing: border-box;`;
            
            const messageP = document.createElement('p');
            messageP.textContent = message;
            messageP.style.marginBottom = '20px'; messageP.style.fontSize = '1.05em'; messageP.style.lineHeight = '1.4';

            const buttonContainer = document.createElement('div');
            buttonContainer.style.display = 'flex';
            buttonContainer.style.flexWrap = 'wrap'; // Allow buttons to wrap on small screens
            buttonContainer.style.justifyContent = 'center';
            buttonContainer.style.gap = '10px'; // Space between buttons

            const yesButton = document.createElement('button');
            yesButton.textContent = 'Yes';
            yesButton.style.cssText = `padding: 10px 18px; border-radius: 5px; cursor: pointer; background-color: #28a745; color: white; border: none; font-size: 0.95em;`;
            
            const noButton = document.createElement('button');
            noButton.textContent = 'No';
            noButton.style.cssText = `padding: 10px 18px; border-radius: 5px; cursor: pointer; background-color: #dc3545; color: white; border: none; font-size: 0.95em;`;

            const closeModal = (value) => { modal.remove(); resolve(value); };
            yesButton.onclick = () => closeModal(true);
            noButton.onclick = () => closeModal(false);

            buttonContainer.appendChild(yesButton);
            buttonContainer.appendChild(noButton);
            modalContent.appendChild(messageP);
            modalContent.appendChild(buttonContainer);
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
        });
    }
    
    function showNameModalLoading(isLoading) {
        if (loadingIndicatorModalElement) {
            loadingIndicatorModalElement.style.display = isLoading ? 'flex' : 'none';
        }
    }

    // --- Firestore Name List Functions ---
    async function saveNameListToFirestore(session, namesArray) {
        if (!fbDb || !fbUserId || !fbIsAuthReady) {
            showMessage("Firebase not ready. Cannot save name list.", "error"); return;
        }
        showNameModalLoading(true);
        const uniqueSortedNames = [...new Set(namesArray.map(n => n.trim()).filter(n => n))].sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));
        
        if (!appId || appId === 'default-app-id-jadual') { // Check against the more specific default
            showMessage("Configuration error: App ID is missing or default.", "error"); showNameModalLoading(false); return;
        }
        const docPath = `artifacts/${appId}/users/${fbUserId}/nameLists/${session}`;
        const docRef = doc(fbDb, docPath);
        try {
            await setDoc(docRef, { names: uniqueSortedNames });
            showMessage(`Name list for ${session} session updated in Firestore.`, "success");
        } catch (error) {
            console.error(`Failed to save list to ${session}. Path: ${docPath}`, error);
            showMessage(`Failed to save list to ${session}. Error: ${error.message}`, "error");
        } finally {
            showNameModalLoading(false);
        }
    }

    async function addNameToCurrentSessionInFirestore(name) {
        if (!fbDb || !fbUserId || !fbIsAuthReady) {
            showMessage("Firebase not ready. Cannot add name.", "error"); return;
        }
        const trimmedName = name.trim();
        if (!trimmedName) {
            showMessage("Name cannot be empty.", "info"); return;
        }
        showNameModalLoading(true);
        const sessionNames = currentNameListSession === 'pagi' ? namesPagi : namesPetang;
        if (sessionNames.map(n => n.toLowerCase()).includes(trimmedName.toLowerCase())) {
            showMessage(`Name "${trimmedName}" already exists in ${currentNameListSession} session.`, "info");
            showNameModalLoading(false); return;
        }
        const updatedNames = [...sessionNames, trimmedName]; // Firestore save will sort
        await saveNameListToFirestore(currentNameListSession, updatedNames); // Reuse save function
        if(newNameInput) { newNameInput.value = ''; newNameInput.focus(); }
        // renderNameListFromFirestore will be called by the onSnapshot listener
        showNameModalLoading(false); // saveNameListToFirestore handles its own loading
    }

    async function deleteNameFromCurrentSessionInFirestore(nameToDelete) {
        if (!fbDb || !fbUserId || !fbIsAuthReady) {
            showMessage("Firebase not ready. Cannot delete name.", "error"); return;
        }
        if (await customConfirm(`Are you sure you want to delete "${nameToDelete}" from the ${currentNameListSession} session list? This will also remove it from all schedule tables.`)) {
            showNameModalLoading(true);
            const currentNames = currentNameListSession === 'pagi' ? namesPagi : namesPetang;
            const updatedNames = currentNames.filter(name => name !== nameToDelete);
            await saveNameListToFirestore(currentNameListSession, updatedNames); // Reuse save function
            
            // Remove name from tables
            tablesContainer.querySelectorAll('table').forEach(table => {
                table.querySelectorAll('tbody td, tbody th, .merged-cell-overlay').forEach(cell => {
                    if (cell.textContent.trim() === nameToDelete) cell.textContent = '';
                });
            });
            rebuildAndRenderSummary();
            if (selectedNameFromList === nameToDelete) clearNameSelection(); // Clear selection if deleted name was selected
            // renderNameListFromFirestore will be called by the onSnapshot listener
            showNameModalLoading(false); // saveNameListToFirestore handles its own loading
        }
    }

    function listenToNameList(sessionToListen) {
        if (!fbDb || !fbUserId || !fbIsAuthReady) {
            console.warn(`Cannot listen to ${sessionToListen} names: Firebase not ready.`);
            return () => {}; // Return a dummy unsubscribe function
        }
        if (!appId || appId === 'default-app-id-jadual') {
             console.warn(`Cannot listen to ${sessionToListen} names: App ID missing or default.`);
            return () => {};
        }
        const docPath = `artifacts/${appId}/users/${fbUserId}/nameLists/${sessionToListen}`;
        const docRef = doc(fbDb, docPath);

        return onSnapshot(docRef, (docSnap) => {
            showNameModalLoading(true); // Show loading while processing
            if (docSnap.exists()) {
                const data = docSnap.data();
                const fetchedNames = data.names || [];
                if (sessionToListen === 'pagi') namesPagi = fetchedNames;
                else namesPetang = fetchedNames;
            } else {
                // Document doesn't exist, so list is empty
                if (sessionToListen === 'pagi') namesPagi = [];
                else namesPetang = [];
            }
            // Only render if the modal is open and showing the current session
            if (nameModal.style.display === 'flex' && sessionToListen === currentNameListSession) {
                renderNameListFromFirestore(searchNameInputElement ? searchNameInputElement.value : '');
            }
            rebuildAndRenderSummary(); // Update summary table as names might affect it
            showNameModalLoading(false);
        }, (error) => {
            console.error(`Error fetching ${sessionToListen} names. Path: ${docPath}`, error);
            showMessage(`Error fetching ${sessionToListen} names: ${error.message}. Check console.`, "error", 7000);
            showNameModalLoading(false);
        });
    }
    
    // --- DOMContentLoaded ---
    document.addEventListener('DOMContentLoaded', () => {
        // Cache DOM elements
        scheduleTitleElement = document.getElementById('scheduleTitle');
        tablesContainer = document.getElementById('tablesContainer');
        tableTabs = document.getElementById('tableTabs');
        nameModal = document.getElementById('nameModal');
        nameModalContent = document.getElementById('nameModalContent');
        nameModalHeader = document.getElementById('nameModalHeader');
        nameListContainer = document.getElementById('nameList');
        newNameInput = document.getElementById('newNameInput');
        draftListElement = document.getElementById('draftList');
        summaryTableElement = document.getElementById('summaryTable');
        customMessageBox = document.getElementById('customMessageBox');
        fileInputElement = document.getElementById('fileInput');
        directCopyFullHtmlButtonElement = document.getElementById('directCopyFullHtmlBtn');
        closeNameModalButtonStandardElement = document.getElementById('closeNameModalBtnStandard');
        nameListImportFileInputElement = document.getElementById('nameListImportFile');
        searchNameInputElement = document.getElementById('searchNameInput');
        draftImportFileInputElement = document.getElementById('draftImportFile');
        userIdDisplayElement = document.getElementById('userIdDisplay');
        namePagiTabElement = document.getElementById('namePagiTab');
        namePetangTabElement = document.getElementById('namePetangTab');
        loadingIndicatorModalElement = document.getElementById('loadingIndicatorModal');
        nameModalTitleElement = document.getElementById('nameModalTitle');

        if (!tablesContainer || !tableTabs || !nameModal || !summaryTableElement || !scheduleTitleElement) {
            document.body.innerHTML = "<p style='color:red; text-align:center; font-size:1.2em; padding:20px;'>Error: Critical page elements are missing. Application cannot start.</p>";
            console.error("Critical page elements missing. Application cannot start.");
            return;
        }

        // Firebase Auth State Change Listener
        if (fbAuth) {
            onAuthStateChanged(fbAuth, async (user) => {
                if (user) {
                    fbUserId = user.uid;
                    fbIsAuthReady = true;
                    if(userIdDisplayElement) userIdDisplayElement.textContent = `User ID: ${fbUserId}`; // Show full ID or part as preferred
                    
                    // Unsubscribe from previous listeners if any, then subscribe anew
                    if (unsubscribePagi) unsubscribePagi();
                    if (unsubscribePetang) unsubscribePetang();
                    unsubscribePagi = listenToNameList('pagi');
                    unsubscribePetang = listenToNameList('petang');

                    // If name modal is already open, refresh its list
                    if (nameModal.style.display === 'flex' && searchNameInputElement) {
                        renderNameListFromFirestore(searchNameInputElement.value);
                    }
                } else {
                    fbIsAuthReady = false;
                    fbUserId = null;
                    if(userIdDisplayElement) userIdDisplayElement.textContent = "User ID: Authenticating...";
                    try {
                        if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                            await signInWithCustomToken(fbAuth, __initial_auth_token);
                        } else {
                            await signInAnonymously(fbAuth); // Fallback to anonymous sign-in
                        }
                    } catch (error) {
                        console.error("Firebase Auth failed:", error);
                        showMessage(`Firebase Auth failed: ${error.message}`, "error", 7000);
                        if(userIdDisplayElement) userIdDisplayElement.textContent = `User ID: Auth Error`;
                    }
                }
            });
        } else {
             if(userIdDisplayElement) userIdDisplayElement.textContent = "User ID: Firebase Auth Service Error";
             showMessage("Critical Error: Firebase Auth service not initialized. Some features will not work.", "error", 10000);
        }

        loadScheduleTitle();
        initializeEventListeners();
        setupInitialTableState(); // Sets up or creates the first table
        rebuildAndRenderSummary();
        handleNameListSessionSwitch('pagi'); // Set initial session for name list
    });

    function setupInitialTableState() {
        const existingTables = tablesContainer.querySelectorAll('table');
        if (existingTables.length > 0) {
            tableTabs.innerHTML = ''; // Clear any existing tabs
            existingTables.forEach((table, index) => {
                const tableId = table.id || `tbl_init_${Date.now()}_${index + 1}`;
                table.id = tableId;
                const tableName = table.dataset.tableName || `Table ${index + 1}`;
                table.dataset.tableName = tableName;
                addTabButton(tableId, tableName);
                if (index === 0) activeTableId = tableId; // Set first table as active
            });
            tableCount = existingTables.length; // Update tableCount based on existing tables
        } else {
            // No tables exist, add a default one
            addNewTable(true); // true indicates it's an initial setup
        }
        // Ensure the active table is correctly displayed
        if (activeTableId && document.getElementById(activeTableId)) {
            switchTable(activeTableId);
        } else if (tablesContainer.querySelector('table')) {
            // Fallback if activeTableId is somehow invalid but tables exist
            switchTable(tablesContainer.querySelector('table').id);
        }
    }
    
    function loadScheduleTitle() {
        const savedTitle = localStorage.getItem(SCHEDULE_TITLE_KEY);
        if (savedTitle && scheduleTitleElement) scheduleTitleElement.textContent = savedTitle;
        if (scheduleTitleElement) {
            scheduleTitleElement.addEventListener('blur', () => {
                localStorage.setItem(SCHEDULE_TITLE_KEY, scheduleTitleElement.textContent);
                showMessage('Schedule title saved!', 'success');
            });
        }
    }

    // --- Event Listener Initialization ---
    function initializeEventListeners() {
        // General UI and File Operations
        if(directCopyFullHtmlButtonElement) directCopyFullHtmlButtonElement.addEventListener('click', attemptDirectCopyToClipboard);
        document.getElementById('excelBtnTrigger')?.addEventListener('click', exportActiveTableToExcel);
        document.getElementById('importExcelBtn')?.addEventListener('click', () => fileInputElement?.click());
        if(fileInputElement) fileInputElement.addEventListener('change', handleExcelFileImport);

        // Draft Management
        document.getElementById('saveDraftBtn')?.addEventListener('click', promptAndSaveDraft);
        document.getElementById('loadDraftBtn')?.addEventListener('click', toggleDraftListVisibility);
        document.getElementById('exportDraftsBtn')?.addEventListener('click', exportAllDrafts);
        document.getElementById('importDraftsBtn')?.addEventListener('click', () => draftImportFileInputElement?.click());
        if(draftImportFileInputElement) draftImportFileInputElement.addEventListener('change', handleDraftsFileImport);
        if(draftListElement) draftListElement.addEventListener('click', async (e) => {
            const targetSpan = e.target.closest('.draft-item span');
            const targetButton = e.target.closest('.draft-item button.delete-draft-btn'); // More specific selector
            if (targetSpan) loadSelectedDraft(targetSpan.textContent);
            else if (targetButton) await confirmAndDeleteDraft(targetButton.dataset.draftName);
        });

        // Table Content and Structure Manipulation
        document.getElementById('clearActiveTableContentBtn')?.addEventListener('click', confirmAndClearActiveTableContent);
        document.getElementById('selectBtn')?.addEventListener('click', toggleCellSelectionMode);
        document.getElementById('mergeBtn')?.addEventListener('click', mergeSelectedTableCells);
        document.getElementById('deselectBtn')?.addEventListener('click', deselectAllTableCells);
        document.getElementById('unmergeBtn')?.addEventListener('click', unmergeActiveCellIfMerged);
        document.getElementById('addTableBtn')?.addEventListener('click', () => addNewTable());
        document.getElementById('renameTableBtn')?.addEventListener('click', promptAndRenameActiveTable);
        document.getElementById('deleteTableBtn')?.addEventListener('click', confirmAndDeleteActiveTable);
        document.getElementById('addRowAboveBtn')?.addEventListener('click', addRowAboveToActiveTable);
        document.getElementById('addRowBelowBtn')?.addEventListener('click', addRowBelowToActiveTable);
        document.getElementById('addColLeftBtn')?.addEventListener('click', addColumnLeftToActiveTable);
        document.getElementById('addColRightBtn')?.addEventListener('click', addColumnRightToActiveTable);
        document.getElementById('deleteRowBtn')?.addEventListener('click', deleteClickedRowFromActiveTable);
        document.getElementById('deleteColBtn')?.addEventListener('click', deleteClickedColumnFromActiveTable);

        // Name List Modal
        document.getElementById('nameListBtn')?.addEventListener('click', toggleNameListModalVisibility);
        if(closeNameModalButtonStandardElement) closeNameModalButtonStandardElement.addEventListener('click', closeNameModal);
        if(nameModalHeader) {
            nameModalHeader.addEventListener('mousedown', startDragModal);
            nameModalHeader.addEventListener('touchstart', startDragModal, { passive: false });
        }
        document.addEventListener('mousemove', dragModal);
        document.addEventListener('mouseup', stopDragModal);
        document.addEventListener('touchmove', dragModal, { passive: false });
        document.addEventListener('touchend', stopDragModal);
        
        document.getElementById('addNameBtnInModal')?.addEventListener('click', () => {
            if(newNameInput) addNameToCurrentSessionInFirestore(newNameInput.value);
        });
        document.getElementById('importNameListBtn')?.addEventListener('click', () => nameListImportFileInputElement?.click());
        if(nameListImportFileInputElement) nameListImportFileInputElement.addEventListener('change', handleNameListImportFirestore);
        if(searchNameInputElement) searchNameInputElement.addEventListener('input', (e) => renderNameListFromFirestore(e.target.value));
        if(namePagiTabElement) namePagiTabElement.addEventListener('click', () => handleNameListSessionSwitch('pagi'));
        if(namePetangTabElement) namePetangTabElement.addEventListener('click', () => handleNameListSessionSwitch('petang'));
        
        // Event listener for clicking a name in the list to select it, or its delete button
        if(nameListContainer) nameListContainer.addEventListener('click', async (e) => {
            const nameItemSpan = e.target.closest('.name-item span[data-name]');
            const deleteButton = e.target.closest('.name-item button[data-name-delete]');
            if (nameItemSpan) {
                selectNameForCellInsertion(nameItemSpan.dataset.name);
            } else if (deleteButton) {
                await deleteNameFromCurrentSessionInFirestore(deleteButton.dataset.nameDelete);
            }
        });

        // Table cell interaction (click for selection/insertion, blur/input for summary update)
        if(tablesContainer) {
            tablesContainer.addEventListener('click', handleTableCellClick);
            // Use 'input' for immediate updates on contenteditable, 'blur' as a fallback
            tablesContainer.addEventListener('input', (e) => {
                 if ((e.target.tagName === 'TD' || e.target.tagName === 'TH' || e.target.classList.contains('merged-cell-overlay')) && e.target.isContentEditable) {
                    // Use a short timeout to allow DOM to update before rebuilding summary
                    setTimeout(rebuildAndRenderSummary, 50);
                }
            }, true);
        }
        window.addEventListener('resize', updateAllMergeOverlays);
    }

    // --- Modal Dragging Functions ---
    function startDragModal(e) {
        if (e.target.closest('.modal-close-btn') || e.target.closest('input') || e.target.closest('button') || e.target.closest('#nameList')) {
            isDraggingModal = false; return;
        }
        isDraggingModal = true;
        if(nameModalContent) nameModalContent.classList.add('dragging');
        const clientX = e.clientX || (e.touches && e.touches[0].clientX);
        const clientY = e.clientY || (e.touches && e.touches[0].clientY);
        const rect = nameModalContent.getBoundingClientRect();
        // Temporarily set position to fixed for dragging relative to viewport
        nameModalContent.style.position = 'fixed';
        nameModalContent.style.left = `${rect.left}px`;
        nameModalContent.style.top = `${rect.top}px`;
        nameModalContent.style.transform = 'none'; // Remove transform if any
        modalDragOffsetX = clientX - nameModalContent.offsetLeft;
        modalDragOffsetY = clientY - nameModalContent.offsetTop;
        if (e.type === 'touchstart') e.preventDefault();
    }

    function dragModal(e) {
        if (!isDraggingModal || !nameModalContent) return;
        const clientX = e.clientX || (e.touches && e.touches[0].clientX);
        const clientY = e.clientY || (e.touches && e.touches[0].clientY);
        let newLeft = clientX - modalDragOffsetX;
        let newTop = clientY - modalDragOffsetY;
        const modalRect = nameModalContent.getBoundingClientRect(); // Use current rect for boundary checks
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        // Boundary checks
        if (newLeft < 0) newLeft = 0;
        if (newTop < 0) newTop = 0;
        if (newLeft + modalRect.width > viewportWidth) newLeft = viewportWidth - modalRect.width;
        if (newTop + modalRect.height > viewportHeight) newTop = viewportHeight - modalRect.height;
        nameModalContent.style.left = `${newLeft}px`;
        nameModalContent.style.top = `${newTop}px`;
        if (e.type === 'touchmove') e.preventDefault();
    }

    function stopDragModal() {
        if (isDraggingModal && nameModalContent) {
            isDraggingModal = false;
            nameModalContent.classList.remove('dragging');
            // Optional: revert to relative positioning if that was the original state,
            // but for a modal that's always centered, fixed might be fine.
            // For this implementation, we'll leave it as fixed after dragging.
        }
    }

    // --- Clipboard and File Operations ---
    async function attemptDirectCopyToClipboard() {
        const fullHtml = document.documentElement.outerHTML;
        try {
            // Modern clipboard API (preferred)
            await navigator.clipboard.writeText(fullHtml);
            showMessage('Full HTML copied to clipboard!', 'success');
        } catch (err) {
            // Fallback for older browsers or if navigator.clipboard is not available/allowed
            const textarea = document.createElement('textarea');
            textarea.value = fullHtml;
            textarea.style.position = 'fixed'; // Prevent screen scroll
            textarea.style.left = '-9999px';
            document.body.appendChild(textarea);
            textarea.select();
            try {
                if (document.execCommand('copy')) {
                    showMessage('Full HTML copied! (fallback method)', 'success');
                } else {
                    showMessage('Copy to clipboard failed. Manual copy might be needed.', 'error', 5000);
                }
            } catch (execErr) {
                showMessage('Copy to clipboard failed. Manual copy might be needed.', 'error', 5000);
            }
            document.body.removeChild(textarea);
        }
    }
    
    function handleExcelFileImport(event) {
        const file = event.target.files[0];
        if (!file || !tablesContainer) {
            showMessage('No file selected or table container missing.', 'info');
            return;
        }
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const workbook = XLSX.read(new Uint8Array(e.target.result), { type: 'array' });
                const sheetName = workbook.SheetNames[0]; // Import only the first sheet
                const worksheet = workbook.Sheets[sheetName];
                // Convert sheet to HTML table string. {raw: false} attempts to format values.
                const htmlTableString = XLSX.utils.sheet_to_html(worksheet, { raw: false, editable: true });
                
                tableCount++; // Ensure unique ID for the new table
                const newTableId = `tbl_imported_${Date.now()}_${tableCount}`;
                const importedTableName = file.name.replace(/\.xlsx?$/i, '') || `Imported Sheet ${tableCount}`;

                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = htmlTableString;
                const importedTableElement = tempDiv.querySelector('table');

                if (importedTableElement) {
                    importedTableElement.id = newTableId;
                    importedTableElement.dataset.tableName = importedTableName;
                    // Make all cells contenteditable
                    importedTableElement.querySelectorAll('td, th').forEach(cell => {
                        cell.contentEditable = 'true';
                    });
                    tablesContainer.appendChild(importedTableElement);
                    addTabButton(newTableId, importedTableName);
                    switchTable(newTableId); // Make the new table active
                    showMessage('Excel data imported successfully!', 'success');
                } else {
                    showMessage('Could not parse a valid table from the Excel file.', 'error');
                }
            } catch (error) {
                console.error("Error processing Excel file:", error);
                showMessage(`Error processing Excel file: ${error.message}`, 'error');
            } finally {
                if(event.target) event.target.value = ''; // Reset file input
            }
        };
        reader.onerror = () => {
            showMessage('Failed to read the Excel file.', 'error');
            if(event.target) event.target.value = ''; // Reset file input
        };
        reader.readAsArrayBuffer(file);
    }

    function exportActiveTableToExcel() {
        const tableToExport = document.getElementById(activeTableId);
        if (!tableToExport) {
            showMessage('No active table to export.', 'error'); return;
        }

        // Temporarily replace merged cell overlays with their text content for export
        const overlaysData = [];
        tableToExport.querySelectorAll('.merged-cell-overlay').forEach(overlay => {
            const parentCell = overlay.parentElement;
            if (parentCell) {
                overlaysData.push({ parent: parentCell, originalParentHTML: parentCell.innerHTML, text: overlay.textContent });
                parentCell.textContent = overlay.textContent; // Replace content for export
            }
        });

        const tableName = tableToExport.dataset.tableName || activeTableId;
        try {
            const wb = XLSX.utils.table_to_book(tableToExport, { sheet: tableName });
            XLSX.writeFile(wb, `${tableName}_${new Date().toISOString().split('T')[0]}.xlsx`);
            showMessage(`Table "${tableName}" exported to Excel.`, 'success');
        } catch (error) {
            console.error("Error exporting to Excel:", error);
            showMessage(`Failed to export table "${tableName}": ${error.message}`, 'error');
        }


        // Restore merged cell overlays
        overlaysData.forEach(data => {
            if (data.parent) {
                data.parent.innerHTML = data.originalParentHTML;
                // Re-attach event listener if necessary, though blur on contenteditable overlay should still work
                const newOverlay = data.parent.querySelector('.merged-cell-overlay');
                if (newOverlay) {
                    newOverlay.addEventListener('blur', () => { rebuildAndRenderSummary(); });
                }
            }
        });
        if(overlaysData.length > 0) updateAllMergeOverlays(); // Ensure overlays are correctly sized after restoration
    }

    // --- Draft Management ---
    function promptAndSaveDraft() {
        if (!tablesContainer || tablesContainer.children.length === 0) {
            showMessage('No schedule data to save as draft.', 'info'); return;
        }
        const defaultDraftName = `Draft ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`;
        const draftName = customPrompt('Enter draft name:', defaultDraftName);

        if (draftName && draftName.trim() !== "") {
            const allTablesData = tablesContainer.innerHTML; // Save the HTML structure
            const allTableMeta = {};
            tablesContainer.querySelectorAll('table').forEach(table => {
                allTableMeta[table.id] = { name: table.dataset.tableName || table.id };
            });

            const drafts = JSON.parse(localStorage.getItem(DRAFTS_KEY) || '{}');
            drafts[draftName.trim()] = { html: allTablesData, meta: allTableMeta, active: activeTableId, timestamp: Date.now() };
            localStorage.setItem(DRAFTS_KEY, JSON.stringify(drafts));
            showMessage(`Draft "${draftName.trim()}" saved!`, 'success');
            if (draftListElement && draftListElement.style.display === 'block') renderDraftList(); // Refresh if visible
        } else if (draftName !== null) { // User entered empty string or only spaces
            showMessage('Draft name cannot be empty.', 'error');
        }
    }

    function toggleDraftListVisibility() {
        if (!draftListElement) return;
        const isVisible = draftListElement.style.display === 'block';
        draftListElement.style.display = isVisible ? 'none' : 'block';
        if (!isVisible) renderDraftList(); // Render only when showing
    }

    function renderDraftList() {
        if (!draftListElement) return;
        draftListElement.innerHTML = ''; // Clear previous list
        const drafts = JSON.parse(localStorage.getItem(DRAFTS_KEY) || '{}');
        const draftNames = Object.keys(drafts).sort((a, b) => (drafts[b].timestamp || 0) - (drafts[a].timestamp || 0)); // Sort by timestamp, newest first

        if (draftNames.length === 0) {
            draftListElement.innerHTML = '<p style="text-align:center; padding:10px;">No drafts saved yet.</p>';
            return;
        }
        draftNames.forEach(name => {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'draft-item'; // Add class for styling if needed
            itemDiv.style.cssText = `display: flex; justify-content: space-between; align-items: center; padding: 8px; border-bottom: 1px solid #eee;`;
            
            const nameSpan = document.createElement('span');
            nameSpan.textContent = name;
            nameSpan.style.cursor = 'pointer';
            nameSpan.title = `Load draft: ${name}`;
            
            const deleteBtn = document.createElement('button');
            deleteBtn.textContent = 'Delete';
            deleteBtn.className = 'delete-draft-btn'; // For specific event handling
            deleteBtn.dataset.draftName = name; // Store name for deletion
            deleteBtn.title = `Delete draft '${name}'`;
            deleteBtn.style.cssText = `padding: 5px 10px; font-size: 0.8em; background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; border-radius: 4px; cursor: pointer;`;

            itemDiv.appendChild(nameSpan);
            itemDiv.appendChild(deleteBtn);
            draftListElement.appendChild(itemDiv);
        });
    }

    function loadSelectedDraft(draftName) {
        if (!tablesContainer || !tableTabs) {
            showMessage("Cannot load draft: critical elements missing.", "error"); return;
        }
        const drafts = JSON.parse(localStorage.getItem(DRAFTS_KEY) || '{}');
        if (drafts[draftName]) {
            tablesContainer.innerHTML = drafts[draftName].html;
            const tableMeta = drafts[draftName].meta || {};
            tableTabs.innerHTML = ''; // Clear existing tabs

            let foundActiveTable = false;
            tablesContainer.querySelectorAll('table').forEach(table => {
                const id = table.id;
                const metaInfo = tableMeta[id] || {};
                const name = metaInfo.name || `Table ${tableTabs.children.length + 1}`;
                table.dataset.tableName = name;
                addTabButton(id, name);
                // Ensure all cells are contenteditable after loading
                table.querySelectorAll('td, th').forEach(cell => cell.contentEditable = 'true');
                // Re-attach event listeners for merged cell overlays if any
                table.querySelectorAll('.merged-cell-overlay').forEach(overlay => {
                    overlay.contentEditable = 'true'; // Ensure overlay is editable
                    overlay.addEventListener('blur', () => { rebuildAndRenderSummary(); });
                });
                if (id === drafts[draftName].active) foundActiveTable = true;
            });

            activeTableId = drafts[draftName].active;
            if (!foundActiveTable || !document.getElementById(activeTableId)) {
                // If saved active table doesn't exist, activate the first one found
                activeTableId = tablesContainer.querySelector('table')?.id || null;
            }

            if (activeTableId) {
                switchTable(activeTableId);
            } else {
                // No tables loaded (empty draft or error), add a new default one
                addNewTable(true);
            }

            showMessage(`Draft "${draftName}" loaded successfully!`, 'success');
            if (draftListElement) draftListElement.style.display = 'none'; // Hide list after loading
            rebuildAndRenderSummary();
            updateAllMergeOverlays(); // Crucial after loading HTML with merges
        } else {
            showMessage(`Draft "${draftName}" not found. It might have been deleted or corrupted.`, 'error');
        }
    }

    async function confirmAndDeleteDraft(draftName) {
        if (await customConfirm(`Are you sure you want to permanently delete the draft "${draftName}"?`)) {
            const drafts = JSON.parse(localStorage.getItem(DRAFTS_KEY) || '{}');
            delete drafts[draftName];
            localStorage.setItem(DRAFTS_KEY, JSON.stringify(drafts));
            showMessage(`Draft "${draftName}" has been deleted.`, 'success');
            renderDraftList(); // Refresh the list
        }
    }
    
    function exportAllDrafts() {
        const drafts = localStorage.getItem(DRAFTS_KEY);
        if (!drafts || drafts === '{}') {
            showMessage('No drafts available to export.', 'info'); return;
        }
        try {
            const blob = new Blob([drafts], { type: 'application/json;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `all_schedule_drafts_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showMessage('All drafts exported successfully!', 'success');
        } catch (error) {
            console.error("Error exporting drafts:", error);
            showMessage(`Failed to export drafts: ${error.message}`, 'error');
        }
    }

    async function handleDraftsFileImport(event) {
        const file = event.target.files[0];
        if (!file) { showMessage('No file selected for draft import.', 'info'); return; }
        if (file.type !== 'application/json') {
            showMessage('Invalid file type. Please select a .json file for drafts.', 'error');
            if(event.target) event.target.value = ''; return;
        }
        const reader = new FileReader();
        reader.onload = async (e) => {
            try {
                const importedDraftsText = e.target.result;
                const importedDraftsData = JSON.parse(importedDraftsText);
                if (typeof importedDraftsData !== 'object' || importedDraftsData === null) {
                    showMessage('Invalid draft file format. Not a valid JSON object.', 'error'); return;
                }
                let localDrafts = JSON.parse(localStorage.getItem(DRAFTS_KEY) || '{}');
                let importedCount = 0, overwrittenCount = 0, skippedCount = 0;

                for (const draftName in importedDraftsData) {
                    if (Object.prototype.hasOwnProperty.call(importedDraftsData, draftName)) {
                        const draftData = importedDraftsData[draftName];
                        // Basic validation of draft structure
                        if (draftData && typeof draftData.html === 'string' && typeof draftData.meta === 'object' && typeof draftData.active === 'string') {
                            if (localDrafts[draftName]) {
                                if (await customConfirm(`Draft "${draftName}" already exists. Overwrite with imported version?`)) {
                                    localDrafts[draftName] = draftData; overwrittenCount++;
                                } else { skippedCount++; }
                            } else {
                                localDrafts[draftName] = draftData; importedCount++;
                            }
                        } else {
                            console.warn(`Skipping invalid draft data for: ${draftName}`);
                            skippedCount++;
                        }
                    }
                }
                localStorage.setItem(DRAFTS_KEY, JSON.stringify(localDrafts));
                showMessage(`Drafts import complete: ${importedCount} new, ${overwrittenCount} overwritten, ${skippedCount} skipped.`, 'success', 6000);
                if (draftListElement && (draftListElement.style.display === 'block' || importedCount > 0 || overwrittenCount > 0)) {
                    renderDraftList(); // Refresh list if it was open or if changes were made
                }
            } catch (error) {
                console.error("Error processing draft file:", error);
                showMessage(`Error processing draft file: ${error.message}`, 'error', 5000);
            }
            finally { if(event.target) event.target.value = ''; } // Reset file input
        };
        reader.onerror = () => {
            showMessage('Failed to read the selected draft file.', 'error');
            if(event.target) event.target.value = '';
        };
        reader.readAsText(file);
    }

    // --- Table Management (Tabs, Add, Rename, Delete) ---
    function addTabButton(id, label) {
        if (!tableTabs) return null;
        const button = document.createElement('button');
        button.textContent = label;
        button.dataset.tableId = id; // Store ID for easy access
        button.title = `Switch to table: ${label}`;
        button.onclick = () => switchTable(id);
        tableTabs.appendChild(button);
        return button;
    }

    function switchTable(id) {
        const targetTable = document.getElementById(id);
        if (!targetTable && tablesContainer) {
            const firstTableInDOM = tablesContainer.querySelector('table');
            if (firstTableInDOM) {
                id = firstTableInDOM.id; // Fallback to first available table
            } else {
                // No tables exist at all, potentially after deleting the last one
                if (tablesContainer && tablesContainer.children.length === 0) {
                    addNewTable(true); // Add a new default table
                    return; // addNewTable will handle switching
                }
                showMessage("Error: Target table not found and no fallback available.", "error");
                return;
            }
        }
        activeTableId = id;
        if(tablesContainer) tablesContainer.querySelectorAll('table').forEach(t => t.classList.toggle('active', t.id === id));
        if(tableTabs) tableTabs.querySelectorAll('button').forEach(b => b.classList.toggle('active', b.dataset.tableId === id));
        
        deselectAllTableCells(); // Clear selection from previous table
        rebuildAndRenderSummary();
        updateAllMergeOverlays(); // Ensure merges are correctly displayed for the new active table
    }

    function addNewTable(isInitial = false) {
        if (!tablesContainer || !tableTabs) return;
        tableCount++; // Increment for unique IDs, even if some tables were deleted
        const defaultTableName = `Schedule ${tableTabs.children.length + 1}`; // Name based on current tab count
        const label = isInitial ? defaultTableName : customPrompt('Enter new table name:', defaultTableName);

        if (!label && !isInitial) { // User cancelled prompt and it's not initial setup
            showMessage('Table creation cancelled.', 'info');
            return;
        }
        const finalTableName = (label || defaultTableName).trim();
        if (!finalTableName && !isInitial) {
            showMessage('Table name cannot be empty.', 'error');
            return;
        }

        const newTable = document.createElement('table');
        const newTableId = `tbl_${Date.now()}_${tableCount}`; // More robust unique ID
        newTable.id = newTableId;
        newTable.dataset.tableName = finalTableName;

        const thead = newTable.createTHead();
        const headerRow = thead.insertRow();
        const defaultHeaders = ['Class/Time', '08:00-09:00', '09:00-10:00', '10:00-11:00', '11:00-12:00', '12:00-13:00'];
        defaultHeaders.forEach(headerText => {
            const th = document.createElement('th');
            th.contentEditable = 'true';
            th.textContent = headerText;
            headerRow.appendChild(th);
        });

        const tbody = newTable.createTBody();
        for (let r = 0; r < 2; r++) { // Add a couple of sample rows
            const dataRow = tbody.insertRow();
            for (let c = 0; c < headerRow.cells.length; c++) {
                const td = dataRow.insertCell();
                td.contentEditable = 'true';
                if (c === 0) td.textContent = `Sample Row ${String.fromCharCode(65 + r)}`;
            }
        }
        tablesContainer.appendChild(newTable);
        addTabButton(newTableId, finalTableName);
        switchTable(newTableId); // Make the new table active

        if (!isInitial) showMessage(`Table "${finalTableName}" added successfully.`, 'success');
    }

    async function promptAndRenameActiveTable() {
        if (!tableTabs) return;
        const currentTab = tableTabs.querySelector('button.active');
        if (!currentTab) { showMessage('No active table selected to rename.', 'error'); return; }

        let tableIdToRename = currentTab.dataset.tableId;
        if (!tableIdToRename) { // Fallback if dataset.tableId is missing (should not happen with addTabButton)
            const onclickAttr = currentTab.getAttribute('onclick');
            const match = onclickAttr ? onclickAttr.match(/'(tbl_.*?)'/) : null;
            if (match && match[1]) tableIdToRename = match[1];
            else { showMessage('Could not identify the active table ID.', 'error'); return; }
        }

        const tableElement = document.getElementById(tableIdToRename);
        if (!tableElement) { showMessage(`Table element for ID "${tableIdToRename}" not found.`, 'error'); return; }

        const oldName = tableElement.dataset.tableName || currentTab.textContent;
        const newName = customPrompt('Enter new table name:', oldName);

        if (newName && newName.trim() !== "" && newName.trim() !== oldName) {
            const trimmedNewName = newName.trim();
            currentTab.textContent = trimmedNewName;
            currentTab.title = `Switch to table: ${trimmedNewName}`; // Update tooltip
            tableElement.dataset.tableName = trimmedNewName;
            showMessage(`Table renamed to "${trimmedNewName}".`, 'success');
            rebuildAndRenderSummary(); // In case table name is used in summary or elsewhere
        } else if (newName && newName.trim() === oldName) {
            showMessage('Table name unchanged.', 'info');
        } else if (newName === null) { // User cancelled the prompt
            showMessage('Rename operation cancelled.', 'info');
        } else { // User entered an empty name
            showMessage('Table name cannot be empty.', 'error');
        }
    }

    async function confirmAndDeleteActiveTable() {
        if (!tablesContainer || !tableTabs || tablesContainer.children.length <= 1) {
            showMessage('Cannot delete the last remaining table.', 'error'); return;
        }
        const activeTab = tableTabs.querySelector('button.active');
        const tableIdToDelete = activeTab ? activeTab.dataset.tableId : null;
        const tableElement = tableIdToDelete ? document.getElementById(tableIdToDelete) : null;
        const tableName = tableElement ? (tableElement.dataset.tableName || `Table ID: ${tableIdToDelete}`) : (activeTab ? activeTab.textContent : 'the active table');

        if (await customConfirm(`Are you sure you want to delete the table "${tableName}"? This action cannot be undone.`)) {
            if (tableElement) tableElement.remove();
            else if (document.getElementById(activeTableId)) { // Fallback if tableElement wasn't found via activeTab
                document.getElementById(activeTableId).remove();
            }
            activeTab?.remove(); // Remove the tab button

            // Switch to the first remaining tab or add a new one if all are deleted (should be prevented by length check)
            const firstRemainingTab = tableTabs.querySelector('button');
            if (firstRemainingTab) {
                const nextActiveId = firstRemainingTab.dataset.tableId ||
                                     (firstRemainingTab.getAttribute('onclick')?.match(/'(tbl_.*?)'/)?.[1]);
                if (nextActiveId) switchTable(nextActiveId);
                else addNewTable(true); // Should not happen if tabs are managed correctly
            } else {
                // This case should ideally be prevented by the initial check (tablesContainer.children.length <= 1)
                activeTableId = null;
                addNewTable(true); // Add a new default table if somehow all were deleted
            }
            showMessage(`Table "${tableName}" deleted successfully.`, 'success');
        }
    }

    // --- Row and Column Manipulation ---
    function addRowToTable(tableBody, rowIndex, numCols) {
        const row = tableBody.insertRow(rowIndex); // rowIndex -1 appends
        for (let i = 0; i < numCols; i++) {
            const cell = row.insertCell();
            cell.contentEditable = 'true';
            if (i === 0 && numCols > 1) cell.textContent = "New Row"; // Placeholder for first cell
        }
        return row;
    }

    function addRowAboveToActiveTable() {
        const table = document.getElementById(activeTableId);
        if (!table || !table.tBodies[0] || table.rows.length === 0) {
            showMessage("No active table or table is empty.", "info"); return;
        }
        const numCols = table.rows[0].cells.length; // Get col count from header or first row
        let insertAtIndex = 0; // Default to top of tbody
        if (lastClickedCell && lastClickedCell.closest('tbody') && lastClickedCell.parentElement.rowIndex >= 0) {
            // rowIndex for <tr> within <tbody> is 0-indexed relative to tbody
            insertAtIndex = lastClickedCell.parentElement.rowIndex;
        }
        addRowToTable(table.tBodies[0], insertAtIndex, numCols);
        rebuildAndRenderSummary(); updateAllMergeOverlays();
    }

    function addRowBelowToActiveTable() {
        const table = document.getElementById(activeTableId);
        if (!table || !table.tBodies[0] || table.rows.length === 0) {
            showMessage("No active table or table is empty.", "info"); return;
        }
        const numCols = table.rows[0].cells.length;
        let insertAtIndex = table.tBodies[0].rows.length; // Default to end of tbody
        if (lastClickedCell && lastClickedCell.closest('tbody') && lastClickedCell.parentElement.rowIndex >= 0) {
            insertAtIndex = lastClickedCell.parentElement.rowIndex + 1;
        }
        addRowToTable(table.tBodies[0], insertAtIndex, numCols);
        rebuildAndRenderSummary(); updateAllMergeOverlays();
    }

    function addColumnToTable(table, colIndex) { // colIndex -1 appends
        for (const row of table.rows) {
            const isHeaderRow = row.parentElement.tagName === 'THEAD';
            const cell = isHeaderRow ? document.createElement('th') : row.insertCell(colIndex === -1 ? row.cells.length : colIndex);
            cell.contentEditable = 'true';
            if (isHeaderRow) {
                cell.textContent = "New Header";
                // If inserting into THEAD and not appending, need to handle insertion carefully
                if (colIndex !== -1 && row.cells[colIndex] && isHeaderRow) {
                     row.insertBefore(cell, row.cells[colIndex]);
                } else if (isHeaderRow) { // Appending to header or only one cell exists
                     row.appendChild(cell);
                }
            }
        }
    }

    function addColumnLeftToActiveTable() {
        const table = document.getElementById(activeTableId);
        if (!table) { showMessage("No active table.", "info"); return; }
        let insertAtIndex = 0; // Default to far left
        if (lastClickedCell && lastClickedCell.cellIndex >= 0) {
            insertAtIndex = lastClickedCell.cellIndex;
        }
        addColumnToTable(table, insertAtIndex);
        rebuildAndRenderSummary(); updateAllMergeOverlays();
    }

    function addColumnRightToActiveTable() {
        const table = document.getElementById(activeTableId);
        if (!table) { showMessage("No active table.", "info"); return; }
        let insertAtIndex = -1; // Default to append (far right)
        if (lastClickedCell && lastClickedCell.cellIndex >= 0) {
            insertAtIndex = lastClickedCell.cellIndex + 1;
        }
        addColumnToTable(table, insertAtIndex);
        rebuildAndRenderSummary(); updateAllMergeOverlays();
    }

    async function deleteClickedRowFromActiveTable() {
        if (!lastClickedCell) { showMessage('Please click a cell in the row you wish to delete.', 'info'); return; }
        const table = document.getElementById(activeTableId);
        if (!table || !table.tBodies[0]) { showMessage('No active table or table body found.', 'error'); return; }
        
        const rowToDelete = lastClickedCell.closest('tr');
        if (!rowToDelete || !rowToDelete.parentElement || rowToDelete.parentElement.tagName !== 'TBODY') {
            showMessage('Cannot delete header row. Please click a cell in a data row.', 'error'); return;
        }
        if (table.tBodies[0].rows.length <= 1) {
            showMessage('Cannot delete the last data row in the table.', 'error'); return;
        }
        if (await customConfirm('Are you sure you want to delete this entire row?')) {
            rowToDelete.remove();
            lastClickedCell = null; // Clear last clicked cell as it's now gone
            deselectAllTableCells(); // Clear any selections
            rebuildAndRenderSummary();
            updateAllMergeOverlays();
            showMessage('Row deleted successfully.', 'success');
        }
    }

    async function deleteClickedColumnFromActiveTable() {
        if (!lastClickedCell) { showMessage('Please click a cell in the column you wish to delete.', 'info'); return; }
        const table = document.getElementById(activeTableId);
        if (!table) { showMessage('No active table found.', 'error'); return; }
        if (table.rows[0] && table.rows[0].cells.length <= 1) {
            showMessage('Cannot delete the last column in the table.', 'error'); return;
        }
        const colIndexToDelete = lastClickedCell.cellIndex;
        if (await customConfirm('Are you sure you want to delete this entire column?')) {
            for (const row of table.rows) {
                if (row.cells[colIndexToDelete]) row.cells[colIndexToDelete].remove();
            }
            lastClickedCell = null; // Clear last clicked cell
            deselectAllTableCells();
            rebuildAndRenderSummary();
            updateAllMergeOverlays();
            showMessage('Column deleted successfully.', 'success');
        }
    }
    
    async function confirmAndClearActiveTableContent() {
        const activeTableElement = document.getElementById(activeTableId);
        if (!activeTableElement) { showMessage('No active table to clear.', 'error'); return; }
        const tableName = activeTableElement.dataset.tableName || `Table ${activeTableId.split('_').pop()}`;
        if (await customConfirm(`Are you sure you want to clear all content and unmerge all cells in "${tableName}"? This will not delete saved drafts.`)) {
            // Unmerge all cells in the active table first
            activeTableElement.querySelectorAll('.merged-cell-container').forEach(containerCell => {
                const mergeId = containerCell.dataset.mergeId;
                if(mergeId){
                    const cellsInGroup = activeTableElement.querySelectorAll(`[data-merge-id="${mergeId}"]`);
                    cellsInGroup.forEach(c => {
                        c.removeAttribute('data-merge-id');
                        c.classList.remove('merged-cell-container', 'subsumed-cell');
                        const overlay = c.querySelector('.merged-cell-overlay');
                        if (overlay) c.textContent = overlay.textContent; // Keep text from overlay if desired, or set to ''
                        else c.innerHTML = ''; // Clear content
                        const overlayChild = c.querySelector('.merged-cell-overlay');
                        if(overlayChild) overlayChild.remove();
                        c.style.visibility = 'visible'; // Ensure subsumed cells are visible again
                    });
                }
            });
            // Clear content from all data cells (tbody td and tbody th if used for row headers)
            activeTableElement.querySelectorAll('tbody td, tbody th').forEach(cell => {
                cell.innerHTML = ''; // Clears content
                cell.classList.remove('selected'); // Remove selection styling
            });
            selectedCells = []; // Clear the selection array
            rebuildAndRenderSummary();
            updateAllMergeOverlays(); // Recalculate any remaining (should be none after this) or newly formed structures
            showMessage(`All content and merges in table "${tableName}" have been cleared.`, 'success');
        }
    }


    // --- Cell Selection and Merging ---
    function toggleCellSelectionMode() {
        selectionMode = !selectionMode;
        const btn = document.getElementById('selectBtn');
        if(btn) {
            btn.classList.toggle('active', selectionMode);
            btn.textContent = selectionMode ? '✨ Selecting... (Click cells)' : '✨ Select Cells';
        }
        if (!selectionMode) {
            deselectAllTableCells(); // Clear selection when turning off mode
        }
        showMessage(selectionMode ? 'Cell selection mode ON. Click cells to select.' : 'Cell selection mode OFF.', 'info', 2000);
    }

    function handleTableCellClick(event) {
        const cell = event.target.closest('td, th');
        if (!cell || !cell.closest(`#${activeTableId}`)) return; // Clicked outside active table or not on a cell

        lastClickedCell = cell; // Always update last clicked cell

        if (selectedNameFromList) {
            // Attempting to insert a name
            if (cell.isContentEditable || cell.querySelector('.merged-cell-overlay')?.isContentEditable) { // Check if cell or its overlay is editable
                const overlay = cell.querySelector('.merged-cell-overlay');
                if (overlay) {
                    overlay.textContent = selectedNameFromList;
                } else {
                    cell.textContent = selectedNameFromList;
                }
                rebuildAndRenderSummary();
                showMessage(`Inserted "${selectedNameFromList}" into cell.`, 'success', 2500);
                clearNameSelection(); // Clears highlight from list and resets cursor
            } else {
                showMessage('Cannot insert name: Click an editable data cell.', 'info');
            }
            return; // Exit after attempting name insertion
        }

        if (selectionMode) {
            // Handling cell selection for merging
            if (cell.classList.contains('subsumed-cell') ||
                (cell.classList.contains('merged-cell-container') && selectedCells.some(sc => sc !== cell && sc.dataset.mergeId !== cell.dataset.mergeId))) {
                showMessage('Cannot select: Cell is part of a different merge or is hidden by a merge. Unmerge first if needed.', 'warning', 4000);
                return;
            }
            cell.classList.toggle('selected');
            if (cell.classList.contains('selected')) {
                selectedCells.push(cell);
            } else {
                selectedCells = selectedCells.filter(c => c !== cell);
            }
        }
    }

    function deselectAllTableCells() {
        selectedCells.forEach(c => c.classList.remove('selected'));
        selectedCells = [];
    }

    function mergeSelectedTableCells() {
        if (selectedCells.length < 2) {
            showMessage('Please select at least two cells to merge.', 'error'); return;
        }
        if (selectedCells.some(cell => cell.dataset.mergeId)) {
            showMessage('Cannot merge: One or more selected cells are already part of a merge. Please unmerge them first.', 'warning', 4000);
            return;
        }

        // Determine the primary cell (top-leftmost)
        let primaryCell = selectedCells[0];
        let minRowGUI = primaryCell.parentElement.getBoundingClientRect().top;
        let minColGUI = primaryCell.getBoundingClientRect().left;
        selectedCells.forEach(cell => {
            const cellRowRect = cell.parentElement.getBoundingClientRect();
            const cellRect = cell.getBoundingClientRect();
            if (cellRowRect.top < minRowGUI || (cellRowRect.top === minRowGUI && cellRect.left < minColGUI)) {
                primaryCell = cell;
                minRowGUI = cellRowRect.top;
                minColGUI = cellRect.left;
            }
        });

        // Calculate total width and height of the merged area
        let minLeft = Infinity, maxRight = -Infinity, minTop = Infinity, maxBottom = -Infinity;
        selectedCells.forEach(cell => {
            const rect = cell.getBoundingClientRect();
            minLeft = Math.min(minLeft, rect.left);
            maxRight = Math.max(maxRight, rect.right);
            minTop = Math.min(minTop, rect.top);
            maxBottom = Math.max(maxBottom, rect.bottom);
        });
        const totalWidth = maxRight - minLeft;
        const totalHeight = maxBottom - minTop;

        const mergeId = `merge-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const overlay = document.createElement('div');
        overlay.className = 'merged-cell-overlay';
        overlay.textContent = primaryCell.textContent; // Use primary cell's content
        overlay.contentEditable = 'true'; // Make overlay editable
        overlay.style.setProperty('--merged-width', `${totalWidth}px`);
        overlay.style.setProperty('--merged-height', `${totalHeight}px`);
        overlay.addEventListener('blur', () => { rebuildAndRenderSummary(); }); // Update summary on edit

        primaryCell.innerHTML = ''; // Clear primary cell
        primaryCell.appendChild(overlay);
        primaryCell.classList.add('merged-cell-container');
        primaryCell.setAttribute('data-merge-id', mergeId);
        primaryCell.style.visibility = 'visible'; // Ensure primary is visible

        selectedCells.forEach(cell => {
            if (cell !== primaryCell) {
                cell.textContent = ''; // Clear content of subsumed cells
                cell.classList.add('subsumed-cell'); // Mark as subsumed
                cell.setAttribute('data-merge-id', mergeId);
                cell.style.visibility = 'hidden'; // Hide subsumed cells
            }
        });

        deselectAllTableCells();
        if (selectionMode) toggleCellSelectionMode(); // Optionally turn off selection mode
        showMessage('Cells merged successfully.', 'success');
        updateAllMergeOverlays(); // Update this merge immediately
    }

    function unmergeActiveCellIfMerged() {
        const cellToUnmerge = lastClickedCell; // Use the last clicked cell as the target
        if (!cellToUnmerge) {
            showMessage('Please click on a merged cell to unmerge it.', 'info'); return;
        }
        const containerCell = cellToUnmerge.closest('[data-merge-id]'); // Find the container or any cell in the merge group
        if (!containerCell) {
            showMessage('The clicked cell is not part of a merge.', 'error'); return;
        }

        const mergeId = containerCell.dataset.mergeId;
        const table = containerCell.closest('table');
        if (!table) {
            showMessage('Error: Could not find parent table for unmerging.', 'error'); return;
        }

        const cellsInGroup = table.querySelectorAll(`[data-merge-id="${mergeId}"]`);
        let originalText = '';
        const primaryCellInGroup = Array.from(cellsInGroup).find(c => c.classList.contains('merged-cell-container'));

        if (primaryCellInGroup) {
            const overlay = primaryCellInGroup.querySelector('.merged-cell-overlay');
            if (overlay) originalText = overlay.textContent;
            else originalText = primaryCellInGroup.textContent; // Fallback if overlay somehow missing
            primaryCellInGroup.innerHTML = ''; // Clear the primary cell (overlay will be removed)
        }

        cellsInGroup.forEach(c => {
            c.removeAttribute('data-merge-id');
            c.classList.remove('merged-cell-container', 'subsumed-cell');
            const overlayChild = c.querySelector('.merged-cell-overlay'); // Should only be in primary
            if (overlayChild) overlayChild.remove();
            c.innerHTML = ''; // Clear all cells in the group initially
            c.style.visibility = 'visible'; // Make all cells visible again
        });

        // Restore text to the primary cell (or first cell if primary wasn't clearly identified)
        if (primaryCellInGroup) {
            primaryCellInGroup.textContent = originalText;
        } else if (cellsInGroup.length > 0) {
            cellsInGroup[0].textContent = originalText; // Fallback: put text in the first cell of the group
        }

        rebuildAndRenderSummary();
        showMessage('Cells unmerged successfully.', 'success');
    }

    function updateAllMergeOverlays() {
        const activeTable = document.getElementById(activeTableId);
        if (!activeTable) return;

        activeTable.querySelectorAll('.merged-cell-container').forEach(containerCell => {
            const mergeId = containerCell.dataset.mergeId;
            if (!mergeId) return;
            const overlay = containerCell.querySelector('.merged-cell-overlay');
            if (!overlay) return;

            const cellsInGroup = Array.from(activeTable.querySelectorAll(`[data-merge-id="${mergeId}"]`));
            if (cellsInGroup.length === 0) return; // Should not happen if containerCell exists

            // Calculate bounds based on all cells in the group, including the container
            let minLeft = Infinity, maxRight = -Infinity, minTop = Infinity, maxBottom = -Infinity;
            let primaryCellRect = containerCell.getBoundingClientRect(); // Use container as reference for position

            cellsInGroup.forEach(cellInMerge => {
                // Make sure subsumed cells are hidden for correct measurement of visible cells
                // For sizing, we need the visual extent of the *original* cells
                // The primary cell (containerCell) itself dictates the top-left origin for the overlay.
                // The total width/height is the sum of the widths/heights of the cells that formed the merge.
                // This requires knowing which cells were part of the merge.
                // A simpler approach for resizing is to get the bounding box of all cells in the merge group.
                const rect = cellInMerge.getBoundingClientRect();
                minLeft = Math.min(minLeft, rect.left);
                maxRight = Math.max(maxRight, rect.right);
                minTop = Math.min(minTop, rect.top);
                maxBottom = Math.max(maxBottom, rect.bottom);
            });

            if (minLeft === Infinity) return; // No valid cells found

            const totalWidth = maxRight - minLeft;
            const totalHeight = maxBottom - minTop;

            overlay.style.setProperty('--merged-width', `${totalWidth}px`);
            overlay.style.setProperty('--merged-height', `${totalHeight}px`);
            // Overlay position is relative to its containerCell, so top/left are 0.
        });
    }


    // --- Name List Modal and Firestore Interaction ---
    function handleNameListSessionSwitch(session) {
        currentNameListSession = session;
        if(namePagiTabElement) namePagiTabElement.classList.toggle('active', session === 'pagi');
        if(namePetangTabElement) namePetangTabElement.classList.toggle('active', session === 'petang');
        if(nameModalTitleElement) nameModalTitleElement.textContent = `Name List Manager (${session === 'pagi' ? 'Pagi' : 'Petang'})`;
        if(searchNameInputElement) searchNameInputElement.value = ''; // Clear search on tab switch
        renderNameListFromFirestore(); // Render names for the new session
        clearNameSelection(); // Clear any active name selection from the list
    }

    function highlightSelectedNameInList(nameToHighlight) {
        if (!nameListContainer) return;
        // Remove 'highlighted' from all, then add to the target
        nameListContainer.querySelectorAll('.name-item span').forEach(span => {
            span.classList.remove('highlighted');
        });
        if (nameToHighlight) {
            const targetSpan = nameListContainer.querySelector(`.name-item span[data-name="${nameToHighlight}"]`);
            if (targetSpan) targetSpan.classList.add('highlighted');
        }
    }

    function clearNameSelection() {
        selectedNameFromList = null;
        highlightSelectedNameInList(null); // This will remove all highlights
        if (tablesContainer) tablesContainer.style.cursor = 'default'; // Reset cursor
    }

    function closeNameModal() {
        if (nameModal) nameModal.style.display = 'none';
        clearNameSelection(); // Clear selection and reset cursor when modal closes
        if(searchNameInputElement) searchNameInputElement.value = ''; // Clear search field
    }

    function toggleNameListModalVisibility() {
        if (!nameModal || !nameModalContent || !newNameInput) return;
        const isDisplayed = nameModal.style.display === 'flex';
        if (isDisplayed) {
            closeNameModal();
        } else {
            // Reset modal position before showing (if it was dragged)
            nameModalContent.style.position = 'relative'; // Or initial state
            nameModalContent.style.left = 'auto';
            nameModalContent.style.top = 'auto';
            nameModalContent.style.transform = 'none';

            nameModal.style.display = 'flex';
            if(searchNameInputElement) searchNameInputElement.value = '';
            // Ensure the correct session's names are loaded/displayed
            handleNameListSessionSwitch(currentNameListSession); // This also calls renderNameList
            if(newNameInput) newNameInput.focus();
            clearNameSelection(); // Ensure no prior selection carries over
        }
    }

    function renderNameListFromFirestore(filterText = '') {
        if (!nameListContainer) return;
        if (!fbIsAuthReady) { // Check if Firebase auth is ready
            nameListContainer.innerHTML = '<p style="text-align:center; padding:10px; grid-column: 1 / -1;">Authenticating with Firebase... Please wait.</p>';
            return;
        }
        nameListContainer.innerHTML = ''; // Clear previous list
        const namesToRender = currentNameListSession === 'pagi' ? namesPagi : namesPetang;
        const normalizedFilterText = filterText.toLowerCase().trim();
        const filteredNames = namesToRender.filter(name => name.toLowerCase().includes(normalizedFilterText));

        if (filteredNames.length === 0) {
            nameListContainer.innerHTML = `<p style="text-align:center; padding:10px; grid-column: 1 / -1;">${normalizedFilterText ?
            'No names match your search.' : `No names found in the ${currentNameListSession} session. Add some!`}</p>`;
            return;
        }

        filteredNames.forEach(name => {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'name-item';

            const nameSpan = document.createElement('span');
            nameSpan.dataset.name = name;
            nameSpan.textContent = name;
            nameSpan.title = `Select '${name}' to insert into schedule`;

            const deleteBtn = document.createElement('button');
            deleteBtn.dataset.nameDelete = name;
            deleteBtn.textContent = 'Delete';
            deleteBtn.title = `Delete '${name}' from this list`;

            itemDiv.appendChild(nameSpan);
            itemDiv.appendChild(deleteBtn);
            nameListContainer.appendChild(itemDiv);
        });
        highlightSelectedNameInList(selectedNameFromList); // Re-apply highlight if a name was already selected
    }

    function selectNameForCellInsertion(name) {
        selectedNameFromList = name;
        highlightSelectedNameInList(name); // Highlight the name in the list
        showMessage(`Selected "${name}". Click a cell in the schedule to insert.`, 'info', 4000);
        if (tablesContainer) tablesContainer.style.cursor = 'cell'; // Change cursor to indicate insertion mode
    }

    function handleNameListImportFirestore(event) {
        const file = event.target.files[0];
        if (!file) { showMessage('No file selected for name import.', 'info'); return; }
        if (file.type !== 'text/plain') {
            showMessage('Invalid file type. Please select a .txt file containing names.', 'error');
            if(event.target) event.target.value = ''; return;
        }
        const reader = new FileReader();
        reader.onload = async (e) => {
            try {
                const importedNamesRaw = e.target.result.split(/\r?\n/);
                const importedNames = importedNamesRaw.map(n => n.trim()).filter(n => n !== ''); // Trim and remove empty lines
                
                if (importedNames.length === 0) {
                    showMessage('No valid names found in the selected file.', 'info'); return;
                }
                const currentSessionNames = currentNameListSession === 'pagi' ? namesPagi : namesPetang;
                // Combine and remove duplicates, maintaining case from import for new names
                const combinedNamesSet = new Set([...currentSessionNames, ...importedNames]);
                const combinedNamesArray = Array.from(combinedNamesSet);
                
                await saveNameListToFirestore(currentNameListSession, combinedNamesArray);
                // Firestore onSnapshot will trigger re-render of the list
                showMessage(`${importedNames.length} names processed from file for ${currentNameListSession} session. List updated.`, 'success', 4000);
            } catch (error) {
                console.error("Error processing name list file:", error);
                showMessage(`Error processing name list file: ${error.message}`, 'error');
            } finally {
                if(event.target) event.target.value = ''; // Reset file input
            }
        };
        reader.onerror = () => {
            showMessage('Failed to read the name list file.', 'error');
            if(event.target) event.target.value = '';
        };
        reader.readAsText(file);
    }


    // --- Summary Table Logic ---
    function rebuildAndRenderSummary() {
        const scheduledNames = new Set();
        if (tablesContainer) {
            tablesContainer.querySelectorAll('table.active').forEach(scheduleTable => { // Only active table or all? Let's do all for comprehensive summary.
                 tablesContainer.querySelectorAll('table').forEach(scheduleTable => {
                    if (!scheduleTable.tBodies[0]) return;
                    scheduleTable.tBodies[0].querySelectorAll('tr').forEach(row => {
                        Array.from(row.cells).forEach((cell, cellIndex) => {
                            // Consider only data cells, not row headers (e.g., cellIndex > 0)
                            if (cellIndex > 0) { // Assuming first column is class/label, not a name
                                const overlay = cell.querySelector('.merged-cell-overlay');
                                const nameInCell = (overlay ? overlay.textContent : cell.textContent).trim();
                                if (nameInCell) scheduledNames.add(nameInCell);
                            }
                        });
                    });
                });
            });
        }
        const allSummaryNames = [...scheduledNames].sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));
        buildSummaryTableSkeleton(allSummaryNames); // Rebuilds structure with all names and time slots
        updateSummaryTableData(allSummaryNames);   // Populates the data
    }

    function parseTimeToMinutes(timeStr) {
        if (typeof timeStr !== 'string') return Infinity;
        // Matches HH:MM, H:MM, HH.MM, H.MM at the start of the string
        const match = timeStr.match(/^(\d{1,2})\s*[:.]\s*(\d{2})/);
        if (match) return parseInt(match[1], 10) * 60 + parseInt(match[2], 10);
        // Fallback for simple hour numbers like "8", "14" (less precise)
        const hourOnlyMatch = timeStr.match(/^(\d{1,2})$/);
        if (hourOnlyMatch) return parseInt(hourOnlyMatch[1], 10) * 60;
        return Infinity; // Cannot parse
    }

    function buildSummaryTableSkeleton(allAvailableNames) {
        if (!summaryTableElement) return;
        summaryTableElement.innerHTML = ''; // Clear existing summary

        const tempRawHeadersFromSchedules = new Set();
        if (tablesContainer) {
            tablesContainer.querySelectorAll('table').forEach(scheduleTable => { // Iterate all tables for headers
                if (scheduleTable.tHead && scheduleTable.tHead.rows.length > 0) {
                    // Skip first header cell (usually 'Class/Time')
                    for (let hIdx = 1; hIdx < scheduleTable.tHead.rows[0].cells.length; hIdx++) {
                        const headerText = scheduleTable.tHead.rows[0].cells[hIdx].textContent.trim();
                        if (headerText) tempRawHeadersFromSchedules.add(headerText);
                    }
                }
            });
        }

        // Special LAU/LISAH rule handling (as per original logic)
        let laulisahRuleRequiresSpecialSlot = false;
        const specialNamesForRule = ["LAU", "LISAH"]; // Case-sensitive as in original
        const targetSlotForSpecialNamesRule = "10.15-10.30";
        const sourceSlotToShiftRule = "10.30-12.00"; // The slot that triggers the shift

        if (tablesContainer) {
            for (const scheduleTable of tablesContainer.querySelectorAll('table')) {
                if (laulisahRuleRequiresSpecialSlot) break;
                if (!scheduleTable.tHead?.rows.length > 0 || !scheduleTable.tBodies[0]) continue;
                const currentHeaders = Array.from(scheduleTable.tHead.rows[0].cells).map(th => th.textContent.trim());
                Array.from(scheduleTable.tBodies[0].rows).forEach((dataRow) => {
                    if (laulisahRuleRequiresSpecialSlot) return;
                    for (let cIdx = 1; cIdx < dataRow.cells.length; cIdx++) {
                         let entry = (dataRow.cells[cIdx].querySelector('.merged-cell-overlay')?.textContent || dataRow.cells[cIdx].textContent).trim();
                         if (specialNamesForRule.includes(entry)) {
                            const hdr = currentHeaders[cIdx];
                            // Normalize for comparison: remove spaces, use dot as separator
                            if (hdr && hdr.replace(/\s/g, "").replace(/:/g,".") === sourceSlotToShiftRule.replace(/\s/g, "").replace(/:/g,".")) {
                                laulisahRuleRequiresSpecialSlot = true; return;
                            }
                         }
                    }
                });
            }
        }
        if (laulisahRuleRequiresSpecialSlot) tempRawHeadersFromSchedules.add(targetSlotForSpecialNamesRule);

        let sortedUniqueHeaders = Array.from(tempRawHeadersFromSchedules).sort((a, b) => {
            const timeA = parseTimeToMinutes(a); const timeB = parseTimeToMinutes(b);
            if (timeA !== Infinity && timeB !== Infinity) return timeA - timeB;
            if (timeA !== Infinity) return -1; // Sort valid times before unparseable strings
            if (timeB !== Infinity) return 1;
            return a.localeCompare(b); // Fallback to string compare for non-time headers
        });

        const finalSummaryColumnHeaders = ['Name/Time', ...sortedUniqueHeaders];
        const thead = summaryTableElement.createTHead();
        const headerRow = thead.insertRow();
        finalSummaryColumnHeaders.forEach(txt => {
            const th = document.createElement('th'); th.textContent = txt; headerRow.appendChild(th);
        });

        const tbody = summaryTableElement.createTBody();
        if (allAvailableNames.length === 0 && sortedUniqueHeaders.length === 0) {
            const tr = tbody.insertRow(); const td = tr.insertCell();
            td.textContent = "No schedule data available for summary.";
            td.colSpan = finalSummaryColumnHeaders.length || 1;
            td.style.textAlign = 'center'; td.style.fontStyle = 'italic';
        } else if (allAvailableNames.length === 0) {
             const tr = tbody.insertRow(); const td = tr.insertCell();
            td.textContent = "No names scheduled.";
            td.colSpan = finalSummaryColumnHeaders.length || 1;
            td.style.textAlign = 'center'; td.style.fontStyle = 'italic';
        }
        else {
            allAvailableNames.forEach(name => {
                const tr = tbody.insertRow();
                tr.insertCell().textContent = name; // First cell for the name
                for (let i = 1; i < finalSummaryColumnHeaders.length; i++) {
                    tr.insertCell().textContent = ''; // Empty cells for time slots
                }
            });
        }
    }

    function updateSummaryTableData(allAvailableNames) {
        if (!summaryTableElement || !summaryTableElement.tBodies || !summaryTableElement.tHead || !summaryTableElement.tHead.rows[0]) return;
        const summaryBody = summaryTableElement.tBodies[0];
        if (!summaryBody || (summaryBody.rows.length === 0 && !(summaryBody.rows[0]?.cells[0]?.colSpan > 1))) return;

        const summaryHeaders = Array.from(summaryTableElement.tHead.rows[0].cells).map(th => th.textContent.trim());
        // Normalize summary headers for matching: remove spaces, use dot as separator
        const normalizedSummaryHeaders = summaryHeaders.map(h => h.replace(/\s/g, "").replace(/:/g,"."));

        // Clear previous data and conflict highlights from summary table cells
        Array.from(summaryBody.rows).forEach(row => {
            if (row.cells.length > 1) { // Ensure it's not a "No data" row
                Array.from(row.cells).slice(1).forEach(cell => { // Skip the name cell
                    cell.textContent = '';
                    cell.classList.remove('highlight-conflict');
                });
            }
        });

        if (tablesContainer) {
            tablesContainer.querySelectorAll('table').forEach(scheduleTable => { // Iterate ALL tables
                if (!scheduleTable.tHead?.rows.length > 0 || !scheduleTable.tBodies[0]) return;
                const schHeaders = Array.from(scheduleTable.tHead.rows[0].cells).map(th => th.textContent.trim());

                Array.from(scheduleTable.tBodies[0].rows).forEach((dataRow) => {
                    const classIdCell = dataRow.cells[0];
                    const classId = classIdCell ? classIdCell.textContent.trim() : `Row ${dataRow.rowIndex + 1}`; // Fallback if first cell is empty
                    if (!classId && dataRow.cells.length <=1) return; // Skip if truly empty row

                    for (let cIdx = 1; cIdx < dataRow.cells.length; cIdx++) { // Start from second cell for names
                        let entry = (dataRow.cells[cIdx].querySelector('.merged-cell-overlay')?.textContent || dataRow.cells[cIdx].textContent).trim();
                        if (entry) {
                            let schColHeader = schHeaders[cIdx]; if (!schColHeader) continue;
                            let sumColToUse = schColHeader; // Header to match in summary table

                            // LAU/LISAH rule: if name is LAU or LISAH and in "10.30-12.00", map to "10.15-10.30" in summary
                            const specialNames = ["LAU", "LISAH"];
                            const targetSlot = "10.15-10.30";
                            const sourceSlot = "10.30-12.00";
                            const normSchColHdr = schColHeader.replace(/\s/g, "").replace(/:/g,".");
                            const normSrcSlot = sourceSlot.replace(/\s/g, "").replace(/:/g,".");
                            if (specialNames.includes(entry) && normSchColHdr === normSrcSlot) {
                                sumColToUse = targetSlot;
                            }

                            const targetRow = Array.from(summaryBody.rows).find(sr => sr.cells[0]?.textContent === entry);
                            if (targetRow && targetRow.cells.length > 1) {
                                const normSumColLookup = sumColToUse.replace(/\s/g, "").replace(/:/g,".");
                                const targetColIdx = normalizedSummaryHeaders.indexOf(normSumColLookup);
                                if (targetColIdx > 0) { // Found matching header in summary
                                    const sumCell = targetRow.cells[targetColIdx];
                                    let classes = sumCell.textContent.trim() ? sumCell.textContent.trim().split(',').map(s => s.trim()) : [];
                                    if (!classes.includes(classId)) {
                                        classes.push(classId);
                                        sumCell.textContent = classes.sort((a,b) => a.localeCompare(b, undefined, { sensitivity: 'base' })).join(', ');
                                    }
                                }
                            }
                        }
                    }
                });
            });
        }
        // Highlight conflicts (cells with multiple classes)
        Array.from(summaryBody.rows).forEach(row => {
            if (row.cells.length > 1) {
                Array.from(row.cells).forEach((cell, idx) => {
                    if (idx > 0 && cell.textContent.includes(',')) { // If cell has multiple comma-separated items
                        cell.classList.add('highlight-conflict');
                    }
                });
            }
        });
    }

</script>
</body>
</html>