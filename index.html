<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=0.1, maximum-scale=5.0">
    <title>Shared Weekly Schedule with Firestore</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', 'Roboto', Arial, sans-serif;
            margin: 0;
            background-color: #f0f2f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            box-sizing: border-box;
            min-height: 100vh;
        }
        .main-container {
            width: 100%;
            max-width: 1400px;
            background-color: #ffffff;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 6px 20px rgba(0,0,0,0.08);
            box-sizing: border-box;
        }
        h2, h3 {
            color: #1c1e21;
            text-align: center;
            margin-bottom: 20px;
        }
        #scheduleTitle {
            font-size: 2em;
            color: #0056b3;
            border-bottom: 2px solid #0056b3;
            padding-bottom: 10px;
        }
        #userIdDisplay {
            text-align: center;
            font-size: 0.9em;
            color: #555;
            margin-bottom: 15px;
            min-height: 1.2em;
            word-break: break-all;
        }

        /* --- Top Action Buttons Bar --- */
        #topActionButtonsBar {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: stretch;
            justify-content: center;
            margin-bottom: 20px;
            width: 100%;
        }

        .top-action-btn {
            padding: 10px 15px;
            font-size: 0.9em;
            font-weight: 500;
            border-radius: 8px;
            cursor: pointer;
            border: 1px solid transparent;
            color: #ffffff;
            transition: all 0.25s ease-out;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05), 0 1px 2px rgba(0,0,0,0.03);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            white-space: nowrap;
            flex-grow: 1;
            flex-basis: 150px;
            text-align: center;
            min-height: 40px;
            box-sizing: border-box;
        }

        #controlsToggler.top-action-btn {
            background-image: linear-gradient(to right, #007bff 0%, #0056b3 100%);
        }
        #controlsToggler.top-action-btn:hover {
            background-image: linear-gradient(to right, #0069d9 0%, #004085 100%);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1), 0 2px 4px rgba(0,0,0,0.06);
            transform: translateY(-1px);
        }

        #manualSaveBtn.top-action-btn {
            background-image: linear-gradient(to right, #17a2b8 0%, #117a8b 100%);
        }
        #manualSaveBtn.top-action-btn:hover {
            background-image: linear-gradient(to right, #138496 0%, #0c6270 100%);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1), 0 2px 4px rgba(0,0,0,0.06);
            transform: translateY(-1px);
        }

        #downloadPdfBtn.top-action-btn {
             background-image: linear-gradient(to right, #28a745 0%, #1e7e34 100%);
        }
        #downloadPdfBtn.top-action-btn:hover {
             background-image: linear-gradient(to right, #218838 0%, #155724 100%);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1), 0 2px 4px rgba(0,0,0,0.06);
            transform: translateY(-1px);
        }
        
        #clearScheduledNamesBtn.top-action-btn {
            background-image: linear-gradient(to right, #6f42c1 0%, #563d7c 100%);
        }
        #clearScheduledNamesBtn.top-action-btn:hover {
            background-image: linear-gradient(to right, #5a2a9e 0%, #452863 100%);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1), 0 2px 4px rgba(0,0,0,0.06);
            transform: translateY(-1px);
        }

        .top-action-btn:active {
            transform: translateY(0px);
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }

        #controlsToggler .toggler-icon {
            transition: transform 0.3s ease-out;
            width: 18px;
            height: 18px;
        }
        #controlsToggler[aria-expanded="false"] .toggler-icon {
            transform: rotate(180deg);
        }
         #controlsToggler[aria-expanded="true"] .toggler-icon {
            transform: rotate(0deg);
        }

        /* --- Collapsible Button Bars --- */
        #collapsibleButtonBars {
            max-height: 1000px;
            overflow: hidden;
            transition: max-height 0.4s ease-in-out, margin-top 0.4s ease-in-out, padding-top 0.4s ease-in-out, padding-bottom 0.4s ease-in-out;
            padding-top: 5px;
            padding-bottom: 5px;
            width: 100%;
        }
        #collapsibleButtonBars:not(.open) {
            max-height: 0;
            padding-top: 0;
            padding-bottom: 0;
            margin-top: 0;
        }

        .bar {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 15px;
            align-items: stretch;
            justify-content: center;
        }
        .bar button {
            padding: 10px 15px;
            font-size: 0.9em;
            font-weight: 500;
            border-radius: 8px;
            cursor: pointer;
            border: 1px solid #ced4da;
            background-color: #f8f9fa;
            color: #212529;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 1px 2px rgba(0,0,0,0.04);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            flex-grow: 1;
            flex-basis: 120px;
            text-align: center;
            min-width: 100px;
        }
        .bar button:hover {
            border-color: #adb5bd;
            background-color: #e9ecef;
            box-shadow: 0 2px 5px rgba(0,0,0,0.08);
            transform: translateY(-1px);
        }
        .bar button:active {
            transform: translateY(0px);
            background-color: #dee2e6;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.06);
        }

        #directCopyFullHtmlBtn { background-color: #545b62; color: white; border-color: #4e555b;}
        #excelBtnTrigger, #importExcelBtn, #importNameListBtn, .input-group button { background-color: #28a745; color: white; border-color: #23923d;}
        #saveSharedScheduleBtn { background-color: #007bff; color: white; border-color: #0069d9;}
        #loadSharedScheduleBtn { background-color: #ffc107; color: #212529; border-color: #e0a800;}
        #restoreBackupBtn { background-color: #fd7e0f; color: white; border-color: #df6e0d; }
        #clearAndResetScheduleBtn, #nameListBtn { background-color: #fd7e14; color: white; border-color: #e66a04;}
        #selectBtn { background-color: #17a2b8; color: white; border-color: #117a8b;}
        #selectBtn.active { background-color: #e66a04; border-color: #d05f03;}
        #mergeBtn { background-color: #6f42c1; color: white; border-color: #5d37a2;}
        #unmergeBtn { background-color: #e83e8c; color: white; border-color: #d9307b;}
        #addTableBtn { background-color: #20c997; color: white; border-color: #1aa87f;}
        #renameTableBtn, #deselectBtn { background-color: #6c757d; color: white; border-color: #5a6268;}
        #deleteTableBtn, #rowColManipulationBar button.delete-btn { background-color: #dc3545; color: white; border-color: #c82333;}
        #exportSharedSchedulesBtn { background-color: #4e54c8; color: white; border-color: #3b40a0;}
        #importSharedSchedulesBtn { background-color: #8f94fb; color: white; border-color: #7076f9;}
        
        #directCopyFullHtmlBtn:hover { background-color: #434a50; }
        #excelBtnTrigger:hover, #importExcelBtn:hover, #importNameListBtn:hover, .input-group button:hover { background-color: #1e7e34; }
        #saveSharedScheduleBtn:hover { background-color: #0056b3; }
        #loadSharedScheduleBtn:hover { background-color: #d39e00; }
        #restoreBackupBtn:hover { background-color: #e07010; }
        #clearAndResetScheduleBtn:hover, #nameListBtn:hover { background-color: #d05f03; }
        #selectBtn:hover { background-color: #0f6674; }
        #selectBtn.active:hover { background-color: #c25202;}
        #mergeBtn:hover { background-color: #563299; }
        #unmergeBtn:hover { background-color: #d9307b; }
        #addTableBtn:hover { background-color: #178d6f; }
        #renameTableBtn:hover, #deselectBtn:hover { background-color: #545b62; }
        #deleteTableBtn:hover, #rowColManipulationBar button.delete-btn:hover { background-color: #b21f2d; }
        #exportSharedSchedulesBtn:hover { background-color: #3b40a0; }
        #importSharedSchedulesBtn:hover { background-color: #7076f9; }

        #rowColManipulationBar button { padding: 8px 12px; font-size: 0.85em; }

        table {
            border-collapse: collapse;
            width: 100%;
            margin-top: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            background-color: #fff;
            table-layout: auto; /* Changed to auto for better flexibility with colspan */
        }
        #tablesContainer, #summaryTableContainer {
            overflow-x: auto;
            position: relative;
            width: 100%;
        }
        #tablesContainer > table { display: none; }
        #tablesContainer > table.active { display: table; }
        #summaryTable { margin-top: 25px; }

        th, td {
            border: 1px solid #dee2e6;
            padding: 10px 12px;
            text-align: center;
            min-width: 90px; /* Consider if this needs adjustment with many summary columns */
            box-sizing: border-box;
            position: relative;
            font-size: 0.9em;
        }
        table th {
            background-color: #f8f9fa;
            color: #343a40;
            font-weight: 600;
            white-space: nowrap;
        }
        #tablesContainer > table > thead > tr:not(.date-header-row) > th {
            font-weight: bold;
            background-color: #e9ecef;
            color: #343a40;
        }
        #tablesContainer > table > thead > tr:not(.date-header-row) > th:first-child,
        #tablesContainer > table > tbody > tr > td:first-child,
        #tablesContainer > table > tbody > tr > th:first-child {
            font-weight: bold;
            background-color: #e6f7ff; /* Light blue for first column */
            color: #1c1e21;
        }

        #tablesContainer > table > thead > tr.date-header-row > th.date-header-cell {
            font-weight: bold;
            background-color: #cce0ff; /* Lighter blue for date headers */
            color: #1c1e21;
            white-space: normal;
        }
        #tablesContainer > table > thead > tr.date-header-row > th.date-header-cell.merged-cell-container .merged-cell-overlay {
            background-color: #cce0ff; /* Ensure overlay matches */
            font-weight: bold;
            color: #1c1e21;
        }


        #summaryTable > thead > tr > th {
            font-weight: bold;
            background-color: #e9ecef; /* Light grey for summary headers */
            color: #212529;
        }
        #summaryTable > thead > tr > th:first-child,
        #summaryTable > tbody > tr > td:first-child {
            font-weight: bold;
            background-color: #e6f7ff !important; /* Consistent light blue for first column, !important to override other styles if needed */
            color: #1c1e21;
        }
        /* Style for merged cells in the summary table */
        #summaryTable td.summary-merged-cell {
            background-color: #f0f8ff !important; /* AliceBlue or similar light color, !important for specificity */
        }
        #summaryTable td { background-color: #fff9e6; } /* Default for non-merged summary data cells */
        
        td.selected, th.selected {
            outline: 3px solid #007bff;
            background-color: #d1e7fd;
        }
        
        .table-tabs {
            margin-bottom: 15px;
            border-bottom: 2px solid #007bff;
            padding-bottom: 0;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }
        .table-tabs button {
            background-color: transparent; border: none;
            border-bottom: 3px solid transparent; border-radius: 6px 6px 0 0;
            color: #0056b3; font-weight: 500; padding: 10px 15px;
            transition: all 0.2s ease;
        }
        .table-tabs button.active {
            background-color: #007bff; color: white;
            border-color: #0056b3;
        }
        .table-tabs button:hover:not(.active) {
            background-color: #e9f5ff; color: #004494;
        }

        .name-session-tabs {
            margin-bottom: 20px; border-bottom: 2px solid #dee2e6;
            padding-bottom: 8px; display: flex; flex-wrap: wrap; gap: 5px;
        }
        .name-session-tabs button {
            border-bottom-left-radius: 0; border-bottom-right-radius: 0;
            border-bottom: none; margin-bottom: -2px;
            padding: 10px 15px; font-size: 1em;
            background-color: #f8f9fa; border: 1px solid #dee2e6;
            border-bottom: 1px solid #dee2e6;
        }
        .name-session-tabs button.active {
            background-color: #ffffff; color: #007bff;
            border-color: #dee2e6 #dee2e6 #ffffff;
            border-bottom: 1px solid #ffffff;
            font-weight: bold; position: relative; z-index: 1;
        }
        
        .highlight-conflict {
            background-color: #f8d7da !important; font-weight: bold;
            color: #721c24 !important;
        }
        /* Ensure conflict in first column of summary also gets attention if needed, though less likely */
        #summaryTable > tbody > tr > td.highlight-conflict:first-child {
            background-color: #e6f7ff !important; /* Keep its base color */
            color: #721c24 !important; /* But show conflict text color */
        }
        .modal {
            display: none; position: fixed; z-index: 1000; left: 0; top: 0;
            width: 100%; height: 100%; overflow: hidden;
            background-color: rgba(0,0,0,0.5);
            align-items: center; justify-content: center;
            pointer-events: none;
        }
        .modal-content {
            background-color: #fff; padding: 25px; border: 1px solid #ccc;
            width: 90%; max-width: 650px; border-radius: 10px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.3); position: relative;
            pointer-events: auto; max-height: 90vh; overflow-y: auto;
            box-sizing: border-box;
        }
        .modal-content.dragging { transform: none; }
        .modal-header {
            padding-bottom: 15px; border-bottom: 1px solid #e9ecef; margin-bottom: 20px;
            font-size: 1.3em; color: #333; display: flex;
            justify-content: space-between; align-items: center;
            cursor: move; user-select: none;
        }
        .modal-close-btn {
            font-size: 1.8rem; font-weight: bold; line-height: 1; color: #555;
            text-shadow: none; opacity: .7; background: transparent; border: 0;
            cursor: pointer; padding: 0 5px; transition: color 0.2s;
        }
        .modal-close-btn:hover { opacity: 1; color: #dc3545; }
        .name-item {
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px 8px; border-bottom: 1px solid #f1f3f5;
            transition: background-color 0.2s;
        }
        .name-item:hover { background-color: #f8f9fa; }
        .name-item:last-child { border-bottom: none; }
        .name-item span {
            flex-grow: 1; cursor: pointer; color: #007bff; font-weight: 500;
        }
        .name-item span:hover { text-decoration: none; color: #0056b3; }
        .name-item button {
            background-color: #dc3545; color: white; border: none; border-radius: 5px;
            padding: 6px 12px; font-size: 0.9em; transition: background-color 0.2s;
        }
        .name-item button:hover { background-color: #c82333; }
        .highlighted { background-color: #cfe2ff !important; font-weight: bold; }
        
        #sharedScheduleListContainer, #restoreBackupListContainer {
            border: 1px solid #ddd; padding: 15px; margin-bottom: 20px;
            border-radius: 8px; background-color: #f8f9fa;
            max-height: 300px; overflow-y: auto;
        }
        .shared-schedule-item, .backup-schedule-item {
            display: flex; flex-direction: column;
            padding: 10px 8px; border-bottom: 1px solid #e9ecef;
        }
        .shared-schedule-item:last-child, .backup-schedule-item:last-child { border-bottom: none; }

        .schedule-item-main-line {
            display: flex; justify-content: space-between; align-items: center; width: 100%;
        }
        .schedule-item-main-line span {
            cursor: pointer; color: #007bff; flex-grow: 1; margin-right: 10px;
            font-weight: 500;
        }
        .schedule-item-main-line span:hover { text-decoration: underline; }
        .schedule-item-main-line button {
            background-color: #dc3545; color: white; border: none; border-radius: 5px;
            padding: 6px 12px; font-size: 0.9em; flex-shrink: 0;
        }
        .schedule-item-details {
            font-size: 0.8em; color: #6c757d; margin-top: 4px;
            display: flex; flex-direction: column;
            gap: 2px;
        }
        .schedule-item-details .schedule-date,
        .schedule-item-details .original-schedule-name {
             white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }


        #newNameInput, #searchNameInput {
            padding: 10px; margin-right: 8px; border: 1px solid #ccc;
            border-radius: 5px; flex-grow: 1; width: calc(100% - 120px);
            box-sizing: border-box;
        }
         #searchNameInput {
            margin-bottom: 15px; width: 100%; box-sizing: border-box; margin-right: 0;
         }
        .input-group { display: flex; margin-bottom: 15px; width: 100%; }
        .input-group button { padding: 10px 15px; }
        #importNameListBtn { margin-top: 10px; width: 100%; }
        #nameList { margin-top:15px; max-height:250px; overflow-y:auto; }
        @media (min-width: 480px) {
            #nameList { column-count: 2; column-gap: 20px; }
        }
        .custom-message-box {
            display: none; position: fixed; top: 20px; left: 50%;
            transform: translateX(-50%); background-color: #333; color: white;
            padding: 15px 25px; border-radius: 8px; z-index: 2000;
            box-shadow: 0 4px 15px rgba(0,0,0,0.25); font-size: 1.05em;
            text-align: center; width: 90%; max-width: 400px;
        }
        .custom-message-box.success { background-color: #28a745; }
        .custom-message-box.error { background-color: #dc3545; }
        .custom-message-box.info { background-color: #007bff; }
        .merged-cell-container { position: relative; z-index: 2; vertical-align: top; }
        .merged-cell-overlay {
            position: absolute; top: 0; left: 0;
            width: var(--merged-width); height: var(--merged-height);
            background-color: rgba(240, 248, 255, 0.95); /* Light alpha blue for original table merges */
            font-style: italic; border: 1px solid #add8e6;
            display: flex; align-items: center; justify-content: center;
            overflow: hidden; box-sizing: border-box; z-index: 5;
        }
        .subsumed-cell { visibility: hidden; }
        #loadingIndicatorModal, #generalLoadingIndicator, #loadingIndicatorRestoreModal {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(255, 255, 255, 0.85);
            display: flex; align-items: center; justify-content: center;
            z-index: 10; border-radius: 10px;
        }
        #generalLoadingIndicator { position: fixed; z-index: 3000; border-radius: 0; }
        .spinner {
            border: 5px solid rgba(0, 0, 0, 0.1); width: 40px; height: 40px;
            border-radius: 50%; border-left-color: #007bff;
            animation: spin 1s ease infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        input[type="file"][style*="display:none"],
        input[type="file"][style*="display: none"] {
            position: absolute; left: -9999px; width: 1px; height: 1px; opacity: 0;
        }
        #autocompleteSuggestions {
            display: none; position: absolute; border: 1px solid #ccc;
            background-color: white; z-index: 1001; max-height: 150px;
            overflow-y: auto; min-width: 120px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.15); border-radius: 4px;
        }
        .suggestion-item {
            padding: 8px 10px; cursor: pointer; font-size: 0.9em; white-space: nowrap;
        }
        .suggestion-item:hover, .suggestion-item.active-suggestion {
            background-color: #e9ecef; color: #0056b3;
        }

        /* PDF Specific Styles */
        #pdfContent {
            padding: 5mm; background-color: #fff; color: #333;
            font-family: 'Arial', sans-serif; box-sizing: border-box;
            width: 100%; display: none;
        }
        #pdfContent .pdf-page-wrapper {
            page-break-inside: avoid !important; padding-bottom: 10mm;
            box-sizing: border-box; margin-bottom: 5mm;
        }
         #pdfContent .pdf-page-wrapper:not(:first-child) { page-break-before: always !important; }
        #pdfContent .pdf-page-wrapper:last-child { page-break-after: auto !important; }
        #pdfContent h2 {
            text-align: center; color: #000; margin-bottom: 5mm; font-size: 14pt;
            page-break-after: avoid !important; page-break-inside: avoid !important;
        }
        #pdfContent h3 {
            text-align: center; color: #000; margin-top: 2mm; margin-bottom: 3mm;
            font-size: 11pt; page-break-after: avoid !important; page-break-inside: avoid !important;
        }
        #pdfContent table {
            width: 100% !important; border-collapse: collapse !important;
            margin-bottom: 5mm; box-shadow: none; background-color: #fff;
            table-layout: fixed !important; font-size: 7pt;
            page-break-inside: avoid !important;
        }
        #pdfContent th, #pdfContent td {
            border: 0.5pt solid #333 !important; padding: 1mm 1.5mm;
            text-align: center; word-wrap: break-word; overflow-wrap: break-word;
            background-color: #fff !important; page-break-inside: avoid !important;
        }
        #pdfContent th {
            background-color: #f0f0f0 !important; color: #000; font-weight: bold;
        }
        #pdfContent table thead tr.date-header-row th.date-header-cell {
            background-color: #b8d6ff !important;
            font-weight: bold !important;
            color: #000 !important;
            white-space: normal !important;
        }
        #pdfContent table thead tr:not(.date-header-row) th:first-child,
        #pdfContent table tbody tr td:first-child {
            background-color: #e6f7ff !important; font-weight: bold; white-space: normal;
        }
         #pdfContent table tr { page-break-inside: avoid !important; }
        #pdfContent .pdf-footnote {
            text-align: right; font-size: 6pt; color: #333; margin-top: 3mm;
            padding-top: 2mm; border-top: 0.5pt solid #ccc; width: 100%;
            box-sizing: border-box;
        }

        @media (max-width: 768px) {
            .main-container { padding: 15px; }
            #scheduleTitle { font-size: 1.8em; }
            h3 { font-size: 1.1em; }
            .top-action-btn {
                font-size: 0.85em;
                padding: 8px 12px;
                flex-basis: calc(25% - 6px);
                min-width: 0;
            }
            .bar button { font-size: 0.85em; padding: 8px 12px; flex-basis: 100px; }
            th, td { padding: 8px 10px; min-width: 70px; font-size: 0.85em; }
            .table-tabs button, .name-session-tabs button { padding: 8px 10px; font-size: 0.9em; }
        }
        @media (max-width: 600px) {
             .top-action-btn {
                flex-basis: calc(50% - 4px);
            }
        }
        @media (max-width: 480px) {
            body { padding: 5px; }
            .main-container { padding: 10px; }
            #scheduleTitle { font-size: 1.5em; }
            #controlsToggler .toggler-icon { width: 16px; height: 16px; }
             .bar button { font-size: 0.8em; padding: 6px 10px; gap: 4px; flex-basis: calc(50% - 4px); }
            th, td { padding: 6px 8px; min-width: 60px; font-size: 0.8em; }
             #nameList { column-count: 1; }
        }
    </style>
</head>
<body>
<div class="main-container">
    <h2 contenteditable="true" id="scheduleTitle">Jadual Anjal</h2>
    <div id="userIdDisplay">User ID: Loading...</div>

    <div id="topActionButtonsBar">
        <button id="controlsToggler" class="top-action-btn" aria-expanded="false" aria-controls="collapsibleButtonBars" title="Toggle button controls visibility">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="toggler-icon"><polyline points="18 15 12 9 6 15"></polyline></svg>
            <span>Show Controls</span>
        </button>
        <button id="manualSaveBtn" class="top-action-btn" title="Manually save current page state to Cloud (also creates a backup)">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg>
            <span>Save Page</span>
        </button>
        <button id="downloadPdfBtn" class="top-action-btn" title="Download schedule tables as PDF">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>
            <span>PDF</span>
        </button>
        <button id="clearScheduledNamesBtn" class="top-action-btn" title="Clear scheduled names from the ACTIVE table (retains merged cell content)">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><line x1="17" y1="8" x2="22" y2="13"></line><line x1="22" y1="8" x2="17" y2="13"></line></svg>
            <span>Clear Names (Active Table)</span>
        </button>
    </div>

    <div id="collapsibleButtonBars">
        <div class="bar">
            <button id="directCopyFullHtmlBtn" title="Copy the entire page's HTML to clipboard">üìã Copy HTML</button>
        </div>
        <div class="bar">
            <button id="excelBtnTrigger" title="Export the currently active table to an Excel file">üíæ Export Excel</button>
            <button id="importExcelBtn" title="Import data from an Excel file into a new table">üìÇ Import Excel</button>
            <input type="file" id="fileInput" accept=".xlsx, .xls" style="display:none">
        </div>
        <div class="bar">
            <button id="saveSharedScheduleBtn" title="Save current schedule to the shared Cloud space (also creates a backup)">üí† Save Shared</button>
            <button id="loadSharedScheduleBtn" title="Show list of shared schedules from Cloud to load">‚òÅÔ∏è Load Shared</button>
            <button id="restoreBackupBtn" title="Restore a schedule from a backup copy">üõ°Ô∏è Restore Backup</button>
            <button id="exportSharedSchedulesBtn" title="Export all shared schedules from Cloud to a JSON file">üì§ Export All</button>
            <button id="importSharedSchedulesBtn" title="Import schedules from a JSON file to the shared Cloud space">üì• Import All</button>
            <input type="file" id="sharedScheduleImportFile" accept=".json" style="display:none;">
            <button id="clearAndResetScheduleBtn" title="Clear all data and start a new schedule">üßπ Clear & New</button>
        </div>
        <div class="bar">
            <button id="selectBtn" title="Toggle cell selection mode on/off">‚ú® Select Cells</button>
            <button id="mergeBtn" title="Merge the currently selected cells">üîó Merge</button>
            <button id="deselectBtn" title="Clear current cell selection">üö´ Deselect</button>
            <button id="unmergeBtn" title="Unmerge the cell that was last clicked if it's part of a merge">üíî Unmerge</button>
        </div>
        <div class="bar">
            <button id="addTableBtn" title="Add a new, empty table/sheet">‚ûï Add Table</button>
            <button id="renameTableBtn" title="Rename the currently active table/sheet">üìù Rename Table</button>
            <button id="deleteTableBtn" title="Delete the currently active table/sheet">‚ùå Delete Table</button>
            <button id="nameListBtn" title="Open a dialog to manage the shared list of names (Firestore)">üë• Names</button>
        </div>
        <div class="bar" id="rowColManipulationBar">
            <button id="addRowAboveBtn" title="Add a new row above the currently selected/clicked row">‚¨ÜÔ∏è Row Above</button>
            <button id="addRowBelowBtn" title="Add a new row below the currently selected/clicked row">‚¨áÔ∏è Row Below</button>
            <button id="addColLeftBtn" title="Add a new column to the left of the currently selected/clicked column">‚¨ÖÔ∏è Col Left</button>
            <button id="addColRightBtn" title="Add a new column to the right of the currently selected/clicked column">‚û°Ô∏è Col Right</button>
            <button id="deleteRowBtn" class="delete-btn" title="Delete the currently selected/clicked row">üóëÔ∏è Del Row</button>
            <button id="deleteColBtn" class="delete-btn" title="Delete the currently selected/clicked column">üóëÔ∏è Del Col</button>
        </div>
    </div>
    <div id="sharedScheduleListContainer" style="display:none;"></div>
    
    <div id="restoreBackupModal" class="modal">
        <div class="modal-content" id="restoreBackupModalContent">
            <div class="modal-header" id="restoreBackupModalHeader">
                <h3 id="restoreBackupModalTitle">Restore Schedule from Backup</h3>
                <button type="button" class="modal-close-btn" id="closeRestoreBackupModalBtn" title="Close restore backup">√ó</button>
            </div>
            <div id="restoreBackupListContainer"></div>
            <div id="loadingIndicatorRestoreModal" style="display:none;"><div class="spinner"></div></div>
        </div>
    </div>

    <div class="bar table-tabs" id="tableTabs"></div>
    <div id="tablesContainer">
        <!-- Example Table Structure (initial content) -->
        <table id="tbl_1" class="active" data-table-name="Kelas 3 & 5">
            <thead>
                <tr class="date-header-row">
                    <th class="date-header-cell" contenteditable="true">Thursday, 22 May 2025</th>
                    <th class="date-header-cell" contenteditable="true"></th>
                    <th class="date-header-cell" contenteditable="true"></th>
                    <th class="date-header-cell date-header-cell merged-cell-container" contenteditable="true" data-merge-id="date_rehat_tbl1_col4">
                        <div class="merged-cell-overlay" style="--merged-width: 200px; --merged-height: 40px;" contenteditable="true">DAY INFO</div>
                    </th>
                    <th class="date-header-cell subsumed-cell" contenteditable="true" data-merge-id="date_rehat_tbl1_col4"></th>
                    <th class="date-header-cell" contenteditable="true"></th>
                    <th class="date-header-cell" contenteditable="true"></th>
                </tr>
                <tr>
                    <th contenteditable="true">Class</th>
                    <th contenteditable="true">08:00</th>
                    <th contenteditable="true">09:00</th>
                    <th contenteditable="true">10:00</th>
                    <th contenteditable="true" data-merge-id="rehat_tbl1_col4" class="merged-cell-container">
                        <div class="merged-cell-overlay" style="--merged-width: 200px; --merged-height: 50px;" contenteditable="true">REHAT</div>
                    </th>
                    <th contenteditable="true" data-merge-id="rehat_tbl1_col4" class="subsumed-cell">11:00</th>
                    <th contenteditable="true">12:00</th>
                    <th contenteditable="true">13:00</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td contenteditable="true">5S1</td>
                    <td contenteditable="true"></td><td contenteditable="true">JAMES *ReportDue // Sick leave</td><td contenteditable="true"></td>
                    <td contenteditable="true" data-merge-id="rehat_tbl1_col4_row1" class="merged-cell-container">
                         <div class="merged-cell-overlay" style="--merged-width: 200px; --merged-height: 50px;" contenteditable="true"></div>
                    </td>
                    <td contenteditable="true" data-merge-id="rehat_tbl1_col4_row1" class="subsumed-cell"></td>
                    <td contenteditable="true"></td><td contenteditable="true"></td>
                </tr>
                 <tr>
                    <td contenteditable="true">5S2</td>
                    <td contenteditable="true">*SpecialAssembly</td><td contenteditable="true"></td><td contenteditable="true">LILY</td>
                     <td contenteditable="true" data-merge-id="rehat_tbl1_col4_row2" class="merged-cell-container">
                         <div class="merged-cell-overlay" style="--merged-width: 200px; --merged-height: 50px;" contenteditable="true"></div>
                    </td>
                    <td contenteditable="true" data-merge-id="rehat_tbl1_col4_row2" class="subsumed-cell"></td>
                    <td contenteditable="true"></td><td contenteditable="true"></td>
                </tr>
            </tbody>
        </table>
    </div>

    <div id="nameModal" class="modal">
        <div class="modal-content" id="nameModalContent">
            <div class="modal-header" id="nameModalHeader">
                <h3 id="nameModalTitle">Shared Name List Manager</h3>
                <button type="button" class="modal-close-btn" id="closeNameModalBtnStandard" title="Close name manager">√ó</button>
            </div>
            <div class="name-session-tabs">
                <button id="namePagiTab" data-session="pagi" class="active">Pagi (Morning)</button>
                <button id="namePetangTab" data-session="petang">Petang (Afternoon)</button>
            </div>
             <div class="input-group">
                <input id="newNameInput" placeholder="Add new name to current shared session">
                <button id="addNameBtnInModal" title="Add the name to the shared list">Add</button>
             </div>
            <button id="importNameListBtn" title="Import names from a .txt file (one name per line) to current shared session">üìÇ Import Names (.txt) to Shared Session</button>
            <input type="file" id="nameListImportFile" accept=".txt" style="display:none;">
            <input type="text" id="searchNameInput" placeholder="üîç Search names in current shared session..." title="Filter the list of names">
            <div id="nameList"></div>
            <div id="loadingIndicatorModal" style="display:none;"><div class="spinner"></div></div>
        </div>
    </div>

    <h3 style="margin-top:32px">Teacher/Subject Attendance Summary</h3>
    <div id="summaryTableContainer">
        <table id="summaryTable"></table>
    </div>
    <div id="customMessageBox" class="custom-message-box"></div>
    <div id="generalLoadingIndicator" style="display:none;"><div class="spinner"></div></div>
</div>

<div id="pdfContent"></div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, setDoc, onSnapshot, collection, addDoc, getDocs, getDoc, deleteDoc, updateDoc, query, serverTimestamp, orderBy, where, limit } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // --- User-provided Firebase Config (Fallback) ---
    const userProvidedFirebaseConfig = {
      apiKey: "AIzaSyBgvyb95-jujtCC2HPiHXLdYMJgQquIEx4", // Replace with your actual API key if not using injected config
      authDomain: "jadual-3f0aa.firebaseapp.com",
      projectId: "jadual-3f0aa",
      storageBucket: "jadual-3f0aa.appspot.com", // Corrected storage bucket
      messagingSenderId: "496526436851",
      appId: "1:496526436851:web:78ff48b28bfc8c31f14a86"
    };

    // --- Firebase Initialization ---
    let firebaseConfig;
    if (typeof __firebase_config !== 'undefined' && __firebase_config !== null && __firebase_config.trim() !== '') {
        try {
            firebaseConfig = JSON.parse(__firebase_config);
            console.log("Using injected Firebase config (__firebase_config).");
        } catch (e) {
            console.error("Error parsing injected __firebase_config. Falling back. Error:", e);
            firebaseConfig = userProvidedFirebaseConfig;
        }
    } else {
        firebaseConfig = userProvidedFirebaseConfig;
        console.log("Using Firebase config defined in the script.");
    }
    
    if (firebaseConfig.apiKey === "AIzaSyEXAMPLE-API-KEYdQquIEx4" || firebaseConfig.apiKey === "YOUR_API_KEY" || firebaseConfig.apiKey.includes("AIzaSyBgvyb95-jujtCC2HPiHXLdYMJgQquIEx4")) {
        console.warn("Firebase Auth: Update Firebase API Key if you see this in production and not using an injected key.");
    }
    
    const appId = typeof __app_id !== 'undefined' ? __app_id : (firebaseConfig.appId || 'default-shared-scheduler-app');
    if (typeof __app_id === 'undefined') {
        console.warn("Firebase Auth: __app_id is not defined. Using App ID from Firebase config or default.");
    }

    let fbApp, fbAuth, fbDb;
    let fbUserId = null;
    let fbIsAuthReady = false;
    let unsubscribePagiShared = null;
    let unsubscribePetangShared = null;

    try {
        fbApp = initializeApp(firebaseConfig);
        fbAuth = getAuth(fbApp);
        fbDb = getFirestore(fbApp);
        console.log("Firebase services initialized for Shared Scheduler with Project ID:", firebaseConfig.projectId);
    } catch (e) {
        console.error("CRITICAL Error initializing Firebase services:", e);
        const userIdDisplayInitError = document.getElementById('userIdDisplay');
        if (userIdDisplayInitError) userIdDisplayInitError.textContent = "User ID: Firebase Init Error!";
    }

    // --- Global Variables & Constants ---
    const SCHEDULE_TITLE_KEY = `shared_jadual_title_${appId}`;
    const LAST_ACTIVE_SCHEDULE_ID_KEY = `last_active_schedule_id_${appId}`;
    
    let activeTableId = 'tbl_1';
    let tableCount = 1;
    let selectionMode = false;
    let selectedCells = [];
    let lastClickedCell = null;
    let selectedNameFromList = null;
    let currentNameListSession = 'pagi';
    let namesPagiShared = [];
    let namesPetangShared = [];
    let isDraggingModal = false;
    let modalDragOffsetX, modalDragOffsetY;
    let autocompleteSuggestionsDiv = null;
    let activeCellForAutocomplete = null;
    let currentAutocompleteIndex = -1;
    
    let currentWorkingScheduleDocId = null;
    let autoSaveIntervalId = null;
    const AUTO_SAVE_INTERVAL = 60000; // 1 minute
    let isAutoSaving = false;
    let lastSavedState = null;
    let isInitialStateSet = false;

    // --- DOM Element References ---
    // (Keep all existing DOM element references as they are essential)
    let scheduleTitleElement, tablesContainer, tableTabs, nameModal, nameModalContent, nameModalHeader,
        nameListContainer, newNameInput, sharedScheduleListContainerElement, summaryTableElement,
        summaryTableContainerElement, customMessageBox, fileInputElement, directCopyFullHtmlButtonElement,
        closeNameModalButtonStandardElement, nameListImportFileInputElement, searchNameInputElement,
        sharedScheduleImportFileInputElement, userIdDisplayElement, namePagiTabElement, namePetangTabElement,
        loadingIndicatorModalElement, nameModalTitleElement, generalLoadingIndicatorElement,
        controlsTogglerElement, collapsibleButtonBarsElement, downloadPdfButtonElement, pdfContentElement,
        clearAndResetScheduleBtnElement, manualSaveBtnElement, clearScheduledNamesBtnElement,
        restoreBackupBtnElement, restoreBackupModalElement, restoreBackupModalContentElement,
        restoreBackupModalHeaderElement, closeRestoreBackupModalBtnElement, restoreBackupListContainerElement,
        loadingIndicatorRestoreModalElement;


    // --- Utility Functions ---
    // (Keep showMessage, customPrompt, customConfirm, showGeneralLoading, toggleButtonBarsVisibility, showNameModalLoading, showRestoreBackupModalLoading, ensureDateHeaderRowExists, captureCurrentState, hasStateChanged, _updateLocalStateAfterSave as they are)
    function showMessage(message, type = 'info', duration = 3000) {
        if (!customMessageBox) {
            customMessageBox = document.getElementById('customMessageBox');
            if (!customMessageBox) { console.warn("showMessage: customMessageBox not found. Msg:", message); return; }
        }
        customMessageBox.textContent = message;
        customMessageBox.className = `custom-message-box ${type}`;
        customMessageBox.style.display = 'block';
        setTimeout(() => { if (customMessageBox) customMessageBox.style.display = 'none'; }, duration);
    }

    function customPrompt(message, defaultValue = "") { return prompt(message, defaultValue); }

    function customConfirm(message) {
        return new Promise((resolve) => {
            const confirmModalId = 'customConfirmModal';
            let existingModal = document.getElementById(confirmModalId);
            if (existingModal) existingModal.remove();
            const modal = document.createElement('div');
            modal.id = confirmModalId;
            modal.style.cssText = `display: flex; position: fixed; z-index: 2001; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5); align-items: center; justify-content: center;`;
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `background-color: #fff; padding: 25px; border-radius: 8px; text-align: center; box-shadow: 0 5px 15px rgba(0,0,0,0.3); min-width: 300px; max-width: 90%;`;
            const messageP = document.createElement('p');
            messageP.textContent = message;
            messageP.style.marginBottom = '20px'; messageP.style.fontSize = '1.1em';
            const yesButton = document.createElement('button');
            yesButton.textContent = 'Yes';
            yesButton.style.cssText = `padding: 10px 20px; margin: 0 10px; border-radius: 5px; cursor: pointer; background-color: #28a745; color: white; border: none; font-size: 1em;`;
            const noButton = document.createElement('button');
            noButton.textContent = 'No';
            noButton.style.cssText = `padding: 10px 20px; margin: 0 10px; border-radius: 5px; cursor: pointer; background-color: #dc3545; color: white; border: none; font-size: 1em;`;
            const closeModal = (value) => { modal.remove(); resolve(value); };
            yesButton.onclick = () => closeModal(true);
            noButton.onclick = () => closeModal(false);
            modalContent.appendChild(messageP); modalContent.appendChild(yesButton); modalContent.appendChild(noButton);
            modal.appendChild(modalContent); document.body.appendChild(modal);
        });
    }
    
    function showGeneralLoading(isLoading) {
        if (generalLoadingIndicatorElement) generalLoadingIndicatorElement.style.display = isLoading ? 'flex' : 'none';
    }

    function toggleButtonBarsVisibility() {
        if (!collapsibleButtonBarsElement || !controlsTogglerElement) return;
        const isOpen = collapsibleButtonBarsElement.classList.toggle('open');
        controlsTogglerElement.setAttribute('aria-expanded', isOpen.toString());
        const textSpan = controlsTogglerElement.querySelector('span');
        if (textSpan) textSpan.textContent = isOpen ? 'Hide Controls' : 'Show Controls';
    }

    function showNameModalLoading(isLoading) {
        if (loadingIndicatorModalElement) loadingIndicatorModalElement.style.display = isLoading ? 'flex' : 'none';
    }
    function showRestoreBackupModalLoading(isLoading) {
        if (loadingIndicatorRestoreModalElement) loadingIndicatorRestoreModalElement.style.display = isLoading ? 'flex' : 'none';
    }
    
    function ensureDateHeaderRowExists(tableElement) {
        if (!tableElement || !tableElement.tHead) return;
        let numCols = 0;
        const timeSlotHeaderRow = Array.from(tableElement.tHead.rows).find(row => !row.classList.contains('date-header-row'));
        if (timeSlotHeaderRow) {
            numCols = timeSlotHeaderRow.cells.length;
        } else if (tableElement.rows.length > 0 && tableElement.rows[0].cells.length > 0) {
            const firstMeaningfulRow = Array.from(tableElement.rows).find(r => !r.classList.contains('date-header-row'));
            numCols = firstMeaningfulRow ? firstMeaningfulRow.cells.length : 1;
        } else {
            numCols = 1; // Default to 1 if table is completely empty
        }
        if (numCols === 0 && tableElement.tHead.rows.length > 0) { // If only date row exists, it might have 0 cols
             const firstRowCells = tableElement.tHead.rows[0].cells.length;
             if (firstRowCells > 0) numCols = firstRowCells;
             else numCols = 1; // Still default to 1 if truly empty
        }


        let dateRow = tableElement.tHead.querySelector('tr.date-header-row');
        if (!dateRow) {
            dateRow = document.createElement('tr');
            dateRow.className = 'date-header-row';
            for (let i = 0; i < numCols; i++) {
                const th = document.createElement('th');
                th.className = 'date-header-cell';
                th.contentEditable = 'true';
                dateRow.appendChild(th);
            }
            if (tableElement.tHead.firstChild) {
                tableElement.tHead.insertBefore(dateRow, tableElement.tHead.firstChild);
            } else {
                tableElement.tHead.appendChild(dateRow);
            }
        } else {
            const currentCellCount = dateRow.cells.length;
            if (currentCellCount < numCols) {
                for (let i = currentCellCount; i < numCols; i++) {
                    const th = document.createElement('th');
                    th.className = 'date-header-cell';
                    th.contentEditable = 'true';
                    dateRow.appendChild(th);
                }
            } else if (currentCellCount > numCols && numCols > 0) { // Ensure numCols is positive before removing
                for (let i = currentCellCount - 1; i >= numCols; i--) {
                    if(dateRow.cells[i]) dateRow.cells[i].remove();
                }
            }
        }
    }

    function captureCurrentState() {
        if (!tablesContainer || !scheduleTitleElement) {
            console.warn("captureCurrentState: Critical elements (tablesContainer or scheduleTitleElement) not found. Returning null.");
            return null;
        }
        const state = {
            html: tablesContainer.innerHTML,
            tableMeta: {},
            activeTableId: activeTableId,
            scheduleTitle: scheduleTitleElement.textContent || ''
        };
        tablesContainer.querySelectorAll('table').forEach(table => {
            state.tableMeta[table.id] = {
                name: table.dataset.tableName || table.id,
                rowCount: table.rows.length,
                colCount: table.rows[0]?.cells.length || 0
            };
        });
        return JSON.stringify(state);
    }

    function hasStateChanged(currentStateStringified) {
        if (!isInitialStateSet || !lastSavedState) return true; // If initial state wasn't set or no last save, assume changed
        if (!currentStateStringified) return false; // If current state couldn't be captured, assume no change from last valid
        return currentStateStringified !== lastSavedState;
    }

    function _updateLocalStateAfterSave(docId, scheduleName, isAutoDraft, operationType) {
        const capturedStateStringified = captureCurrentState();
        if (!capturedStateStringified) {
            console.error(`_updateLocalStateAfterSave (${operationType}): Failed to capture current state. Local state NOT updated.`);
            // Do not set lastSavedState to null here, keep the previous valid one.
        } else {
            lastSavedState = capturedStateStringified;
        }
        currentWorkingScheduleDocId = docId; // This can be null if resetting or deleting current
        if (docId) sessionStorage.setItem(LAST_ACTIVE_SCHEDULE_ID_KEY, docId);
        else sessionStorage.removeItem(LAST_ACTIVE_SCHEDULE_ID_KEY); // If docId is null, remove it
        
        const timestamp = new Date().toLocaleTimeString();
        console.log(`%cStateUpdate (${operationType}): ID: ${docId || 'N/A'}, Name: "${scheduleName || 'N/A'}", Draft: ${isAutoDraft}. lastSavedState updated. Time: ${timestamp}`, "color: blue; font-weight: bold;");

        if (operationType === "explicit-save" && scheduleName) showMessage(`Shared schedule "${scheduleName}" saved! (ID: ${docId})`, 'success');
        else if (operationType === "manual-save" && scheduleName) showMessage(`Page "${scheduleName + (isAutoDraft ? " (Draft)" : "")}" saved! (ID: ${docId})`, 'success');
        else if (operationType === "load" && scheduleName) showMessage(`Schedule "${scheduleName + (isAutoDraft ? " (Draft)" : "")}" loaded!`, 'success');
        else if (operationType === "restore-from-backup" && scheduleName) showMessage(`Backup "${scheduleName}" loaded into view. Save to make changes permanent.`, 'info', 5000);
        // Add other relevant messages for reset, delete-current etc. if needed
    }


    // --- Firestore Interaction Functions (Shared Names) ---
    // (Keep saveSharedNameListToFirestore, addNameToSharedSessionInFirestore, deleteNameFromSharedSessionInFirestore, listenToSharedNameList as they are)
    async function saveSharedNameListToFirestore(session, namesArray) {
        if (!fbDb || !fbIsAuthReady) { showMessage("Firebase not ready.", "error"); return; }
        showNameModalLoading(true);
        const uniqueSortedNames = [...new Set(namesArray.map(n => String(n||'').trim()).filter(n => n))].sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));
        if (!appId || appId === 'default-shared-scheduler-app') { showMessage("Config error: App ID missing.", "error"); showNameModalLoading(false); return; }
        const docRef = doc(fbDb, "artifacts", appId, "public/data/sharedNameLists", session);
        try {
            await setDoc(docRef, { names: uniqueSortedNames, lastUpdatedBy: fbUserId || "anonymous", updatedAt: serverTimestamp() });
            showMessage(`Shared name list for ${session} updated.`, "success");
        } catch (error) { console.error(`Error saving shared list to ${session}:`, error); showMessage(`Failed to save. Error: ${error.message}`, "error"); }
        finally { showNameModalLoading(false); }
    }
    async function addNameToSharedSessionInFirestore(name) {
        if (!fbDb || !fbIsAuthReady) { showMessage("Firebase not ready.", "error"); return; }
        const trimmedName = String(name || '').trim();
        if (!trimmedName) { showMessage("Name cannot be empty.", "info"); return; }
        showNameModalLoading(true);
        const sessionNames = currentNameListSession === 'pagi' ? namesPagiShared : namesPetangShared;
        if (sessionNames.map(n => String(n || '').toLowerCase()).includes(trimmedName.toLowerCase())) { showMessage(`"${trimmedName}" already exists.`, "info"); showNameModalLoading(false); return; }
        if (!appId || appId === 'default-shared-scheduler-app') { showMessage("Config error: App ID missing.", "error"); showNameModalLoading(false); return; }
        const updatedNames = [...sessionNames, trimmedName].sort((a, b) => String(a).localeCompare(String(b), undefined, { sensitivity: 'base' }));
        const docRef = doc(fbDb, "artifacts", appId, "public/data/sharedNameLists", currentNameListSession);
        try {
            await setDoc(docRef, { names: updatedNames, lastUpdatedBy: fbUserId || "anonymous", updatedAt: serverTimestamp() });
            if(newNameInput) { newNameInput.value = ''; newNameInput.focus(); }
        } catch (error) { console.error(`Error adding name:`, error); showMessage(`Failed to add. Error: ${error.message}`, "error"); }
        finally { showNameModalLoading(false); }
    }
    async function deleteNameFromSharedSessionInFirestore(nameToDelete) {
        if (!fbDb || !fbIsAuthReady) { showMessage("Firebase not ready.", "error"); return; }
        const nameToDeleteStr = String(nameToDelete || '');
        if (await customConfirm(`Delete "${nameToDeleteStr}" from shared ${currentNameListSession} session? This also removes it from tables.`)) {
            showNameModalLoading(true);
            if (!appId || appId === 'default-shared-scheduler-app') { showMessage("Config error: App ID missing.", "error"); showNameModalLoading(false); return; }
            const currentNames = currentNameListSession === 'pagi' ? namesPagiShared : namesPetangShared;
            const updatedNames = currentNames.filter(name => String(name || '') !== nameToDeleteStr);
            const docRef = doc(fbDb, "artifacts", appId, "public/data/sharedNameLists", currentNameListSession);
            try {
                await setDoc(docRef, { names: updatedNames, lastUpdatedBy: fbUserId || "anonymous", updatedAt: serverTimestamp() });
                tablesContainer.querySelectorAll('table').forEach(table => {
                    table.querySelectorAll('tbody td, tbody th, .merged-cell-overlay').forEach(cell => {
                        const cellText = cell.textContent.trim(); const parts = cellText.split(' // ');
                        let mainContent = parts[0]; const remarkContent = parts.length > 1 ? ` // ${parts.slice(1).join(' // ')}` : '';
                        const wordsInMain = mainContent.split(/\s+/);
                        // More robust deletion: remove the exact name, even if it's part of a multi-name cell, or if it has a star.
                        const newWordsInMain = wordsInMain.filter(word => {
                            const cleanWord = word.startsWith('*') ? word.substring(1) : word;
                            return cleanWord.toLowerCase() !== nameToDeleteStr.toLowerCase();
                        });
                        const newMainContent = newWordsInMain.join(' ').trim();
                        cell.textContent = (newMainContent || remarkContent) ? (newMainContent + remarkContent).trim() : '';
                    });
                });
                rebuildAndRenderSummary();
                if (selectedNameFromList === nameToDeleteStr) clearNameSelection();
            } catch (error) { console.error(`Error deleting name:`, error); showMessage(`Failed to delete. Error: ${error.message}`, "error"); }
            finally { showNameModalLoading(false); }
        }
    }
    function listenToSharedNameList(sessionToListen) {
        if (!fbDb || !fbIsAuthReady) { console.warn(`listenToSharedNameList (${sessionToListen}): Firestore not ready.`); return () => {}; }
        if (!appId || appId === 'default-shared-scheduler-app') { console.error(`listenToSharedNameList (${sessionToListen}): Invalid appId.`); return () => {}; }
        const docRef = doc(fbDb, "artifacts", appId, "public/data/sharedNameLists", sessionToListen);
        return onSnapshot(docRef, (docSnap) => {
            showNameModalLoading(true);
            const namesFromDb = docSnap.exists() ? (docSnap.data().names || []) : [];
            const sanitizedNames = namesFromDb.map(name => String(name || '').trim()).filter(name => name.length > 0);
            if (sessionToListen === 'pagi') namesPagiShared = sanitizedNames; else namesPetangShared = sanitizedNames;
            if (sessionToListen === currentNameListSession && nameModal?.style.display === 'flex' && searchNameInputElement) renderNameListFromFirestore(searchNameInputElement.value);
            rebuildAndRenderSummary(); showNameModalLoading(false);
        }, (error) => { console.error(`Error listening to ${sessionToListen} names:`, error); showMessage(`Error fetching ${sessionToListen} names.`, "error"); showNameModalLoading(false); });
    }

    // --- Firestore Interaction Functions (Schedules & Backups) ---
    // (Keep _saveBackupForSchedule, saveSharedScheduleToFirestore, autoSaveCurrentSchedule, manualSaveCurrentPage, loadAndRenderSharedSchedulesFromFirestore, renderSharedScheduleList, loadSelectedSharedScheduleFromFirestore, loadLatestSharedScheduleAsDefault, confirmAndDeleteSharedScheduleFromFirestore, exportAllSharedSchedulesFromFirestore, handleSharedSchedulesImport as they are)
    async function _saveBackupForSchedule(liveDocId, liveScheduleParsedState, liveScheduleNameForBackup, isOriginalAutoDraft) {
        if (!fbDb || !fbIsAuthReady || !liveDocId || !liveScheduleParsedState) {
            console.warn("Backup: Missing critical data for backup.", { liveDocId, liveScheduleParsedState, fbReady: fbIsAuthReady });
            return;
        }

        const backupScheduleData = {
            name: `${liveScheduleNameForBackup} - Backup`,
            html: liveScheduleParsedState.html,
            meta: liveScheduleParsedState.tableMeta,
            activeTableId: liveScheduleParsedState.activeTableId,
            scheduleTitle: liveScheduleParsedState.scheduleTitle,
            lastUpdatedAt: serverTimestamp(),
            lastUpdatedBy: fbUserId || "anonymous",
            isAutoDraft: isOriginalAutoDraft,
            isBackup: true,
            originalDocId: liveDocId,
            originalDocName: liveScheduleNameForBackup
        };

        try {
            const q = query(collection(fbDb, "artifacts", appId, "public/data/sharedSchedules"),
                where("isBackup", "==", true),
                where("originalDocId", "==", liveDocId),
                limit(1));
            const querySnapshot = await getDocs(q);

            if (!querySnapshot.empty) {
                const backupDocRef = querySnapshot.docs[0].ref;
                backupScheduleData.createdAt = querySnapshot.docs[0].data().createdAt || serverTimestamp(); // Preserve original creation if exists
                await updateDoc(backupDocRef, backupScheduleData);
                console.log(`Backup updated for originalDocId: ${liveDocId}`);
            } else {
                // Try to get createdAt from the live document if this is the first backup
                const liveDocSnap = await getDoc(doc(fbDb, "artifacts", appId, "public/data/sharedSchedules", liveDocId));
                backupScheduleData.createdAt = liveDocSnap.exists() && liveDocSnap.data().createdAt ? liveDocSnap.data().createdAt : serverTimestamp();
                await addDoc(collection(fbDb, "artifacts", appId, "public/data/sharedSchedules"), backupScheduleData);
                console.log(`Backup created for originalDocId: ${liveDocId}`);
            }
        } catch (error) {
            console.error("Error during backup operation:", error);
            showMessage(`Backup failed: ${error.message}`, 'error', 4000);
        }
    }

    async function saveSharedScheduleToFirestore() {
        if (!fbDb || !fbIsAuthReady) { showMessage("Firebase not ready.", "error"); return; }
        if (!tablesContainer || tablesContainer.children.length === 0) { showMessage('No data to save.', 'info'); return; }
        const scheduleNameInput = customPrompt('Enter name for this shared schedule:', `Shared Schedule ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`);
        if (!scheduleNameInput || scheduleNameInput.trim() === "") { showMessage('Save cancelled or name empty.', 'info'); return; }
        
        const scheduleName = scheduleNameInput.trim();
        isAutoSaving = true; showGeneralLoading(true); // Use isAutoSaving to prevent concurrent saves
        const currentFullStateStringified = captureCurrentState();
        if (!currentFullStateStringified) { showMessage('Error capturing state.', 'error'); isAutoSaving = false; showGeneralLoading(false); return; }
        
        const currentFullState = JSON.parse(currentFullStateStringified);
        const scheduleData = {
            name: scheduleName,
            html: currentFullState.html,
            meta: currentFullState.tableMeta,
            activeTableId: currentFullState.activeTableId,
            scheduleTitle: currentFullState.scheduleTitle,
            createdAt: serverTimestamp(), // Always set for new explicit save
            lastUpdatedAt: serverTimestamp(),
            lastUpdatedBy: fbUserId || "anonymous",
            isAutoDraft: false, // Explicit save is not a draft
            isBackup: false
        };

        try {
            const newDocRef = await addDoc(collection(fbDb, "artifacts", appId, "public/data/sharedSchedules"), scheduleData);
            _updateLocalStateAfterSave(newDocRef.id, scheduleData.name, false, "explicit-save");
            await _saveBackupForSchedule(newDocRef.id, currentFullState, scheduleData.name, false); // Backup for the new save
            if (sharedScheduleListContainerElement?.style.display === 'block') await loadAndRenderSharedSchedulesFromFirestore(); // Refresh list if open
        } catch (error) { console.error("Error saving shared schedule:", error); showMessage(`Failed to save. Error: ${error.message}`, "error"); }
        finally { isAutoSaving = false; showGeneralLoading(false); }
    }

    async function autoSaveCurrentSchedule() {
        if (!fbDb || !fbIsAuthReady || isAutoSaving || !tablesContainer || tablesContainer.children.length === 0 || !isInitialStateSet) return;
        
        const currentStateStringified = captureCurrentState();
        if (currentStateStringified === null) {
            console.warn("AutoSave: Failed to capture current state. Skipping auto-save cycle.");
            return;
        }
        if (!hasStateChanged(currentStateStringified)) {
            // console.log("AutoSave: No changes detected.");
            return;
        }
        
        isAutoSaving = true; // Block other saves
        console.log(`AutoSave: Changes detected. DocID: ${currentWorkingScheduleDocId || 'NEW DRAFT'}`);
        
        try {
            const currentState = JSON.parse(currentStateStringified);
            const scheduleContentToSave = {
                html: currentState.html,
                meta: currentState.tableMeta,
                activeTableId: currentState.activeTableId,
                scheduleTitle: currentState.scheduleTitle,
                isBackup: false // Autosaves are not backups themselves
            };

            let savedDocId = currentWorkingScheduleDocId;
            let savedScheduleName = "";
            let savedIsAutoDraft = true; // Default for autosaves

            if (!currentWorkingScheduleDocId) { // No current document, create a new auto-draft
                savedScheduleName = `Autosaved Draft (${fbUserId ? fbUserId.substring(0, 5) : 'anon'}...) - ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString([], {hour12: false, hour: '2-digit', minute: '2-digit'})}`;
                const scheduleData = { name: savedScheduleName, ...scheduleContentToSave, createdAt: serverTimestamp(), lastUpdatedAt: serverTimestamp(), lastUpdatedBy: fbUserId || "anonymous", isAutoDraft: true };
                const newDocRef = await addDoc(collection(fbDb, "artifacts", appId, "public/data/sharedSchedules"), scheduleData);
                savedDocId = newDocRef.id;
                _updateLocalStateAfterSave(savedDocId, savedScheduleName, true, "auto-draft-created");
            } else { // Update existing document
                const docRef = doc(fbDb, "artifacts", appId, "public/data/sharedSchedules", currentWorkingScheduleDocId);
                const docSnap = await getDoc(docRef);
                if (!docSnap.exists()) { // Document disappeared
                    console.warn(`AutoSave: Doc ID ${currentWorkingScheduleDocId} not found. Creating new draft.`);
                    _updateLocalStateAfterSave(null, "Previous Draft Lost", true, "doc-not-found-during-autosave");
                    currentWorkingScheduleDocId = null; // Reset, will create new draft next cycle if changes persist
                    isAutoSaving = false;
                    return; // Exit and let next cycle handle new draft creation
                }
                savedScheduleName = docSnap.data().name;
                savedIsAutoDraft = typeof docSnap.data().isAutoDraft === 'boolean' ? docSnap.data().isAutoDraft : true; // Preserve draft status
                const scheduleDataForUpdate = { ...scheduleContentToSave, name: savedScheduleName, /* createdAt should not be updated */ lastUpdatedAt: serverTimestamp(), lastUpdatedBy: fbUserId || "anonymous", isAutoDraft: savedIsAutoDraft };
                await updateDoc(docRef, scheduleDataForUpdate); // Use updateDoc to avoid overwriting createdAt
                _updateLocalStateAfterSave(currentWorkingScheduleDocId, savedScheduleName, savedIsAutoDraft, "auto-save-update");
            }
            // Always try to save/update a backup for the current working document (draft or not)
            if (savedDocId) {
                 await _saveBackupForSchedule(savedDocId, currentState, savedScheduleName, savedIsAutoDraft);
            }

        } catch (error) {
            console.error("Auto-save error:", error);
            // Potentially clear currentWorkingScheduleDocId if save failed badly, to attempt new draft next time
            // showMessage("Auto-save failed. Retrying later.", "error", 2000); // Avoid spamming user
        }
        finally { isAutoSaving = false; } // Release lock
    }

    async function manualSaveCurrentPage() {
        if (!fbDb || !fbIsAuthReady) { showMessage("Firebase not ready.", "error"); return; }
        if (!tablesContainer || tablesContainer.children.length === 0) { showMessage('No data to save.', 'info'); return; }
        if (isAutoSaving) { showMessage('Operation in progress. Please wait.', 'info'); return; } // Prevent manual save during auto-save
        
        showGeneralLoading(true);
        isAutoSaving = true; // Block other saves
        const currentStateStringified = captureCurrentState();

        if (!currentStateStringified) {
            showMessage('Error capturing state for save.', 'error');
            isAutoSaving = false;
            showGeneralLoading(false);
            return;
        }
        
        try {
            const currentState = JSON.parse(currentStateStringified);
            const scheduleContentToSave = {
                html: currentState.html,
                meta: currentState.tableMeta,
                activeTableId: currentState.activeTableId,
                scheduleTitle: currentState.scheduleTitle,
                isBackup: false
            };
            
            let savedDocId = currentWorkingScheduleDocId;
            let finalScheduleName = "";
            let finalIsAutoDraft = false; // By default, manual save makes it non-draft

            if (currentWorkingScheduleDocId) { // If there's a current document ID
                const docRef = doc(fbDb, "artifacts", appId, "public/data/sharedSchedules", currentWorkingScheduleDocId);
                const docSnap = await getDoc(docRef);

                if (!docSnap.exists()) { // If the document disappeared
                    showMessage(`Error: Previously loaded document (ID: ${currentWorkingScheduleDocId}) not found. This save will create a NEW schedule.`, "warning", 7000);
                    currentWorkingScheduleDocId = null; // This save will now be a new document
                    _updateLocalStateAfterSave(null, "Previous Doc Lost", false, "manual-save-doc-not-found"); // Update local state to reflect no current doc
                    savedDocId = null; // Ensure it proceeds to new doc logic
                } else { // Document exists, update it
                    let currentScheduleName = docSnap.data().name;
                    let currentIsAutoDraft = typeof docSnap.data().isAutoDraft === 'boolean' ? docSnap.data().isAutoDraft : false; // Default to false if undefined

                    if (currentIsAutoDraft) { // If saving an existing auto-draft
                        const newNamePrompt = customPrompt(`This is an autosaved draft ("${currentScheduleName}"). Enter a new name to save it permanently (recommended), or cancel to update the draft with its current name.`, currentScheduleName.replace(/Autosaved Draft /i, "").replace(/\([\w\s.-]+\)\s*-\s*\d{1,2}\/\d{1,2}\/\d{4}.*/i, "").trim());
                        if (newNamePrompt && newNamePrompt.trim() !== "") {
                            finalScheduleName = newNamePrompt.trim();
                            finalIsAutoDraft = false; // Becomes a non-draft
                        } else { // User cancelled prompt or entered empty, keep draft name and status
                            finalScheduleName = currentScheduleName;
                            finalIsAutoDraft = true; // Stays a draft
                        }
                    } else { // Saving an existing non-draft
                        finalScheduleName = currentScheduleName; // Keep its name
                        finalIsAutoDraft = false; // Stays non-draft
                    }
                    // Update existing document, preserving createdAt
                    const scheduleDataForUpdate = { ...scheduleContentToSave, name: finalScheduleName, lastUpdatedAt: serverTimestamp(), lastUpdatedBy: fbUserId || "anonymous", /* createdAt: docSnap.data().createdAt, */ isAutoDraft: finalIsAutoDraft };
                    await updateDoc(docRef, scheduleDataForUpdate); // updateDoc won't overwrite createdAt if not provided
                    _updateLocalStateAfterSave(currentWorkingScheduleDocId, finalScheduleName, finalIsAutoDraft, "manual-save");
                    await _saveBackupForSchedule(currentWorkingScheduleDocId, currentState, finalScheduleName, finalIsAutoDraft);
                    if (sharedScheduleListContainerElement?.style.display === 'block') await loadAndRenderSharedSchedulesFromFirestore();
                    isAutoSaving = false; showGeneralLoading(false); return; // Exit after update
                }
            }
            
            // If no currentWorkingScheduleDocId (either from start or because previous was lost)
            // Create a new schedule document
            const defaultNewName = `My Schedule - ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
            const scheduleNameInput = customPrompt('Enter name for this new schedule:', defaultNewName);
            if (!scheduleNameInput || scheduleNameInput.trim() === "") {
                showMessage('Save cancelled or name empty.', 'info');
                isAutoSaving = false; showGeneralLoading(false); return;
            }
            finalScheduleName = scheduleNameInput.trim();
            finalIsAutoDraft = false; // New manual save is not a draft
            const scheduleData = { name: finalScheduleName, ...scheduleContentToSave, createdAt: serverTimestamp(), lastUpdatedAt: serverTimestamp(), lastUpdatedBy: fbUserId || "anonymous", isAutoDraft: finalIsAutoDraft };
            const newDocRef = await addDoc(collection(fbDb, "artifacts", appId, "public/data/sharedSchedules"), scheduleData);
            savedDocId = newDocRef.id; // Get the new ID
            _updateLocalStateAfterSave(savedDocId, finalScheduleName, finalIsAutoDraft, "manual-save"); // Update local state with new ID
            await _saveBackupForSchedule(savedDocId, currentState, finalScheduleName, finalIsAutoDraft);
            if (sharedScheduleListContainerElement?.style.display === 'block') await loadAndRenderSharedSchedulesFromFirestore();

        } catch (error) { console.error("Error during manual save:", error); showMessage(`Failed to save. Error: ${error.message}`, "error"); }
        finally { isAutoSaving = false; showGeneralLoading(false); } // Release lock
    }

    async function loadAndRenderSharedSchedulesFromFirestore() {
        if (!fbDb || !fbIsAuthReady) { showMessage("Firebase not ready.", "error"); if (sharedScheduleListContainerElement) sharedScheduleListContainerElement.innerHTML = '<p>Connect to Firebase.</p>'; return; }
        if (!sharedScheduleListContainerElement) return;
        showGeneralLoading(true);
        sharedScheduleListContainerElement.innerHTML = '<p>Loading schedules...</p>';
        try {
            let querySnapshot;
            try {
                // Primary query: non-backups, ordered by lastUpdatedAt
                let q = query(collection(fbDb, "artifacts", appId, "public/data/sharedSchedules"),
                              where("isBackup", "!=", true), // Exclude backups from this list
                              orderBy("lastUpdatedAt", "desc"));
                querySnapshot = await getDocs(q);
            } catch (error) {
                console.warn("Error loading schedules (lastUpdatedAt order failed, trying createdAt):", error);
                if (error.message.toLowerCase().includes("index")) showMessage("Loading (fallback sort)...", "info", 4000);
                else showMessage("Error loading. Trying fallback...", "info", 4000);
                // Fallback query: non-backups, ordered by createdAt
                let qFallback = query(collection(fbDb, "artifacts", appId, "public/data/sharedSchedules"),
                                      where("isBackup", "!=", true), // Still exclude backups
                                      orderBy("createdAt", "desc"));
                querySnapshot = await getDocs(qFallback);
            }

            const schedules = [];
            querySnapshot.forEach((docSnap) => {
                // Double check isBackup is false or undefined (older data might not have it)
                const data = docSnap.data();
                if (data.isBackup !== true) {
                    schedules.push({ id: docSnap.id, ...data });
                }
            });
            renderSharedScheduleList(schedules); // This function already sorts by date client-side
            sharedScheduleListContainerElement.style.display = 'block';
        } catch (finalError) {
             console.error("Error loading schedules (final attempt):", finalError);
             showMessage(`Failed to load schedules. Error: ${finalError.message}`, "error");
             sharedScheduleListContainerElement.innerHTML = `<p>Error loading schedules. Check console.</p>`;
        } finally {
            showGeneralLoading(false);
        }
    }

    function renderSharedScheduleList(schedulesArray) {
        if (!sharedScheduleListContainerElement) return;
        sharedScheduleListContainerElement.innerHTML = '';
        // Sort by lastUpdatedAt descending (most recent first), then by createdAt if lastUpdatedAt is same or missing
        const sortedSchedules = schedulesArray.sort((a, b) => {
            const dateA = a.lastUpdatedAt?.toDate ? a.lastUpdatedAt.toDate() : (a.createdAt?.toDate ? a.createdAt.toDate() : new Date(0));
            const dateB = b.lastUpdatedAt?.toDate ? b.lastUpdatedAt.toDate() : (b.createdAt?.toDate ? b.createdAt.toDate() : new Date(0));
            if (dateB - dateA !== 0) return dateB - dateA;
            // Fallback to createdAt if lastUpdatedAt is the same or missing for one
            const createdA = a.createdAt?.toDate ? a.createdAt.toDate() : new Date(0);
            const createdB = b.createdAt?.toDate ? b.createdAt.toDate() : new Date(0);
            return createdB - createdA;
        });

        if (!sortedSchedules || sortedSchedules.length === 0) { sharedScheduleListContainerElement.innerHTML = '<p>No shared schedules saved yet.</p>'; return; }
        
        sortedSchedules.forEach(schedule => {
            const itemDiv = document.createElement('div'); itemDiv.className = 'shared-schedule-item';
            
            const mainLineDiv = document.createElement('div'); mainLineDiv.className = 'schedule-item-main-line';
            
            let dateToShow = 'Date N/A';
            if (schedule.lastUpdatedAt?.toDate) dateToShow = `Updated: ${schedule.lastUpdatedAt.toDate().toLocaleString()}`;
            else if (schedule.createdAt?.toDate) dateToShow = `Created: ${schedule.createdAt.toDate().toLocaleString()}`;
            
            const updatedByText = schedule.lastUpdatedBy ? ` (by ${schedule.lastUpdatedBy.substring(0,8)}...)` : '';
            const draftSuffix = schedule.isAutoDraft ? " (Draft)" : "";
            const displayName = `${schedule.name}${draftSuffix}`;

            const nameSpan = document.createElement('span');
            nameSpan.dataset.scheduleId = schedule.id;
            nameSpan.title = `Load: ${displayName}`;
            nameSpan.textContent = `${displayName}${updatedByText}`;
            mainLineDiv.appendChild(nameSpan);

            const deleteButton = document.createElement('button');
            deleteButton.dataset.scheduleId = schedule.id;
            deleteButton.title = `Delete '${displayName}'`;
            deleteButton.textContent = 'Delete';
            mainLineDiv.appendChild(deleteButton);
            
            itemDiv.appendChild(mainLineDiv);

            const detailsDiv = document.createElement('div');
            detailsDiv.className = 'schedule-item-details';
            const dateSpan = document.createElement('span');
            dateSpan.className = 'schedule-date';
            dateSpan.textContent = dateToShow;
            detailsDiv.appendChild(dateSpan);
            itemDiv.appendChild(detailsDiv);
            
            sharedScheduleListContainerElement.appendChild(itemDiv);
        });
    }

    async function loadSelectedSharedScheduleFromFirestore(scheduleDocId, isDefaultLoad = false) {
        if (!fbDb || !fbIsAuthReady) {
            if (!isDefaultLoad) showMessage("Firebase not ready.", "error");
            else console.warn("loadSelected: Firebase not ready for default load.");
            return false;
        }
        if (!tablesContainer || !tableTabs || !scheduleTitleElement) {
            console.error("loadSelected: Critical DOM elements missing.");
            return false;
        }
        showGeneralLoading(true);
        try {
            const docRef = doc(fbDb, "artifacts", appId, "public/data/sharedSchedules", scheduleDocId);
            const docSnap = await getDoc(docRef);
            if (docSnap.exists()) {
                const scheduleData = docSnap.data();
                if (scheduleData.isBackup === true) { // Explicitly check if it's a backup
                    console.warn(`loadSelected: Attempted to load a backup document (ID: ${scheduleDocId}). Operation aborted.`);
                    if (!isDefaultLoad) showMessage("Cannot load a backup file directly from this list. Use 'Restore Backup'.", "error");
                    _updateLocalStateAfterSave(null, null, false, "attempted-backup-load"); // Clear current working doc
                    if (scheduleDocId === sessionStorage.getItem(LAST_ACTIVE_SCHEDULE_ID_KEY)) sessionStorage.removeItem(LAST_ACTIVE_SCHEDULE_ID_KEY);
                    return false;
                }

                if (typeof scheduleData.scheduleTitle === 'string') {
                    scheduleTitleElement.textContent = scheduleData.scheduleTitle;
                    localStorage.setItem(SCHEDULE_TITLE_KEY, scheduleData.scheduleTitle);
                }
                tablesContainer.innerHTML = scheduleData.html;
                const tableMeta = scheduleData.meta || {};
                tableTabs.innerHTML = '';
                tablesContainer.querySelectorAll('table').forEach(table => {
                    ensureDateHeaderRowExists(table);
                    const id = table.id;
                    const metaInfo = tableMeta[id] || {};
                    const name = metaInfo.name || `Sheet ${tableTabs.children.length + 1}`;
                    table.dataset.tableName = name;
                    addTabButton(id, name);
                    table.querySelectorAll('td, th, .merged-cell-overlay').forEach(cell => cell.contentEditable = 'true');
                });
                activeTableId = scheduleData.activeTableId || tablesContainer.querySelector('table')?.id || 'tbl_1';
                if (document.getElementById(activeTableId)) switchTable(activeTableId);
                else if (tablesContainer.querySelector('table')) switchTable(tablesContainer.querySelector('table').id);
                else { console.warn("Loaded schedule has no tables. Adding new."); addNewTable(true); }
                
                _updateLocalStateAfterSave(scheduleDocId, scheduleData.name, scheduleData.isAutoDraft, "load");
                if (isDefaultLoad) console.log(`Default/Session schedule "${scheduleData.name}" loaded.`);
                if (sharedScheduleListContainerElement) sharedScheduleListContainerElement.style.display = 'none'; // Hide list after load
                rebuildAndRenderSummary();
                updateAllMergeOverlays(); // Ensure merges are visually correct after load
                return true;
            } else {
                console.warn(`loadSelected: Doc ID "${scheduleDocId}" not found.`);
                if (!isDefaultLoad) showMessage(`Schedule ID "${scheduleDocId}" not found.`, "error");
                _updateLocalStateAfterSave(null, null, false, "doc-not-found-on-load"); // Clear current working doc
                if (scheduleDocId === sessionStorage.getItem(LAST_ACTIVE_SCHEDULE_ID_KEY)) sessionStorage.removeItem(LAST_ACTIVE_SCHEDULE_ID_KEY);
                return false;
            }
        } catch (error) {
            console.error(`loadSelected: Error loading schedule ID ${scheduleDocId}:`, error);
            if (!isDefaultLoad) showMessage(`Failed to load. Error: ${error.message}`, "error");
            _updateLocalStateAfterSave(null, null, false, "load-error"); // Clear current working doc on error
            return false;
        } finally {
            showGeneralLoading(false);
        }
    }
    
    async function loadLatestSharedScheduleAsDefault() {
        if (!fbDb || !fbIsAuthReady) {
            console.log("loadLatest: Firebase not ready.");
            // If Firebase isn't ready, proceed to setupInitialTableState to show *something*
            setupInitialTableState();
            lastSavedState = captureCurrentState(); // Capture this initial state
            isInitialStateSet = true;
            if (lastSavedState === null) console.error("CRITICAL: Initial state capture failed (Firebase not ready).");
            rebuildAndRenderSummary();
            return false; // Indicate that loading from Firebase failed
        }
        showGeneralLoading(true);
        let loadedSuccessfully = false;

        try {
            const lastActiveIdFromSession = sessionStorage.getItem(LAST_ACTIVE_SCHEDULE_ID_KEY);
            if (lastActiveIdFromSession) {
                console.log(`loadLatest: Attempting to load last active schedule (ID: ${lastActiveIdFromSession})`);
                const loadedFromSession = await loadSelectedSharedScheduleFromFirestore(lastActiveIdFromSession, true);
                if (loadedFromSession) {
                    console.log("loadLatest: Successfully loaded last active schedule");
                    showGeneralLoading(false);
                    isInitialStateSet = true; // State is now set from loaded schedule
                    // lastSavedState is updated by _updateLocalStateAfterSave inside loadSelectedSharedScheduleFromFirestore
                    return true;
                } else {
                    console.warn(`loadLatest: Failed to load last active schedule (ID: ${lastActiveIdFromSession}). Will try latest from DB.`);
                    sessionStorage.removeItem(LAST_ACTIVE_SCHEDULE_ID_KEY); // Remove invalid session ID
                }
            }

            const MAX_CANDIDATES_TO_CHECK = 5;
            let candidates = [];
            try {
                console.log("loadLatest: Querying Firestore for latest non-backup schedules");
                const qPrimary = query(collection(fbDb, "artifacts", appId, "public/data/sharedSchedules"),
                    where("isBackup", "!=", true), // Ensure we only get main schedules
                    orderBy("lastUpdatedAt", "desc"),
                    limit(MAX_CANDIDATES_TO_CHECK));
                const primarySnapshot = await getDocs(qPrimary);
                primarySnapshot.forEach(docSnap => candidates.push(docSnap));
                console.log(`loadLatest: Found ${candidates.length} candidate schedules (primary query).`);
            } catch (error) {
                console.warn("loadLatest (lastUpdatedAt query failed, trying createdAt):", error);
                const qFallback = query(collection(fbDb, "artifacts", appId, "public/data/sharedSchedules"),
                    where("isBackup", "!=", true),
                    orderBy("createdAt", "desc"),
                    limit(MAX_CANDIDATES_TO_CHECK * 2)); // Get more for fallback sorting
                const fallbackSnapshot = await getDocs(qFallback);
                const fallbackCandidates = [];
                fallbackSnapshot.forEach(docSnap => fallbackCandidates.push(docSnap));
                
                // Combine and sort client-side if fallback was used
                fallbackCandidates.forEach(fc => {
                    if (!candidates.find(c => c.id === fc.id)) candidates.push(fc);
                });
                candidates.sort((a, b) => { // Ensure correct sorting if combined
                    const dateA = a.data().lastUpdatedAt?.toDate ? a.data().lastUpdatedAt.toDate() : (a.data().createdAt?.toDate ? a.data().createdAt.toDate() : new Date(0));
                    const dateB = b.data().lastUpdatedAt?.toDate ? b.data().lastUpdatedAt.toDate() : (b.data().createdAt?.toDate ? b.data().createdAt.toDate() : new Date(0));
                    return dateB - dateA;
                });
                candidates = candidates.slice(0, MAX_CANDIDATES_TO_CHECK); // Limit after sort
                console.log(`loadLatest: Found ${candidates.length} candidate schedules (after fallback & sort).`);
            }

            for (const docSnap of candidates) {
                console.log(`loadLatest: Trying to load schedule ${docSnap.id} ('${docSnap.data().name}')`);
                loadedSuccessfully = await loadSelectedSharedScheduleFromFirestore(docSnap.id, true);
                if (loadedSuccessfully) {
                    console.log("loadLatest: Successfully loaded a schedule from DB candidates.");
                    break; 
                } else {
                    console.warn(`loadLatest: Failed to load schedule ${docSnap.id}. Trying next candidate.`);
                }
            }

            if (!loadedSuccessfully) {
                console.log("loadLatest: No suitable non-backup schedule loaded from Firestore candidates.");
            }

        } catch (finalError) {
            console.error("loadLatest (outer try/catch):", finalError);
        } finally {
            showGeneralLoading(false);
        }
        
        if (!loadedSuccessfully) {
            console.log("loadLatest: Fallback - Setting up initial table state as no schedule was loaded from Firebase.");
            setupInitialTableState(); // This will ensure the default HTML template table is active
            lastSavedState = captureCurrentState();
            isInitialStateSet = true;
            if (lastSavedState === null) {
                console.error("CRITICAL: Initial state capture failed after fallback from Firebase load.");
                showMessage("Error: Could not capture initial state.", "error", 7000);
            }
            rebuildAndRenderSummary();
            // Message user appropriately
            const lastActiveIdFromSession = sessionStorage.getItem(LAST_ACTIVE_SCHEDULE_ID_KEY); // Check again, might have been removed
            if (!lastActiveIdFromSession && candidates.length === 0) { // Truly a fresh start or no schedules in DB
                 showMessage('No saved schedule found. Starting with a new schedule.', 'info', 5000);
            } else if (candidates.length > 0 || lastActiveIdFromSession) { // Tried to load something but failed
                 showMessage('Could not load latest schedule. Displaying default. Try "Load Shared".', 'warning', 7000);
            }
        } else {
            isInitialStateSet = true; // If loadedSuccessfully, state is now set.
            // lastSavedState is handled by _updateLocalStateAfterSave within loadSelectedSharedScheduleFromFirestore
        }
        
        return loadedSuccessfully;
    }
    
    async function confirmAndDeleteSharedScheduleFromFirestore(scheduleDocId, scheduleName) {
        if (!fbDb || !fbIsAuthReady) { showMessage("Firebase not ready.", "error"); return; }
        const displayName = scheduleName.includes("(Draft)") ? scheduleName : `${scheduleName}`;
        if (await customConfirm(`Delete "${displayName}" from Cloud? This cannot be undone. (Associated backup will also be deleted)`)) {
            showGeneralLoading(true);
            try {
                // Delete the main schedule document
                await deleteDoc(doc(fbDb, "artifacts", appId, "public/data/sharedSchedules", scheduleDocId));
                
                // Query and delete its associated backup (if any)
                const backupQuery = query(collection(fbDb, "artifacts", appId, "public/data/sharedSchedules"),
                                          where("isBackup", "==", true),
                                          where("originalDocId", "==", scheduleDocId),
                                          limit(1)); // Should only be one backup per original
                const backupSnapshot = await getDocs(backupQuery);
                if (!backupSnapshot.empty) {
                    await deleteDoc(backupSnapshot.docs[0].ref);
                    console.log(`Backup for ${scheduleDocId} also deleted.`);
                }

                // If the deleted schedule was the one currently being worked on
                if (currentWorkingScheduleDocId === scheduleDocId) {
                    _updateLocalStateAfterSave(null, null, false, "deleted-current"); // Clear current working doc
                }
                showMessage(`Schedule "${scheduleName}" and its backup deleted.`, 'success');
                await loadAndRenderSharedSchedulesFromFirestore(); // Refresh the list
            } catch (error) { console.error("Error deleting schedule and/or its backup:", error); showMessage(`Failed to delete. Error: ${error.message}`, "error"); }
            finally { showGeneralLoading(false); }
        }
    }
    async function exportAllSharedSchedulesFromFirestore() {
        if (!fbDb || !fbIsAuthReady) { showMessage("Firebase not ready.", "error"); return; }
        showGeneralLoading(true);
        try {
            // Query for non-backup schedules, ordered by creation date
            const q = query(collection(fbDb, "artifacts", appId, "public/data/sharedSchedules"),
                            where("isBackup", "!=", true), // Only export main schedules
                            orderBy("createdAt", "desc"));
            const querySnapshot = await getDocs(q); const schedulesToExport = [];
            querySnapshot.forEach((docSnap) => {
                const data = docSnap.data();
                schedulesToExport.push({
                    name: data.name,
                    html: data.html,
                    meta: data.meta,
                    activeTableId: data.activeTableId,
                    scheduleTitle: data.scheduleTitle || null,
                    createdAt: data.createdAt?.toDate ? data.createdAt.toDate().toISOString() : null,
                    lastUpdatedAt: data.lastUpdatedAt?.toDate ? data.lastUpdatedAt.toDate().toISOString() : null,
                    lastUpdatedBy: data.lastUpdatedBy || null,
                    isAutoDraft: typeof data.isAutoDraft === 'boolean' ? data.isAutoDraft : undefined // Export if defined
                });
            });
            if (schedulesToExport.length === 0) { showMessage('No (non-backup) schedules to export.', 'info'); showGeneralLoading(false); return; }
            const blob = new Blob([JSON.stringify(schedulesToExport, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob); const a = document.createElement('a');
            a.href = url; a.download = `shared_schedules_${appId}_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
            showMessage('All non-backup schedules exported!', 'success');
        } catch (error) { console.error("Error exporting schedules:", error); showMessage(`Failed to export. Error: ${error.message}`, "error"); }
        finally { showGeneralLoading(false); }
    }
    async function handleSharedSchedulesImport(event) {
        if (!fbDb || !fbIsAuthReady) { showMessage("Firebase not ready.", "error"); return; }
        const file = event.target.files[0];
        if (!file) { showMessage('No file selected.', 'info'); return; }
        if (file.type !== 'application/json') { showMessage('Invalid file type (.json only).', 'error'); event.target.value = ''; return; }
        showGeneralLoading(true);
        const reader = new FileReader();
        reader.onload = async (e) => {
            try {
                const importedSchedulesData = JSON.parse(e.target.result);
                if (!Array.isArray(importedSchedulesData)) { showMessage('Invalid file format (expected an array of schedules).', 'error'); return; }
                let importedCount = 0, skippedCount = 0;
                const schedulesCollectionRef = collection(fbDb, "artifacts", appId, "public/data/sharedSchedules");
                
                for (const schedule of importedSchedulesData) {
                    // Basic validation of the schedule object
                    if (schedule && typeof schedule.name === 'string' && typeof schedule.html === 'string' && typeof schedule.meta === 'object' && (typeof schedule.activeTableId === 'string' || schedule.activeTableId === null)) {
                        // Check if a non-backup schedule with the same name already exists
                        const q = query(schedulesCollectionRef, where("name", "==", schedule.name), where("isBackup", "!=", true));
                        const existingSnapshot = await getDocs(q);
                        
                        if (!existingSnapshot.empty) { // If schedule with same name exists
                            if (await customConfirm(`Schedule "${schedule.name}" already exists. Overwrite? (The old schedule and its backup will be removed if you overwrite)`)) {
                                // Delete existing schedule(s) and their backups
                                for(const docToDel of existingSnapshot.docs) {
                                    const oldBackupQuery = query(schedulesCollectionRef, where("isBackup", "==", true), where("originalDocId", "==", docToDel.id));
                                    const oldBackupSnapshot = await getDocs(oldBackupQuery);
                                    oldBackupSnapshot.forEach(async oldBackupDoc => await deleteDoc(oldBackupDoc.ref));
                                    await deleteDoc(docToDel.ref); // Delete the old live schedule
                                }
                            } else {
                                skippedCount++; continue; // Skip this schedule
                            }
                        }
                        // Prepare new schedule data for import
                        const newLiveScheduleData = {
                            name: schedule.name,
                            html: schedule.html,
                            meta: schedule.meta,
                            activeTableId: schedule.activeTableId,
                            scheduleTitle: schedule.scheduleTitle || schedule.name, // Fallback for title
                            createdAt: schedule.createdAt ? new Date(schedule.createdAt) : serverTimestamp(), // Use imported or new timestamp
                            lastUpdatedAt: schedule.lastUpdatedAt ? new Date(schedule.lastUpdatedAt) : serverTimestamp(),
                            lastUpdatedBy: schedule.lastUpdatedBy || fbUserId || "anonymous",
                            isAutoDraft: typeof schedule.isAutoDraft === 'boolean' ? schedule.isAutoDraft : false, // Default to false if undefined
                            isBackup: false // Imported schedules are main schedules
                        };
                        const newLiveDocRef = await addDoc(schedulesCollectionRef, newLiveScheduleData); // Add as new document
                        
                        // Create a backup for the newly imported schedule
                        const importedStateForBackup = {
                            html: schedule.html,
                            tableMeta: schedule.meta,
                            activeTableId: schedule.activeTableId,
                            scheduleTitle: schedule.scheduleTitle || schedule.name
                        };
                        await _saveBackupForSchedule(newLiveDocRef.id, importedStateForBackup, schedule.name, newLiveScheduleData.isAutoDraft);
                        importedCount++;
                    } else { console.warn("Skipping invalid schedule object during import:", schedule); skippedCount++; }
                }
                showMessage(`Import complete: ${importedCount} schedules imported/overwritten (with new backups), ${skippedCount} skipped.`, 'success', 5000);
                // Refresh the list if it's visible or if any schedules were imported
                if (sharedScheduleListContainerElement && (sharedScheduleListContainerElement.style.display === 'block' || importedCount > 0)) {
                    await loadAndRenderSharedSchedulesFromFirestore();
                }
            } catch (error) { console.error("Error processing schedule file:", error); showMessage('Error processing file. Check console for details.', 'error', 5000); }
            finally { event.target.value = ''; showGeneralLoading(false); } // Reset file input
        };
        reader.onerror = () => { showMessage('Failed to read file.', 'error'); event.target.value = ''; showGeneralLoading(false); };
        reader.readAsText(file);
    }


    // --- Restore Backup Functions ---
    // (Keep toggleRestoreBackupModalVisibility, loadAndRenderBackupSchedulesFromFirestore, renderBackupScheduleList, loadSelectedBackupIntoView as they are)
    function toggleRestoreBackupModalVisibility() {
        if (!restoreBackupModalElement || !restoreBackupModalContentElement) return;
        const isDisplayed = restoreBackupModalElement.style.display === 'flex';
        if (isDisplayed) {
            restoreBackupModalElement.style.display = 'none';
        } else {
            // Reset modal position if it was dragged
            restoreBackupModalContentElement.style.position = 'relative'; // Or 'static' if it's inside a flex centered modal
            restoreBackupModalContentElement.style.left = 'auto';
            restoreBackupModalContentElement.style.top = 'auto';
            restoreBackupModalContentElement.style.transform = 'none';
            restoreBackupModalElement.style.display = 'flex';
            loadAndRenderBackupSchedulesFromFirestore();
        }
    }

    async function loadAndRenderBackupSchedulesFromFirestore() {
        if (!fbDb || !fbIsAuthReady) {
            console.error("loadAndRenderBackupSchedulesFromFirestore: Firebase not ready.");
            showMessage("Firebase not ready for backup list.", "error");
            if (restoreBackupListContainerElement) restoreBackupListContainerElement.innerHTML = '<p>Connect to Firebase to see backups.</p>';
            return;
        }
        if (!restoreBackupListContainerElement) {
            console.error("loadAndRenderBackupSchedulesFromFirestore: restoreBackupListContainerElement not found.");
            return;
        }

        showRestoreBackupModalLoading(true);
        restoreBackupListContainerElement.innerHTML = '<p>Loading backups...</p>';
        try {
            // Fetch ALL documents from the collection first, then filter client-side
            // This is because Firestore doesn't support inequality filters on multiple fields or combining `!=` with `orderBy` effectively for this case.
            const allSchedulesSnapshot = await getDocs(collection(fbDb, "artifacts", appId, "public/data/sharedSchedules"));
            
            const backupSchedules = [];
            allSchedulesSnapshot.forEach((docSnap) => {
                const data = docSnap.data();
                // Client-side filtering for backups
                if (data.isBackup === true) {
                    backupSchedules.push({ id: docSnap.id, ...data });
                }
            });

            // Sort client-side by lastUpdatedAt descending (most recent first)
            backupSchedules.sort((a, b) => {
                const dateA = a.lastUpdatedAt?.toDate ? a.lastUpdatedAt.toDate() : (a.createdAt?.toDate ? a.createdAt.toDate() : new Date(0));
                const dateB = b.lastUpdatedAt?.toDate ? b.lastUpdatedAt.toDate() : (b.createdAt?.toDate ? b.createdAt.toDate() : new Date(0));
                if (dateB - dateA !== 0) return dateB - dateA;
                const createdA = a.createdAt?.toDate ? a.createdAt.toDate() : new Date(0);
                const createdB = b.createdAt?.toDate ? b.createdAt.toDate() : new Date(0);
                return createdB - createdA;
            });

            renderBackupScheduleList(backupSchedules);
        } catch (error) {
            console.error("Error loading backup schedules:", error);
            showMessage(`Failed to load backups. Error: ${error.message}`, "error");
            if (restoreBackupListContainerElement) restoreBackupListContainerElement.innerHTML = `<p>Error loading backups. Check console.</p>`;
        } finally {
            showRestoreBackupModalLoading(false);
        }
    }

    function renderBackupScheduleList(backupSchedulesArray) {
        if (!restoreBackupListContainerElement) return;
        restoreBackupListContainerElement.innerHTML = '';

        if (!backupSchedulesArray || backupSchedulesArray.length === 0) {
            restoreBackupListContainerElement.innerHTML = '<p>No backups found.</p>';
            return;
        }

        backupSchedulesArray.forEach(backup => {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'backup-schedule-item';

            const mainLineDiv = document.createElement('div');
            mainLineDiv.className = 'schedule-item-main-line';

            const nameSpan = document.createElement('span');
            nameSpan.dataset.backupId = backup.id;
            nameSpan.dataset.originalDocId = backup.originalDocId; // Store original ID if available
            const displayName = backup.name || `Backup for ${backup.originalDocName || 'Unknown Original'}`;
            nameSpan.title = `Restore from: ${displayName}`;
            nameSpan.textContent = displayName;
            mainLineDiv.appendChild(nameSpan);
            
            itemDiv.appendChild(mainLineDiv);

            const detailsDiv = document.createElement('div');
            detailsDiv.className = 'schedule-item-details';

            if (backup.originalDocName) {
                const originalNameSpan = document.createElement('span');
                originalNameSpan.className = 'original-schedule-name';
                originalNameSpan.textContent = `Original: ${backup.originalDocName}`;
                detailsDiv.appendChild(originalNameSpan);
            }
            
            let dateToShow = 'Backup Date N/A';
            if (backup.lastUpdatedAt?.toDate) {
                dateToShow = `Backup Date: ${backup.lastUpdatedAt.toDate().toLocaleString()}`;
            } else if (backup.createdAt?.toDate) { // Fallback to createdAt if lastUpdatedAt is missing
                 dateToShow = `Backup Date (created): ${backup.createdAt.toDate().toLocaleString()}`;
            }
            const dateSpan = document.createElement('span');
            dateSpan.className = 'schedule-date';
            dateSpan.textContent = dateToShow;
            detailsDiv.appendChild(dateSpan);
            
            itemDiv.appendChild(detailsDiv);
            restoreBackupListContainerElement.appendChild(itemDiv);
        });
    }

    async function loadSelectedBackupIntoView(backupDocId) {
        if (!fbDb || !fbIsAuthReady) {
            showMessage("Firebase not ready to restore backup.", "error");
            return;
        }
        if (!tablesContainer || !tableTabs || !scheduleTitleElement) {
            console.error("Restore Backup: Critical DOM elements missing."); return;
        }

        if (!await customConfirm("Load this backup into the editor? Your current unsaved changes will be lost. This does NOT save the backup over the original yet. Use 'Save Page' or 'Save Shared' after reviewing.")) {
            showMessage("Restore cancelled.", "info");
            return;
        }

        showGeneralLoading(true);
        try {
            const backupDocRef = doc(fbDb, "artifacts", appId, "public/data/sharedSchedules", backupDocId);
            const backupDocSnap = await getDoc(backupDocRef);

            if (backupDocSnap.exists()) {
                const backupData = backupDocSnap.data();
                // Ensure it is actually a backup
                if (backupData.isBackup !== true) {
                    showMessage("Error: Selected item is not a valid backup.", "error");
                    showGeneralLoading(false);
                    return;
                }

                if (typeof backupData.scheduleTitle === 'string') {
                    scheduleTitleElement.textContent = backupData.scheduleTitle;
                }
                tablesContainer.innerHTML = backupData.html;
                const tableMeta = backupData.meta || {};
                tableTabs.innerHTML = '';
                tablesContainer.querySelectorAll('table').forEach(table => {
                    ensureDateHeaderRowExists(table);
                    const id = table.id;
                    const metaInfo = tableMeta[id] || {};
                    const name = metaInfo.name || `Table ${tableTabs.children.length + 1}`;
                    table.dataset.tableName = name;
                    addTabButton(id, name);
                    table.querySelectorAll('td, th, .merged-cell-overlay').forEach(cell => cell.contentEditable = 'true');
                });
                activeTableId = backupData.activeTableId || tablesContainer.querySelector('table')?.id || 'tbl_1';
                if (document.getElementById(activeTableId)) {
                    switchTable(activeTableId);
                } else if (tablesContainer.querySelector('table')) {
                    switchTable(tablesContainer.querySelector('table').id);
                } else {
                    addNewTable(true); // Should not happen if backup is valid
                }
                
                // When loading a backup, the currentWorkingScheduleDocId should become the originalDocId
                // so that a "Save Page" action correctly updates the original live document.
                // The name displayed should reflect it's a loaded backup, perhaps.
                _updateLocalStateAfterSave(backupData.originalDocId || null, backupData.name, backupData.isAutoDraft, "restore-from-backup");
                // The 'name' here is the backup's name. The user will be prompted on save if it's a draft.
                
                if (restoreBackupModalElement) restoreBackupModalElement.style.display = 'none';
                rebuildAndRenderSummary();
                updateAllMergeOverlays();
                showMessage(`Backup "${backupData.name}" loaded for review. Use 'Save Page' or 'Save Shared'.`, 'success', 7000);

            } else {
                showMessage(`Backup ID "${backupDocId}" not found.`, "error");
            }
        } catch (error) {
            console.error(`Error loading backup ID ${backupDocId}:`, error);
            showMessage(`Failed to load backup. Error: ${error.message}`, "error");
        } finally {
            showGeneralLoading(false);
        }
    }
    
    // --- Autocomplete Functions ---
    // (Keep showCellAutocompleteSuggestions, hideCellAutocompleteSuggestions, selectCellAutocompleteSuggestion, updateCellSuggestionHighlight as they are)
    function showCellAutocompleteSuggestions(cell, inputText) {
        if (!autocompleteSuggestionsDiv) return;
        const namesForAutocomplete = currentNameListSession === 'pagi' ? namesPagiShared : namesPetangShared;
        let textForMatchingInput = String(inputText || '').split(' // ')[0]; // Match only before remarks
        const wordsForMatching = textForMatchingInput.split(/\s+/).filter(word => !word.startsWith('*')); // Exclude star-prefixed words from matching base
        const textForMatching = wordsForMatching.join(' ').toLowerCase().trim(); // The part to match against suggestions

        if (!textForMatching) { hideCellAutocompleteSuggestions(); return; }

        const filteredSuggestions = namesForAutocomplete.filter(name => {
            const nameStr = String(name || '').toLowerCase().trim();
            return nameStr.startsWith(textForMatching) && nameStr !== textForMatching;
        });

        if (filteredSuggestions.length > 0) {
            activeCellForAutocomplete = cell;
            autocompleteSuggestionsDiv.innerHTML = '';
            filteredSuggestions.slice(0, 10).forEach(suggestion => { // Limit to 10 suggestions
                const item = document.createElement('div');
                item.className = 'suggestion-item';
                item.textContent = suggestion;
                item.addEventListener('mousedown', (e) => { // Use mousedown to fire before blur
                    e.preventDefault(); // Prevent blur on cell
                    selectCellAutocompleteSuggestion(suggestion);
                });
                autocompleteSuggestionsDiv.appendChild(item);
            });
            const cellRect = cell.getBoundingClientRect();
            autocompleteSuggestionsDiv.style.left = `${cellRect.left + window.scrollX}px`;
            autocompleteSuggestionsDiv.style.top = `${cellRect.bottom + window.scrollY}px`;
            autocompleteSuggestionsDiv.style.minWidth = `${cellRect.width}px`;
            autocompleteSuggestionsDiv.style.display = 'block';
            currentAutocompleteIndex = -1; // Reset selection
        } else {
            hideCellAutocompleteSuggestions();
        }
    }
    function hideCellAutocompleteSuggestions() {
        if (autocompleteSuggestionsDiv) autocompleteSuggestionsDiv.style.display = 'none';
        activeCellForAutocomplete = null;
        currentAutocompleteIndex = -1;
    }
    function selectCellAutocompleteSuggestion(suggestionText) {
        if (activeCellForAutocomplete) {
            const targetCell = activeCellForAutocomplete;
            const overlay = targetCell.querySelector('.merged-cell-overlay');
            const contentNode = overlay || targetCell; // Edit overlay if present, else cell itself

            const currentFullText = contentNode.textContent;
            const remarkPart = currentFullText.includes(' // ') ? currentFullText.substring(currentFullText.indexOf(' // ')) : '';
            
            // Preserve starred words from the original content before remarks
            const contentBeforeRemark = currentFullText.split(' // ')[0];
            const starWordsBeforeRemark = contentBeforeRemark.split(/\s+/).filter(word => word.startsWith('*')).join(' ');

            let newText = suggestionText;
            if (starWordsBeforeRemark) {
                newText += ' ' + starWordsBeforeRemark;
            }
            newText = (newText.trim() + remarkPart).trim();
            
            contentNode.textContent = newText;
            hideCellAutocompleteSuggestions();
            rebuildAndRenderSummary(); // Update summary as cell content changed

            // Set cursor to end of the cell content
            contentNode.focus();
            const range = document.createRange();
            const sel = window.getSelection();
            if (sel) {
                if (contentNode.childNodes.length > 0) {
                    range.selectNodeContents(contentNode);
                    range.collapse(false); // false to collapse to end
                } else { // If cell is empty (e.g. after clearing)
                    range.setStart(contentNode, 0);
                    range.collapse(true);
                }
                sel.removeAllRanges();
                sel.addRange(range);
            }
        }
    }
    function updateCellSuggestionHighlight() {
        if (!autocompleteSuggestionsDiv || autocompleteSuggestionsDiv.style.display === 'none') return;
        const items = autocompleteSuggestionsDiv.querySelectorAll('.suggestion-item');
        items.forEach((item, index) => {
            item.classList.toggle('active-suggestion', index === currentAutocompleteIndex);
        });
    }


    // --- DOMContentLoaded: Main Initialization ---
    document.addEventListener('DOMContentLoaded', () => {
        // Keep all existing DOM element gets
        scheduleTitleElement = document.getElementById('scheduleTitle'); tablesContainer = document.getElementById('tablesContainer'); tableTabs = document.getElementById('tableTabs'); nameModal = document.getElementById('nameModal'); nameModalContent = document.getElementById('nameModalContent'); nameModalHeader = document.getElementById('nameModalHeader'); nameListContainer = document.getElementById('nameList'); newNameInput = document.getElementById('newNameInput'); sharedScheduleListContainerElement = document.getElementById('sharedScheduleListContainer'); summaryTableElement = document.getElementById('summaryTable'); summaryTableContainerElement = document.getElementById('summaryTableContainer'); customMessageBox = document.getElementById('customMessageBox'); fileInputElement = document.getElementById('fileInput'); directCopyFullHtmlButtonElement = document.getElementById('directCopyFullHtmlBtn'); closeNameModalButtonStandardElement = document.getElementById('closeNameModalBtnStandard'); nameListImportFileInputElement = document.getElementById('nameListImportFile'); searchNameInputElement = document.getElementById('searchNameInput'); sharedScheduleImportFileInputElement = document.getElementById('sharedScheduleImportFile'); userIdDisplayElement = document.getElementById('userIdDisplay'); namePagiTabElement = document.getElementById('namePagiTab'); namePetangTabElement = document.getElementById('namePetangTab'); loadingIndicatorModalElement = document.getElementById('loadingIndicatorModal'); nameModalTitleElement = document.getElementById('nameModalTitle'); generalLoadingIndicatorElement = document.getElementById('generalLoadingIndicator'); controlsTogglerElement = document.getElementById('controlsToggler'); collapsibleButtonBarsElement = document.getElementById('collapsibleButtonBars'); downloadPdfButtonElement = document.getElementById('downloadPdfBtn'); pdfContentElement = document.getElementById('pdfContent'); clearAndResetScheduleBtnElement = document.getElementById('clearAndResetScheduleBtn'); manualSaveBtnElement = document.getElementById('manualSaveBtn');
        clearScheduledNamesBtnElement = document.getElementById('clearScheduledNamesBtn');
        restoreBackupBtnElement = document.getElementById('restoreBackupBtn');
        restoreBackupModalElement = document.getElementById('restoreBackupModal');
        restoreBackupModalContentElement = document.getElementById('restoreBackupModalContent');
        restoreBackupModalHeaderElement = document.getElementById('restoreBackupModalHeader');
        closeRestoreBackupModalBtnElement = document.getElementById('closeRestoreBackupModalBtn');
        restoreBackupListContainerElement = document.getElementById('restoreBackupListContainer');
        loadingIndicatorRestoreModalElement = document.getElementById('loadingIndicatorRestoreModal');


        autocompleteSuggestionsDiv = document.createElement('div'); autocompleteSuggestionsDiv.id = 'autocompleteSuggestions'; document.body.appendChild(autocompleteSuggestionsDiv);
        
        if (controlsTogglerElement && collapsibleButtonBarsElement) { collapsibleButtonBarsElement.classList.remove('open'); controlsTogglerElement.setAttribute('aria-expanded', 'false'); const textSpan = controlsTogglerElement.querySelector('span'); if (textSpan) textSpan.textContent = 'Show Controls'; }

        if (!tablesContainer || !tableTabs || !nameModal || !summaryTableElement || !scheduleTitleElement || !sharedScheduleListContainerElement || !generalLoadingIndicatorElement || !summaryTableContainerElement || !controlsTogglerElement || !collapsibleButtonBarsElement || !downloadPdfButtonElement || !pdfContentElement || !clearAndResetScheduleBtnElement || !manualSaveBtnElement || !clearScheduledNamesBtnElement || !restoreBackupBtnElement || !restoreBackupModalElement || !closeRestoreBackupModalBtnElement || !restoreBackupListContainerElement || !loadingIndicatorRestoreModalElement ) {
            console.error("CRITICAL DOM elements missing. Some functionality may be impaired.");
            // Potentially display a user-facing error here if core elements are gone
        }
        
        if (fbAuth) {
            onAuthStateChanged(fbAuth, async (user) => {
                if (user) {
                    fbUserId = user.uid; fbIsAuthReady = true; if(userIdDisplayElement) userIdDisplayElement.textContent = `User ID: ${fbUserId}`;
                    if (unsubscribePagiShared) unsubscribePagiShared(); if (unsubscribePetangShared) unsubscribePetangShared();
                    unsubscribePagiShared = listenToSharedNameList('pagi'); unsubscribePetangShared = listenToSharedNameList('petang');
                    if (nameModal?.style.display === 'flex' && searchNameInputElement) renderNameListFromFirestore(searchNameInputElement.value); // Refresh if modal open
                    
                    await loadLatestSharedScheduleAsDefault(); // This now handles initial state setup or load
                    // isInitialStateSet and lastSavedState are handled within loadLatest or its fallbacks.
                    
                    if (autoSaveIntervalId) clearInterval(autoSaveIntervalId);
                    autoSaveIntervalId = setInterval(autoSaveCurrentSchedule, AUTO_SAVE_INTERVAL);
                } else { // User is signed out or auth token expired
                    fbIsAuthReady = false; fbUserId = null; if(userIdDisplayElement) userIdDisplayElement.textContent = "User ID: Authenticating...";
                    try {
                        if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token && __initial_auth_token.trim() !== '') {
                            await signInWithCustomToken(fbAuth, __initial_auth_token);
                        } else {
                            await signInAnonymously(fbAuth);
                        }
                    } catch (error) {
                        console.error("Firebase Auth: Error during sign-in:", error); showMessage(`Firebase Auth failed. Error: ${error.message}`, "error", 7000);
                        if(userIdDisplayElement) userIdDisplayElement.textContent = `User ID: Auth Error`;
                        // Fallback to setting up initial state if auth fails catastrophically
                        console.log("Auth Error: Setting up initial table state as fallback.");
                        setupInitialTableState();
                        lastSavedState = captureCurrentState();
                        isInitialStateSet = true;
                        if (lastSavedState === null) console.error("CRITICAL: Initial state capture failed after auth failure.");
                        rebuildAndRenderSummary();
                    }
                }
            });
        } else { // Firebase Auth service itself failed to initialize
             if(userIdDisplayElement) userIdDisplayElement.textContent = "User ID: Firebase Auth Not Initialized";
             console.error("Firebase Auth: fbAuth object not available."); showMessage("Critical Error: Firebase Auth service not initialized.", "error", 10000);
             console.log("Firebase Init Error: Setting up initial table state as fallback.");
             setupInitialTableState();
             lastSavedState = captureCurrentState();
             isInitialStateSet = true;
             if (lastSavedState === null) console.error("CRITICAL: Initial state capture failed due to Firebase init error.");
             rebuildAndRenderSummary();
        }
        loadScheduleTitleFromLocalStorage(); initializeEventListeners();
        handleNameListSessionSwitch('pagi'); // Set default session for name list
    });

    function setupInitialTableState() {
        // This function ensures there's a basic table structure if no data is loaded.
        // It primarily focuses on setting up tabs for whatever is in tablesContainer.
        // loadLatestSharedScheduleAsDefault will call this if it fails to load anything.

        const existingTablesInDOM = tablesContainer.querySelectorAll('table');
        
        if (existingTablesInDOM.length === 0) {
            // If tablesContainer is truly empty (e.g. initial HTML was minimal or cleared),
            // create the default table from scratch.
            console.warn("setupInitialTableState: tablesContainer was empty. Creating default table.");
            // The addNewTable(true) function can create a default table.
            // However, the original HTML already contains a default table.
            // This path should ideally not be taken if the HTML is intact.
            // If it *is* taken, ensure addNewTable creates a sensible default.
            // For robustness, let's assume the original HTML's tbl_1 is the desired default.
            // If tbl_1 is missing, addNewTable will create one.
            if (!document.getElementById('tbl_1')) {
                 addNewTable(true); // This will create a new table and set it as active
            } else {
                // tbl_1 exists from original HTML, ensure it's active
                activeTableId = 'tbl_1';
            }
        } else if (!tablesContainer.querySelector('table.active')) {
            // If tables exist but none are active, activate the first one.
            activeTableId = existingTablesInDOM[0].id;
        } else {
            // A table is already active, respect that.
            activeTableId = tablesContainer.querySelector('table.active').id;
        }

        tableTabs.innerHTML = ''; // Clear existing tabs
        const currentTablesForTabs = tablesContainer.querySelectorAll('table'); // Re-query after potential addNewTable
        currentTablesForTabs.forEach((table, index) => {
            ensureDateHeaderRowExists(table); // Ensure all tables have date headers
            const id = table.id || `tbl_dom_${Date.now()}_${index + 1}`; // Ensure ID if missing
            if (!table.id) table.id = id;
            const name = table.dataset.tableName || `Sheet ${index + 1}`;
            table.dataset.tableName = name;
            addTabButton(id, name);
            table.querySelectorAll('td, th, .merged-cell-overlay').forEach(cell => cell.contentEditable = 'true');
        });

        if (activeTableId && document.getElementById(activeTableId)) {
            switchTable(activeTableId);
        } else if (currentTablesForTabs.length > 0) {
            // Fallback if activeTableId somehow became invalid but tables exist
            switchTable(currentTablesForTabs[0].id);
        } else {
            // This case means no tables exist even after trying to add one, which is an error state.
            console.error("setupInitialTableState: No tables found in DOM to activate after setup. This is problematic.");
            // Potentially add a default table again if all else fails
            if (tablesContainer.children.length === 0) addNewTable(true);
        }
        tableCount = Math.max(1, currentTablesForTabs.length); // Update global table count
        console.log(`setupInitialTableState: Final activeTableId is ${activeTableId}. tableCount is ${tableCount}.`);
    }


    function loadScheduleTitleFromLocalStorage() {
        const savedTitle = localStorage.getItem(SCHEDULE_TITLE_KEY);
        if (savedTitle && scheduleTitleElement) scheduleTitleElement.textContent = savedTitle;
        if (scheduleTitleElement) scheduleTitleElement.addEventListener('blur', () => localStorage.setItem(SCHEDULE_TITLE_KEY, scheduleTitleElement.textContent));
    }
    function initializeEventListeners() {
        // (Keep all existing event listeners as they are crucial for functionality)
        if(controlsTogglerElement) controlsTogglerElement.addEventListener('click', toggleButtonBarsVisibility);
        if(manualSaveBtnElement) manualSaveBtnElement.addEventListener('click', manualSaveCurrentPage);
        if(downloadPdfButtonElement) downloadPdfButtonElement.addEventListener('click', generateSchedulePdf);
        if(clearScheduledNamesBtnElement) clearScheduledNamesBtnElement.addEventListener('click', clearScheduledNamesFromActiveTable);
        if(directCopyFullHtmlButtonElement) directCopyFullHtmlButtonElement.addEventListener('click', attemptDirectCopyToClipboard);
        if(closeNameModalButtonStandardElement) closeNameModalButtonStandardElement.addEventListener('click', closeNameModal);
        if(nameModalHeader) { nameModalHeader.addEventListener('mousedown', (e) => startDragModal(e, nameModalContent)); nameModalHeader.addEventListener('touchstart', (e) => startDragModal(e, nameModalContent), { passive: false }); }
        document.addEventListener('mousemove', (e) => dragModal(e, document.querySelector('.modal-content.dragging')));
        document.addEventListener('mouseup', (e) => stopDragModal(e, document.querySelector('.modal-content.dragging')));
        document.addEventListener('touchmove', (e) => dragModal(e, document.querySelector('.modal-content.dragging')), { passive: false });
        document.addEventListener('touchend', (e) => stopDragModal(e, document.querySelector('.modal-content.dragging')));
        document.getElementById('excelBtnTrigger')?.addEventListener('click', exportActiveTableToExcel);
        document.getElementById('importExcelBtn')?.addEventListener('click', () => fileInputElement?.click());
        if(fileInputElement) fileInputElement.addEventListener('change', handleExcelFileImport);
        document.getElementById('saveSharedScheduleBtn')?.addEventListener('click', saveSharedScheduleToFirestore);
        document.getElementById('loadSharedScheduleBtn')?.addEventListener('click', loadAndRenderSharedSchedulesFromFirestore);
        document.getElementById('exportSharedSchedulesBtn')?.addEventListener('click', exportAllSharedSchedulesFromFirestore);
        document.getElementById('importSharedSchedulesBtn')?.addEventListener('click', () => sharedScheduleImportFileInputElement?.click());
        if(sharedScheduleImportFileInputElement) sharedScheduleImportFileInputElement.addEventListener('change', handleSharedSchedulesImport);
        if(sharedScheduleListContainerElement) sharedScheduleListContainerElement.addEventListener('click', async (e) => {
            const targetSpan = e.target.closest('.shared-schedule-item .schedule-item-main-line span[data-schedule-id]');
            const targetButton = e.target.closest('.shared-schedule-item .schedule-item-main-line button[data-schedule-id]');
            if (targetSpan) loadSelectedSharedScheduleFromFirestore(targetSpan.dataset.scheduleId);
            else if (targetButton) { const scheduleId = targetButton.dataset.scheduleId; const scheduleNameElement = targetButton.parentElement.querySelector('span[data-schedule-id]'); const scheduleName = scheduleNameElement ? scheduleNameElement.textContent.split(' (by')[0] : 'this schedule'; await confirmAndDeleteSharedScheduleFromFirestore(scheduleId, scheduleName); }
        });
        if(clearAndResetScheduleBtnElement) clearAndResetScheduleBtnElement.addEventListener('click', async () => {
            if (await customConfirm("Clear everything and start new schedule? This will affect the current view only and does not delete saved Cloud schedules or their backups.")) {
                tablesContainer.innerHTML = ''; tableTabs.innerHTML = ''; activeTableId = null;
                if (scheduleTitleElement) scheduleTitleElement.textContent = "Jadual Anjal"; // Reset title
                localStorage.removeItem(SCHEDULE_TITLE_KEY); // Clear saved title
                addNewTable(true); // Add a fresh default table
                _updateLocalStateAfterSave(null, "New Schedule (Reset)", false, "reset-all"); // Update local state
                rebuildAndRenderSummary(); showMessage('Content cleared. New schedule started.', 'success');
            }
        });
        document.getElementById('selectBtn')?.addEventListener('click', toggleCellSelectionMode);
        document.getElementById('mergeBtn')?.addEventListener('click', mergeSelectedTableCells);
        document.getElementById('deselectBtn')?.addEventListener('click', deselectAllTableCells);
        document.getElementById('unmergeBtn')?.addEventListener('click', unmergeActiveCellIfMerged);
        document.getElementById('addTableBtn')?.addEventListener('click', () => addNewTable());
        document.getElementById('renameTableBtn')?.addEventListener('click', promptAndRenameActiveTable);
        document.getElementById('deleteTableBtn')?.addEventListener('click', confirmAndDeleteActiveTable);
        document.getElementById('addRowAboveBtn')?.addEventListener('click', addRowAboveToActiveTable);
        document.getElementById('addRowBelowBtn')?.addEventListener('click', addRowBelowToActiveTable);
        document.getElementById('addColLeftBtn')?.addEventListener('click', addColumnLeftToActiveTable);
        document.getElementById('addColRightBtn')?.addEventListener('click', addColumnRightToActiveTable);
        document.getElementById('deleteRowBtn')?.addEventListener('click', deleteClickedRowFromActiveTable);
        document.getElementById('deleteColBtn')?.addEventListener('click', deleteClickedColumnFromActiveTable);
        document.getElementById('nameListBtn')?.addEventListener('click', toggleNameListModalVisibility);
        document.getElementById('addNameBtnInModal')?.addEventListener('click', () => { if(newNameInput) addNameToSharedSessionInFirestore(newNameInput.value); });
        document.getElementById('importNameListBtn')?.addEventListener('click', () => nameListImportFileInputElement?.click());
        if(nameListImportFileInputElement) nameListImportFileInputElement.addEventListener('change', handleNameListImportFirestore);
        if(searchNameInputElement) searchNameInputElement.addEventListener('input', (e) => renderNameListFromFirestore(e.target.value));
        if(namePagiTabElement) namePagiTabElement.addEventListener('click', () => handleNameListSessionSwitch('pagi'));
        if(namePetangTabElement) namePetangTabElement.addEventListener('click', () => handleNameListSessionSwitch('petang'));
        if(nameListContainer) nameListContainer.addEventListener('click', async (e) => {
            const nameItemSpan = e.target.closest('.name-item span[data-name]');
            const deleteButton = e.target.closest('.name-item button[data-name-delete]');
            if (nameItemSpan) selectNameForCellInsertion(nameItemSpan.dataset.name);
            else if (deleteButton) await deleteNameFromSharedSessionInFirestore(deleteButton.dataset.nameDelete);
        });
        if(tablesContainer) {
            tablesContainer.addEventListener('click', handleTableCellClick);
            tablesContainer.addEventListener('input', (e) => { // For autocomplete triggering
                const cell = e.target; 
                // Determine the actual content-holding element (cell or overlay)
                const targetElement = cell.classList.contains('merged-cell-overlay') ? cell : (cell.closest('td, th'));
                
                if (targetElement && (targetElement.tagName === 'TD' || (targetElement.tagName === 'TH' && targetElement.closest('tbody')) || targetElement.classList.contains('date-header-cell') || cell.classList.contains('merged-cell-overlay')) && targetElement.isContentEditable !== false) {
                    const text = cell.textContent; // Text from the element that received input
                    // Check if autocomplete should be shown for this cell type
                    const isTimeSlotHeaderCell = targetElement.tagName === 'TH' && targetElement.closest('thead tr:not(.date-header-row)');
                    const isFirstColumnClassHeader = targetElement.closest('table')?.querySelector('thead tr:not(.date-header-row) th:first-child')?.textContent?.toLowerCase() === 'class' && targetElement.cellIndex === 0 && !targetElement.classList.contains('date-header-cell');
                    
                    if (!isTimeSlotHeaderCell && !isFirstColumnClassHeader && !targetElement.classList.contains('date-header-cell')) {
                        showCellAutocompleteSuggestions(targetElement, text);
                    } else {
                        hideCellAutocompleteSuggestions();
                    }
                }
            });
            tablesContainer.addEventListener('blur', (e) => { // For summary update and hiding autocomplete
                const cell = e.target; 
                const targetElement = cell.classList.contains('merged-cell-overlay') ? cell.parentElement : cell;
                if (targetElement && (targetElement.tagName === 'TD' || targetElement.tagName === 'TH' || cell.classList.contains('merged-cell-overlay')) && targetElement.isContentEditable !== false) {
                    setTimeout(rebuildAndRenderSummary, 0); // Update summary after cell loses focus
                    // Delay hiding autocomplete to allow click on suggestions
                    setTimeout(() => { 
                        if (autocompleteSuggestionsDiv?.style.display === 'block' && 
                            !autocompleteSuggestionsDiv.contains(document.activeElement) && 
                            activeCellForAutocomplete !== document.activeElement && 
                            (!activeCellForAutocomplete || activeCellForAutocomplete.querySelector('.merged-cell-overlay') !== document.activeElement)) {
                            hideCellAutocompleteSuggestions(); 
                        }
                    }, 150);
                }
            }, true); // Use capture phase for blur
        }
        window.addEventListener('resize', () => { updateAllMergeOverlays(); hideCellAutocompleteSuggestions(); });
        document.addEventListener('keydown', (e) => { // For autocomplete navigation
            if (autocompleteSuggestionsDiv?.style.display === 'block' && activeCellForAutocomplete) {
                const items = autocompleteSuggestionsDiv.querySelectorAll('.suggestion-item'); 
                if (items.length === 0 && e.key !== 'Escape') return;

                if (e.key === 'ArrowDown') { e.preventDefault(); currentAutocompleteIndex = (currentAutocompleteIndex + 1) % items.length; updateCellSuggestionHighlight(); }
                else if (e.key === 'ArrowUp') { e.preventDefault(); currentAutocompleteIndex = (currentAutocompleteIndex - 1 + items.length) % items.length; updateCellSuggestionHighlight(); }
                else if (e.key === 'Enter') { 
                    e.preventDefault(); 
                    if (currentAutocompleteIndex >= 0 && currentAutocompleteIndex < items.length) {
                        selectCellAutocompleteSuggestion(items[currentAutocompleteIndex].textContent);
                    } else { // If no suggestion selected, just hide
                        hideCellAutocompleteSuggestions(); 
                        if(activeCellForAutocomplete) activeCellForAutocomplete.blur(); // Optionally blur cell
                    }
                }
                else if (e.key === 'Escape') { e.preventDefault(); hideCellAutocompleteSuggestions(); }
                else if (e.key === 'Tab') { hideCellAutocompleteSuggestions(); } // Hide on Tab out
            }
        });
        document.addEventListener('click', (event) => { // Hide autocomplete if click outside
            if (autocompleteSuggestionsDiv?.style.display === 'block') {
                const isClickInsideCell = activeCellForAutocomplete?.contains(event.target);
                const isClickInsideOverlay = activeCellForAutocomplete?.querySelector('.merged-cell-overlay')?.contains(event.target);
                const isClickInsideSuggestions = autocompleteSuggestionsDiv.contains(event.target);
                if (!isClickInsideCell && !isClickInsideSuggestions && !isClickInsideOverlay) {
                    hideCellAutocompleteSuggestions();
                }
            }
        });

        if(restoreBackupBtnElement) restoreBackupBtnElement.addEventListener('click', toggleRestoreBackupModalVisibility);
        if(closeRestoreBackupModalBtnElement) closeRestoreBackupModalBtnElement.addEventListener('click', toggleRestoreBackupModalVisibility);
        if(restoreBackupListContainerElement) restoreBackupListContainerElement.addEventListener('click', async (e) => {
            const targetSpan = e.target.closest('.backup-schedule-item .schedule-item-main-line span[data-backup-id]');
            if (targetSpan) {
                const backupId = targetSpan.dataset.backupId;
                await loadSelectedBackupIntoView(backupId);
            }
        });
        if (restoreBackupModalHeaderElement) {
            restoreBackupModalHeaderElement.addEventListener('mousedown', (e) => startDragModal(e, restoreBackupModalContentElement));
            restoreBackupModalHeaderElement.addEventListener('touchstart', (e) => startDragModal(e, restoreBackupModalContentElement), { passive: false });
        }
    }

    // --- Modal Drag Functions ---
    // (Keep startDragModal, dragModal, stopDragModal as they are)
    function startDragModal(e, modalContentEl = nameModalContent) {
        if (e.target.closest('.modal-close-btn')) { isDraggingModal = false; return; }
        isDraggingModal = true;
        if(modalContentEl) modalContentEl.classList.add('dragging');
        const clientX = e.clientX || (e.touches && e.touches[0].clientX);
        const clientY = e.clientY || (e.touches && e.touches[0].clientY);
        const rect = modalContentEl.getBoundingClientRect();
        modalContentEl.style.position = 'fixed'; // Ensure it's fixed for viewport-relative positioning
        modalContentEl.style.left = `${rect.left}px`;
        modalContentEl.style.top = `${rect.top}px`;
        modalContentEl.style.transform = 'none'; // Reset transform if any
        modalDragOffsetX = clientX - modalContentEl.offsetLeft;
        modalDragOffsetY = clientY - modalContentEl.offsetTop;
        if (e.type === 'touchstart') e.preventDefault();
    }
    function dragModal(e, modalContentEl = nameModalContent) {
        if (!isDraggingModal || !modalContentEl || !modalContentEl.classList.contains('dragging')) return;
        const clientX = e.clientX || (e.touches && e.touches[0].clientX);
        const clientY = e.clientY || (e.touches && e.touches[0].clientY);
        let newLeft = clientX - modalDragOffsetX;
        let newTop = clientY - modalDragOffsetY;
        
        // Boundary checks to keep modal within viewport
        const modalRect = modalContentEl.getBoundingClientRect(); // Get current dimensions
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;

        if (newLeft < 0) newLeft = 0;
        if (newTop < 0) newTop = 0;
        if (newLeft + modalRect.width > viewportWidth) newLeft = viewportWidth - modalRect.width;
        if (newTop + modalRect.height > viewportHeight) newTop = viewportHeight - modalRect.height;
        
        modalContentEl.style.left = `${newLeft}px`;
        modalContentEl.style.top = `${newTop}px`;
        if (e.type === 'touchmove') e.preventDefault();
    }
    function stopDragModal(e, modalContentEl = nameModalContent) {
        if (isDraggingModal && modalContentEl && modalContentEl.classList.contains('dragging')) {
            isDraggingModal = false;
            modalContentEl.classList.remove('dragging');
            // No need to reset position to relative here, as it's fixed during drag
        }
    }


    // --- Clipboard & Table Management ---
    // (Keep attemptDirectCopyToClipboard, addTabButton, switchTable, addNewTable, promptAndRenameActiveTable, confirmAndDeleteActiveTable, addRowToTable, addRowAboveToActiveTable, addRowBelowToActiveTable, addColumnToTable, addColumnLeftToActiveTable, addColumnRightToActiveTable, deleteClickedRowFromActiveTable, deleteClickedColumnFromActiveTable, clearScheduledNamesFromActiveTable as they are)
    async function attemptDirectCopyToClipboard() {
        const fullHtml = document.documentElement.outerHTML;
        try { await navigator.clipboard.writeText(fullHtml); showMessage('Full HTML copied!', 'success'); }
        catch (err) {
            console.warn('Direct copy failed, trying fallback:', err); const textarea = document.createElement('textarea');
            textarea.value = fullHtml; textarea.style.position = 'fixed'; textarea.style.left = '-9999px';
            document.body.appendChild(textarea); textarea.select();
            try { const success = document.execCommand('copy'); if (success) showMessage('Full HTML copied! (fallback)', 'success'); else showMessage('Copy failed (execCommand).', 'error', 5000); }
            catch (execErr) { console.error('execCommand copy failed:', execErr); showMessage('Copy failed completely.', 'error', 5000); }
            document.body.removeChild(textarea);
        }
    }
    
    function addTabButton(id, label) {
        if (!tableTabs) return null;
        const button = document.createElement('button'); button.textContent = label; button.dataset.tableId = id;
        button.title = `Switch to table: ${label}`; button.onclick = () => switchTable(id);
        tableTabs.appendChild(button); return button;
    }
    function switchTable(id) {
        const targetTable = document.getElementById(id);
        if (!targetTable && tablesContainer) { // If target table not found
            const firstTableInDOM = tablesContainer.querySelector('table');
            if (firstTableInDOM) { 
                id = firstTableInDOM.id; 
                console.warn(`SwitchTable: Target table '${id}' not found, falling back to the first available table '${firstTableInDOM.id}'.`);
            } else { // No tables exist at all
                if (tablesContainer.children.length === 0) {
                    console.warn("SwitchTable: No tables exist. Adding a new default table.");
                    addNewTable(true); // This will create and switch to a new table
                    return; // Exit as addNewTable will handle the switch
                }
                console.error(`SwitchTable: Target table '${id}' not found, and no fallback tables available.`); return;
            }
        } else if (!targetTable) { // Target table not found and tablesContainer is also missing (critical error)
             console.error(`SwitchTable: Target table '${id}' not found, and tablesContainer is missing.`); return;
        }

        activeTableId = id;
        if(tablesContainer) tablesContainer.querySelectorAll('table').forEach(t => t.classList.toggle('active', t.id === id));
        if(tableTabs) tableTabs.querySelectorAll('button').forEach(b => b.classList.toggle('active', b.dataset.tableId === id));
        deselectAllTableCells(); rebuildAndRenderSummary(); updateAllMergeOverlays(); hideCellAutocompleteSuggestions();
    }
    function addNewTable(isInitial = false) {
        if (!tablesContainer || !tableTabs) { console.error("addNewTable: Critical DOM elements (tablesContainer or tableTabs) missing."); return; }
        tableCount++; // Increment global table counter
        const defaultTableNameBase = "Schedule";
        let newTableIndex = tableTabs.children.length + 1;
        let proposedName = `${defaultTableNameBase} ${newTableIndex}`;
        
        // Ensure unique default name if "Schedule X" already exists
        const existingNames = Array.from(tableTabs.children).map(btn => btn.textContent);
        while(existingNames.includes(proposedName)) {
            newTableIndex++;
            proposedName = `${defaultTableNameBase} ${newTableIndex}`;
        }

        const label = isInitial ? proposedName : customPrompt('Enter new table name:', proposedName);
        if (!label && !isInitial) { // User cancelled prompt for non-initial table
            showMessage('Table creation cancelled.', 'info');
            tableCount--; // Decrement as table was not added
            return;
        }
        const finalTableName = (label || proposedName).trim();

        const newTable = document.createElement('table');
        newTable.id = `tbl_${Date.now()}_${tableCount}`; // Unique ID
        newTable.dataset.tableName = finalTableName;

        const thead = newTable.createTHead();
        // Date header row will be added by ensureDateHeaderRowExists
        const timeSlotHeaderRow = thead.insertRow();
        timeSlotHeaderRow.className = ''; // Not a date-header-row
        const defaultHeaders = ['Class/Time', '08:00-09:00', '09:00-10:00', '10:00-11:00', '11:00-12:00', '12:00-13:00'];
        defaultHeaders.forEach(headerText => {
            const th = document.createElement('th');
            th.contentEditable = 'true'; th.textContent = headerText;
            timeSlotHeaderRow.appendChild(th);
        });
        
        ensureDateHeaderRowExists(newTable); // Add/update date header row based on time slots

        const tbody = newTable.createTBody();
        for (let r = 0; r < 2; r++) { // Add a couple of sample rows
            const dataRow = tbody.insertRow();
            for (let c = 0; c < timeSlotHeaderRow.cells.length; c++) {
                const td = dataRow.insertCell(); td.contentEditable = 'true';
                if (c === 0) td.textContent = `Sample Class ${String.fromCharCode(65 + r)}`;
            }
        }
        tablesContainer.appendChild(newTable);
        addTabButton(newTable.id, finalTableName);
        switchTable(newTable.id); // Switch to the new table
        if (!isInitial) showMessage(`Table "${finalTableName}" added.`, 'success');
        else console.log(`Initial table "${finalTableName}" created with ID ${newTable.id}.`);
    }
    async function promptAndRenameActiveTable() {
        if (!tableTabs) return;
        const currentTab = tableTabs.querySelector('button.active');
        if (!currentTab) { showMessage('No active table to rename.', 'error'); return; }
        let tableIdToRename = currentTab.dataset.tableId;
        // Fallback if dataset.tableId is missing (should not happen with addTabButton)
        if (!tableIdToRename) { const match = currentTab.getAttribute('onclick')?.match(/'(tbl_.*?)'/); if (match && match[1]) tableIdToRename = match[1]; else { showMessage('Could not identify table ID.', 'error'); return; }}
        
        const tableElement = document.getElementById(tableIdToRename);
        if (!tableElement) { showMessage(`Table element for ID '${tableIdToRename}' not found.`, 'error'); return; }
        
        const oldName = tableElement.dataset.tableName || currentTab.textContent;
        const newName = customPrompt('Enter new table name:', oldName);
        
        if (newName && newName.trim() && newName.trim() !== oldName) {
            const trimmedNewName = newName.trim(); 
            currentTab.textContent = trimmedNewName; 
            currentTab.title = `Switch to table: ${trimmedNewName}`; // Update title attribute
            tableElement.dataset.tableName = trimmedNewName; 
            showMessage(`Table renamed to "${trimmedNewName}".`, 'success');
            rebuildAndRenderSummary(); // Summary might depend on table names if used in headers (not currently, but good practice)
        } else if (newName && newName.trim() === oldName) {
            showMessage('Name unchanged.', 'info');
        } else if (newName === null) { // User cancelled
            showMessage('Rename cancelled.', 'info');
        } else { // Empty name entered
            showMessage('Invalid new name (cannot be empty).', 'error');
        }
    }
    async function confirmAndDeleteActiveTable() {
        if (!tablesContainer || !tableTabs || tablesContainer.children.length <= 1) { showMessage('Cannot delete the last table.', 'error'); return; }
        const activeTab = tableTabs.querySelector('button.active');
        const tableIdToDelete = activeTab?.dataset.tableId;
        const tableElement = tableIdToDelete ? document.getElementById(tableIdToDelete) : null;
        const tableName = tableElement?.dataset.tableName || activeTab?.textContent || 'the active table';
        
        if (await customConfirm(`Delete table "${tableName}"? This action cannot be undone.`)) {
            if (tableElement) tableElement.remove();
            else if (document.getElementById(activeTableId)) document.getElementById(activeTableId).remove(); // Fallback if element not found by var
            
            activeTab?.remove();
            
            const firstRemainingTab = tableTabs.querySelector('button');
            if (firstRemainingTab) { 
                const nextActiveId = firstRemainingTab.dataset.tableId || firstRemainingTab.getAttribute('onclick').match(/'(tbl_.*?)'/)[1]; // Fallback for ID
                switchTable(nextActiveId); 
            } else { // Should not happen due to the "children.length <= 1" check, but as a safeguard
                activeTableId = null; 
                addNewTable(true); // Add a new default if all were somehow deleted
            }
            showMessage(`Table "${tableName}" deleted.`, 'success');
            rebuildAndRenderSummary(); // Update summary as a table is gone
        }
    }

    function addRowToTable(tableBody, rowIndex, numCols) {
        const row = tableBody.insertRow(rowIndex); // rowIndex -1 appends
        for (let i = 0; i < numCols; i++) { const cell = row.insertCell(); cell.contentEditable = 'true'; }
        return row;
    }
    function addRowAboveToActiveTable() {
        const table = document.getElementById(activeTableId); if (!table || !table.tBodies[0] || table.rows.length === 0) { showMessage("No active table or table body found.", "error"); return; }
        const timeSlotHeaderRow = Array.from(table.tHead.rows).find(r => !r.classList.contains('date-header-row'));
        const numCols = timeSlotHeaderRow ? timeSlotHeaderRow.cells.length : (table.rows[0]?.cells.length || 1);
        if (numCols === 0) { showMessage("Cannot add row: table has no columns.", "error"); return; }
        
        let insertAtIndex = 0; // Default to top of tbody
        if (lastClickedCell && lastClickedCell.closest('tbody')) {
            insertAtIndex = lastClickedCell.parentElement.rowIndex; // rowIndex is relative to tbody
        }
        addRowToTable(table.tBodies[0], insertAtIndex, numCols);
        rebuildAndRenderSummary(); updateAllMergeOverlays();
    }
    function addRowBelowToActiveTable() {
        const table = document.getElementById(activeTableId); if (!table || !table.tBodies[0] || table.rows.length === 0) { showMessage("No active table or table body found.", "error"); return; }
        const timeSlotHeaderRow = Array.from(table.tHead.rows).find(r => !r.classList.contains('date-header-row'));
        const numCols = timeSlotHeaderRow ? timeSlotHeaderRow.cells.length : (table.rows[0]?.cells.length || 1);
        if (numCols === 0) { showMessage("Cannot add row: table has no columns.", "error"); return; }

        let insertAtIndex = -1; // Default to append at the end of tbody
        if (lastClickedCell && lastClickedCell.closest('tbody')) {
            insertAtIndex = lastClickedCell.parentElement.rowIndex + 1;
        }
        addRowToTable(table.tBodies[0], insertAtIndex, numCols);
        rebuildAndRenderSummary(); updateAllMergeOverlays();
    }
    function addColumnToTable(table, colIndex) { // colIndex -1 appends
        for (const row of table.rows) {
            const isDateHeaderRow = row.classList.contains('date-header-row');
            const isTimeSlotHeaderRow = row.parentElement.tagName === 'THEAD' && !isDateHeaderRow;
            // const isBodyRow = row.parentElement.tagName === 'TBODY'; // Not directly used for cell type
            let cell;

            if (isDateHeaderRow) {
                cell = document.createElement('th');
                cell.className = 'date-header-cell';
            } else if (isTimeSlotHeaderRow) {
                cell = document.createElement('th');
                if (colIndex === -1 || colIndex >= row.cells.length) cell.textContent = "New Slot"; // Default for new end column
            } else { // Body row
                cell = document.createElement('td');
            }
            cell.contentEditable = 'true';

            if (colIndex === -1 || colIndex >= row.cells.length) { // Append
                row.appendChild(cell);
            } else { // Insert
                row.insertBefore(cell, row.cells[colIndex]);
            }
        }
    }
    function addColumnLeftToActiveTable() {
        const table = document.getElementById(activeTableId); if (!table) { showMessage("No active table.", "error"); return; }
        let insertAtIndex = 0; // Default to far left
        if (lastClickedCell && lastClickedCell.cellIndex >= 0) {
            insertAtIndex = lastClickedCell.cellIndex;
        }
        addColumnToTable(table, insertAtIndex);
        ensureDateHeaderRowExists(table); // Ensure date header row matches new column count
        rebuildAndRenderSummary(); updateAllMergeOverlays();
    }
    function addColumnRightToActiveTable() {
        const table = document.getElementById(activeTableId); if (!table) { showMessage("No active table.", "error"); return; }
        let insertAtIndex = -1; // Default to far right (append)
        if (lastClickedCell && lastClickedCell.cellIndex >= 0) {
            insertAtIndex = lastClickedCell.cellIndex + 1;
        }
        addColumnToTable(table, insertAtIndex);
        ensureDateHeaderRowExists(table); // Ensure date header row matches new column count
        rebuildAndRenderSummary(); updateAllMergeOverlays();
    }
    async function deleteClickedRowFromActiveTable() {
        if (!lastClickedCell) { showMessage('Click a cell in the row you want to delete.', 'info'); return; }
        const table = document.getElementById(activeTableId); if (!table || !table.tBodies[0]) { showMessage('No active table body found.', 'error'); return; }
        const rowToDelete = lastClickedCell.closest('tr');
        
        if (!rowToDelete || rowToDelete.parentElement.tagName !== 'TBODY') { showMessage('Cannot delete header rows. Click a cell in a data row.', 'error'); return; }
        if (table.tBodies[0].rows.length <= 1) { showMessage('Cannot delete the last data row in the table.', 'error'); return; }
        
        if (await customConfirm('Are you sure you want to delete this row?')) {
            rowToDelete.remove(); 
            lastClickedCell = null; // Clear last clicked cell as it's gone
            deselectAllTableCells(); // Clear any selections
            rebuildAndRenderSummary(); 
            updateAllMergeOverlays(); 
            showMessage('Row deleted.', 'success');
        }
    }
    async function deleteClickedColumnFromActiveTable() {
        if (!lastClickedCell) { showMessage('Click a cell in the column you want to delete.', 'info'); return; }
        const table = document.getElementById(activeTableId); if (!table) { showMessage('No active table found.', 'error'); return; }
        
        // Check if it's the last column in the time slot header (primary header for columns)
        const timeSlotHeaderRow = Array.from(table.tHead.rows).find(r => !r.classList.contains('date-header-row'));
        if (timeSlotHeaderRow && timeSlotHeaderRow.cells.length <= 1) {
            showMessage('Cannot delete the last column of the table.', 'error'); return;
        } else if (!timeSlotHeaderRow && table.rows[0]?.cells.length <=1) { // Fallback if no proper time slot header
             showMessage('Cannot delete the last column.', 'error'); return;
        }

        const colIndexToDelete = lastClickedCell.cellIndex;
        if (await customConfirm('Are you sure you want to delete this column?')) {
            for (const row of table.rows) {
                if (row.cells[colIndexToDelete]) row.cells[colIndexToDelete].remove();
            }
            lastClickedCell = null; // Clear last clicked cell
            deselectAllTableCells();
            ensureDateHeaderRowExists(table); // Adjust date header row if necessary
            rebuildAndRenderSummary(); 
            updateAllMergeOverlays(); 
            showMessage('Column deleted.', 'success');
        }
    }

    async function clearScheduledNamesFromActiveTable() {
        const activeTableElement = document.getElementById(activeTableId);
        if (!activeTableElement) {
            showMessage('No active table selected to clear names from.', 'error');
            return;
        }

        const activeTableName = activeTableElement.dataset.tableName || activeTableId;
        if (!await customConfirm(`Are you sure you want to clear scheduled names from table "${activeTableName}"? Merged cells with specific content (like 'REHAT') will be retained. This cannot be undone for other cells.`)) {
            showMessage('Operation cancelled.', 'info');
            return;
        }

        showGeneralLoading(true);
        try {
            const allSharedNamesLowerCase = new Set([...namesPagiShared.map(n => String(n).toLowerCase()), ...namesPetangShared.map(n => String(n).toLowerCase())]);
            
            activeTableElement.querySelectorAll('tbody td, tbody th').forEach(cellElement => {
                // Skip cells that are part of an original structural merge (like REHAT blocks)
                // These typically have a data-merge-id and a specific overlay text.
                const overlay = cellElement.querySelector('.merged-cell-overlay');
                if (overlay && overlay.textContent.toUpperCase() === 'REHAT') { // Example: don't clear REHAT
                    return; 
                }
                // If it's a subsumed cell of such a structural merge, also skip.
                if (cellElement.classList.contains('subsumed-cell') && cellElement.dataset.mergeId) {
                    const primaryContainer = activeTableElement.querySelector(`.merged-cell-container[data-merge-id="${cellElement.dataset.mergeId}"] .merged-cell-overlay`);
                    if (primaryContainer && primaryContainer.textContent.toUpperCase() === 'REHAT') {
                        return;
                    }
                }


                let originalText = String( (overlay ? overlay.textContent : cellElement.textContent) || '');
                const parts = originalText.split(' // ');
                let mainContent = parts[0];
                const remarkContent = parts.length > 1 ? ' // ' + parts.slice(1).join(' // ') : '';
                
                const wordsInMain = mainContent.split(/\s+/).filter(w => w.length > 0);
                const keptMainWords = wordsInMain.filter(word => {
                    const cleanWord = word.startsWith('*') ? word.substring(1) : word;
                    return word.startsWith('*') || !allSharedNamesLowerCase.has(cleanWord.toLowerCase());
                });
                
                const newMainContent = keptMainWords.join(' ');
                let finalText = (newMainContent.trim() + remarkContent).trim();
                // If only remark separator is left, clear it.
                if (finalText === "//" && newMainContent.trim() === "") { finalText = ""; }
                
                if (overlay) overlay.textContent = finalText;
                else cellElement.textContent = finalText;
            });
            rebuildAndRenderSummary();
            showMessage(`Scheduled names cleared from table "${activeTableName}" (structural merges like 'REHAT' retained).`, 'success', 4000);
        } catch (error) {
            console.error(`Error clearing names from table "${activeTableName}":`, error);
            showMessage(`Error clearing names: ${error.message}`, 'error');
        } finally {
            showGeneralLoading(false);
        }
    }


    // --- Cell Selection & Merging ---
    // (Keep toggleCellSelectionMode, handleTableCellClick, deselectAllTableCells, mergeSelectedTableCells, unmergeActiveCellIfMerged, updateAllMergeOverlays as they are)
    function toggleCellSelectionMode() {
        selectionMode = !selectionMode; const btn = document.getElementById('selectBtn');
        if(btn) { btn.classList.toggle('active', selectionMode); btn.textContent = selectionMode ? '‚ú® Selecting...' : '‚ú® Select Cells'; }
        if (!selectionMode) deselectAllTableCells(); hideCellAutocompleteSuggestions();
    }
    function handleTableCellClick(event) {
        const cell = event.target.closest('td, th'); if (!cell || !cell.closest(`#${activeTableId}`)) return;
        lastClickedCell = cell;
        if (autocompleteSuggestionsDiv?.style.display === 'block' && !autocompleteSuggestionsDiv.contains(event.target) && activeCellForAutocomplete !== cell) hideCellAutocompleteSuggestions();
        if (selectedNameFromList) { // If a name is selected from the list, try to insert it
            if (cell.tagName === 'TD' || (cell.tagName === 'TH' && cell.closest('tbody'))) { // Only insert into data cells
                const overlay = cell.querySelector('.merged-cell-overlay'); 
                const contentNode = overlay || cell; // Target overlay if exists, else cell itself
                
                const currentCellText = contentNode.textContent;
                const remarkPart = currentCellText.includes(' // ') ? currentCellText.substring(currentCellText.indexOf(' // ')) : '';
                const contentBeforeRemark = currentCellText.split(' // ')[0];
                const starWords = contentBeforeRemark.split(/\s+/).filter(w => w.startsWith('*')).join(' '); // Preserve existing starred words

                let newText = selectedNameFromList;
                if (starWords) { // Append existing starred words to the new name
                    newText += ' ' + starWords;
                }
                newText = (newText.trim() + remarkPart).trim(); // Add back remarks
                
                contentNode.textContent = newText;
                rebuildAndRenderSummary(); 
                showMessage(`Inserted "${selectedNameFromList}".`, 'success', 2500); 
                clearNameSelection(); // Clear selection after insertion
            } else {
                showMessage('Click an editable data cell (not header) to insert the name.', 'info');
            }
            return; // Exit after attempting insertion
        }
        if (selectionMode) { // Handle cell selection for merging
            if (cell.classList.contains('subsumed-cell') || (cell.classList.contains('merged-cell-container') && selectedCells.some(sc => sc !== cell && sc.dataset.mergeId !== cell.dataset.mergeId))) { showMessage('Cannot select subsumed cells or mix different merge groups.', 'warning'); return; }
            cell.classList.toggle('selected');
            if (cell.classList.contains('selected')) selectedCells.push(cell); else selectedCells = selectedCells.filter(c => c !== cell);
        }
    }
    function deselectAllTableCells() {
        selectedCells.forEach(c => c.classList.remove('selected')); selectedCells = [];
    }
    function mergeSelectedTableCells() {
        if (selectedCells.length < 2) { showMessage('Select at least two cells to merge.', 'error'); return; }
        // Check if any selected cell is already part of a merge (either container or subsumed)
        if (selectedCells.some(cell => cell.dataset.mergeId)) { showMessage('Cannot merge cells that are already part of another merge.', 'warning'); deselectAllTableCells(); return; }
        
        // Determine the primary cell (top-left most)
        let primaryCell = selectedCells[0]; 
        let minRowGUI = primaryCell.parentElement.getBoundingClientRect().top; 
        let minColGUI = primaryCell.getBoundingClientRect().left;
        selectedCells.forEach(cell => { 
            const cellRowRect = cell.parentElement.getBoundingClientRect(); 
            const cellRect = cell.getBoundingClientRect(); 
            if (cellRowRect.top < minRowGUI || (cellRowRect.top === minRowGUI && cellRect.left < minColGUI)) { 
                primaryCell = cell; minRowGUI = cellRowRect.top; minColGUI = cellRect.left; 
            } 
        });
        
        // Calculate total width and height of the merge area
        let minLeft = Infinity, maxRight = -Infinity, minTop = Infinity, maxBottom = -Infinity;
        selectedCells.forEach(cell => { 
            const rect = cell.getBoundingClientRect(); 
            minLeft = Math.min(minLeft, rect.left); maxRight = Math.max(maxRight, rect.right); 
            minTop = Math.min(minTop, rect.top); maxBottom = Math.max(maxBottom, rect.bottom); 
        });
        const totalWidth = maxRight - minLeft; const totalHeight = maxBottom - minTop;
        
        const mergeId = `merge-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const overlay = document.createElement('div'); 
        overlay.className = 'merged-cell-overlay';
        overlay.textContent = primaryCell.textContent; // Initial content from primary cell
        overlay.contentEditable = 'true';
        overlay.style.setProperty('--merged-width', `${totalWidth}px`); 
        overlay.style.setProperty('--merged-height', `${totalHeight}px`);
        
        // Add event listeners to the new overlay
        overlay.addEventListener('blur', () => rebuildAndRenderSummary());
        overlay.addEventListener('input', (e) => {
            const text = e.target.textContent; 
            const parentCellForOverlay = e.target.parentElement; // This is the primaryCell
            // Autocomplete logic for overlay (if it's not a header cell type)
            if (parentCellForOverlay && (parentCellForOverlay.tagName === 'TD' || (parentCellForOverlay.tagName === 'TH' && parentCellForOverlay.closest('tbody'))) && !parentCellForOverlay.classList.contains('date-header-cell')) {
                 showCellAutocompleteSuggestions(parentCellForOverlay, text); 
            } else { 
                hideCellAutocompleteSuggestions(); 
            }
        });
        
        primaryCell.innerHTML = ''; // Clear primary cell
        primaryCell.appendChild(overlay);
        primaryCell.classList.add('merged-cell-container'); 
        primaryCell.setAttribute('data-merge-id', mergeId);
        
        selectedCells.forEach(cell => { 
            if (cell !== primaryCell) { 
                cell.textContent = ''; // Clear content of subsumed cells
                cell.classList.add('subsumed-cell'); 
                cell.setAttribute('data-merge-id', mergeId); 
            } 
        });
        
        deselectAllTableCells(); 
        if (selectionMode) toggleCellSelectionMode(); // Optionally turn off selection mode
        showMessage('Cells visually merged.', 'success');
        rebuildAndRenderSummary(); // Update summary after merge
    }
    function unmergeActiveCellIfMerged() {
        const cell = lastClickedCell; 
        if (!cell) { showMessage('Click a merged cell to unmerge.', 'info'); return; }
        
        const containerCell = cell.closest('[data-merge-id]'); // Find the cell with merge-id (could be the cell itself or a parent if clicked on overlay)
        if (!containerCell) { showMessage('The clicked cell is not part of a merge.', 'error'); return; }
        
        const mergeId = containerCell.dataset.mergeId; 
        const table = containerCell.closest('table'); 
        if (!table) { console.error("Unmerge: Table not found for cell."); return; }
        
        const cellsInGroup = table.querySelectorAll(`[data-merge-id="${mergeId}"]`); 
        let originalText = '';
        
        // Find the primary cell of this group to get the text
        const primaryCellInGroup = Array.from(cellsInGroup).find(c => c.classList.contains('merged-cell-container'));
        if (primaryCellInGroup) { 
            const overlay = primaryCellInGroup.querySelector('.merged-cell-overlay'); 
            if (overlay) originalText = overlay.textContent; 
            else originalText = primaryCellInGroup.textContent; // Fallback if overlay somehow missing
        } else if (cellsInGroup.length > 0) { // Fallback if no clear primary, take first cell's text
            originalText = cellsInGroup[0].textContent;
        }
        
        cellsInGroup.forEach(c => { 
            c.removeAttribute('data-merge-id'); 
            c.classList.remove('merged-cell-container', 'subsumed-cell'); 
            const overlayChild = c.querySelector('.merged-cell-overlay'); 
            if (overlayChild) overlayChild.remove(); 
            c.innerHTML = ''; // Clear all inner HTML
        });
        
        // Restore text to the cell that was originally the primary (or the first one if primary not identified)
        if (primaryCellInGroup) primaryCellInGroup.textContent = originalText; 
        else if (cellsInGroup.length > 0) cellsInGroup[0].textContent = originalText;
        
        rebuildAndRenderSummary(); 
        showMessage('Cells unmerged.', 'success');
    }
    function updateAllMergeOverlays() { // Call on resize or when table structure changes
        const activeTable = document.getElementById(activeTableId); if (!activeTable) return;
        const mergedContainers = activeTable.querySelectorAll('.merged-cell-container');
        mergedContainers.forEach(containerCell => {
            const mergeId = containerCell.dataset.mergeId; if (!mergeId) return;
            const overlay = containerCell.querySelector('.merged-cell-overlay'); if (!overlay) return;
            
            const cellsInGroup = Array.from(activeTable.querySelectorAll(`[data-merge-id="${mergeId}"]`)); 
            if (cellsInGroup.length === 0) return; // Should not happen if containerCell exists
            
            let minLeft = Infinity, maxRight = -Infinity, minTop = Infinity, maxBottom = -Infinity;
            cellsInGroup.forEach(cellInvolved => { 
                const rect = cellInvolved.getBoundingClientRect(); 
                minLeft = Math.min(minLeft, rect.left); maxRight = Math.max(maxRight, rect.right); 
                minTop = Math.min(minTop, rect.top); maxBottom = Math.max(maxBottom, rect.bottom); 
            });
            
            if (minLeft === Infinity) return; // No valid rects
            overlay.style.setProperty('--merged-width', `${maxRight - minLeft}px`);
            overlay.style.setProperty('--merged-height', `${maxBottom - minTop}px`);
        });
    }


    // --- Name List Management ---
    // (Keep handleNameListSessionSwitch, highlightSelectedNameInList, clearNameSelection, closeNameModal, toggleNameListModalVisibility, renderNameListFromFirestore, selectNameForCellInsertion, handleNameListImportFirestore as they are)
    function handleNameListSessionSwitch(session) {
        currentNameListSession = session; 
        if(namePagiTabElement) namePagiTabElement.classList.toggle('active', session === 'pagi'); 
        if(namePetangTabElement) namePetangTabElement.classList.toggle('active', session === 'petang'); 
        if(nameModalTitleElement) nameModalTitleElement.textContent = `Shared Name List Manager (${session === 'pagi' ? 'Pagi' : 'Petang'})`; 
        if(searchNameInputElement) searchNameInputElement.value = ''; // Clear search on session switch
        renderNameListFromFirestore(); // Re-render list for the new session
        hideCellAutocompleteSuggestions(); // Hide any open suggestions
    }
    function highlightSelectedNameInList(nameToHighlight) {
        if (!nameListContainer) return; 
        const nameToHighlightStr = String(nameToHighlight || '');
        nameListContainer.querySelectorAll('.name-item span').forEach(span => 
            span.classList.toggle('highlighted', String(span.dataset.name || '') === nameToHighlightStr)
        );
    }
    function clearNameSelection() {
        selectedNameFromList = null; 
        if (nameListContainer) nameListContainer.querySelectorAll('.name-item span.highlighted').forEach(span => span.classList.remove('highlighted'));
    }
    function closeNameModal() {
        if (nameModal) nameModal.style.display = 'none'; 
        clearNameSelection(); 
        if(searchNameInputElement) searchNameInputElement.value = ''; // Clear search on close
    }
    function toggleNameListModalVisibility() {
        if (!nameModal || !nameModalContent || !newNameInput) return;
        const isDisplayed = nameModal.style.display === 'flex';
        if (isDisplayed) {
            closeNameModal();
        } else {
            // Reset modal position if it was dragged
            nameModalContent.style.position = 'relative'; 
            nameModalContent.style.left = 'auto';
            nameModalContent.style.top = 'auto';
            nameModalContent.style.transform = 'none';
            nameModal.style.display = 'flex'; 
            if(searchNameInputElement) searchNameInputElement.value = ''; // Clear search on open
            handleNameListSessionSwitch(currentNameListSession); // Ensure correct session is displayed
            if(newNameInput) newNameInput.focus(); 
            clearNameSelection(); // Clear any previous name selection
        }
        hideCellAutocompleteSuggestions(); // Hide any cell suggestions when opening/closing name modal
    }
    function renderNameListFromFirestore(filterText = '') {
        if (!nameListContainer) return; 
        if (!fbIsAuthReady && fbDb) { // Check fbDb too, as fbIsAuthReady might be false during initial auth
             nameListContainer.innerHTML = '<p>Authenticating to load names...</p>'; 
             return; 
        } else if (!fbDb) {
            nameListContainer.innerHTML = '<p>Firebase not initialized.</p>';
            return;
        }
        nameListContainer.innerHTML = ''; // Clear previous list
        const namesToRender = currentNameListSession === 'pagi' ? namesPagiShared : namesPetangShared;
        const normalizedFilterText = String(filterText || '').toLowerCase().trim();

        if (!Array.isArray(namesToRender)) { 
            nameListContainer.innerHTML = '<p>Error: Name list is invalid or not loaded.</p>'; 
            console.error("renderNameListFromFirestore: namesToRender is not an array.", namesToRender);
            return; 
        }
        const filteredNames = namesToRender.filter(name => String(name || '').toLowerCase().trim().includes(normalizedFilterText));
        
        if (filteredNames.length === 0) { 
            nameListContainer.innerHTML = `<p>${normalizedFilterText ? 'No names match your search.' : `No names found in the ${currentNameListSession} session list.`}</p>`; 
            return; 
        }
        filteredNames.forEach(name => { 
            const itemDiv = document.createElement('div'); 
            itemDiv.className = 'name-item'; 
            const nameStr = String(name || ''); 
            const safeNameAttr = nameStr.replace(/"/g, '&quot;'); // Sanitize for attribute
            itemDiv.innerHTML = `<span data-name="${safeNameAttr}" title="Select '${safeNameAttr}' for insertion">${nameStr}</span><button data-name-delete="${safeNameAttr}" title="Delete '${safeNameAttr}' from shared list">Delete</button>`; 
            nameListContainer.appendChild(itemDiv); 
        });
        highlightSelectedNameInList(selectedNameFromList); // Re-apply highlight if a name was selected
    }
    function selectNameForCellInsertion(name) {
        selectedNameFromList = String(name || ''); 
        highlightSelectedNameInList(selectedNameFromList);
        showMessage(`Selected "${selectedNameFromList}". Click a data cell in the schedule to insert.`, 'info', 4000);
    }
    function handleNameListImportFirestore(event) { // For .txt import
        const file = event.target.files[0]; 
        if (!file) { showMessage('No file selected for import.', 'info'); return; }
        if (file.type !== 'text/plain') { showMessage('Invalid file type. Please select a .txt file.', 'error'); event.target.value = ''; return; }
        
        const reader = new FileReader();
        reader.onload = async (e) => {
            try {
                const importedNames = e.target.result.split(/\r?\n/) // Split by newline
                                          .map(n => String(n||'').trim()) // Trim whitespace
                                          .filter(n => n); // Remove empty lines
                if (importedNames.length === 0) { showMessage('No valid names found in the selected file.', 'info'); return; }
                
                const currentSessionNames = (currentNameListSession === 'pagi' ? namesPagiShared : namesPetangShared).map(n => String(n||'').trim());
                // Combine and remove duplicates (case-insensitive for checking, but preserve original casing from import for new names)
                const combinedNamesSet = new Set(currentSessionNames.map(n => n.toLowerCase()));
                const newNamesToAdd = [];
                importedNames.forEach(importedName => {
                    if (!combinedNamesSet.has(importedName.toLowerCase())) {
                        newNamesToAdd.push(importedName); // Add with original casing
                        combinedNamesSet.add(importedName.toLowerCase()); // Add to set to prevent duplicates from within the file
                    }
                });
                const finalNamesArray = [...currentSessionNames, ...newNamesToAdd]; // Keep existing, add new unique
                
                await saveSharedNameListToFirestore(currentNameListSession, finalNamesArray);
                showMessage(`${newNamesToAdd.length} new names imported to ${currentNameListSession} session.`, 'success');
            } catch (error) { 
                console.error("Error processing name list file:", error);
                showMessage('Error processing the name list file.', 'error'); 
            }
            finally { event.target.value = ''; } // Reset file input
        };
        reader.onerror = () => { showMessage('Failed to read the name list file.', 'error'); event.target.value = ''; };
        reader.readAsText(file);
    }


    // --- Excel Import/Export ---
    // (Keep handleExcelFileImport, exportActiveTableToExcel as they are)
    function handleExcelFileImport(event) {
        const file = event.target.files[0]; if (!file || !tablesContainer) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const workbook = XLSX.read(new Uint8Array(e.target.result), { type: 'array', cellDates: true }); // cellDates: true to parse dates
                const sheetName = workbook.SheetNames[0]; // Use the first sheet
                const worksheet = workbook.Sheets[sheetName];
                // Convert sheet to HTML table string. raw: false attempts to format values (e.g., dates)
                const htmlTableString = XLSX.utils.sheet_to_html(worksheet, { raw: false }); 
                
                tableCount++;
                const newTableId = `tbl_imported_${Date.now()}_${tableCount}`;
                const importedTableName = file.name.replace(/\.xlsx?$/i, '') || `Imported Sheet ${tableCount}`;
                
                const tempDiv = document.createElement('div'); tempDiv.innerHTML = htmlTableString;
                const importedTableElement = tempDiv.querySelector('table');
                
                if (importedTableElement) {
                    importedTableElement.id = newTableId;
                    importedTableElement.dataset.tableName = importedTableName;
                    // Ensure standard structure for the imported table
                    ensureDateHeaderRowExists(importedTableElement); // Add date header if missing
                    // Make all cells editable
                    importedTableElement.querySelectorAll('td, th, .merged-cell-overlay').forEach(cell => cell.contentEditable = 'true');
                    
                    tablesContainer.appendChild(importedTableElement);
                    addTabButton(newTableId, importedTableName);
                    switchTable(newTableId); // Switch to the newly imported table
                    showMessage(`Excel data from sheet "${sheetName}" imported successfully!`, 'success');
                } else {
                    showMessage('Could not parse a valid table structure from the Excel file.', 'error');
                }
            } catch (error) { 
                showMessage('Error processing the Excel file. It might be corrupted or in an unsupported format.', 'error'); 
                console.error("Excel import error:", error); 
            }
            finally { event.target.value = ''; } // Reset file input
        };
        reader.readAsArrayBuffer(file);
    }
    function exportActiveTableToExcel() {
        const tableToExport = document.getElementById(activeTableId); 
        if (!tableToExport) { showMessage('No active table to export.', 'error'); return; }
        
        // Temporarily replace merged cell overlays with their text content for export
        const overlaysData = [];
        tableToExport.querySelectorAll('.merged-cell-overlay').forEach(overlay => { 
            const parentCell = overlay.parentElement; 
            overlaysData.push({ parent: parentCell, originalHTML: parentCell.innerHTML }); 
            parentCell.textContent = overlay.textContent; // Replace with text
        });
        
        const tableName = tableToExport.dataset.tableName || activeTableId;
        // Create a workbook and add the table
        const wb = XLSX.utils.table_to_book(tableToExport, { sheet: tableName });
        XLSX.writeFile(wb, `${tableName}_${new Date().toISOString().split('T')[0]}.xlsx`);
        
        // Restore original merged cell overlays
        overlaysData.forEach(data => {
            data.parent.innerHTML = data.originalHTML;
            // Re-attach event listeners if they were on the overlay itself and got removed
            const newOverlay = data.parent.querySelector('.merged-cell-overlay');
            if (newOverlay) {
                newOverlay.addEventListener('blur', () => rebuildAndRenderSummary());
                newOverlay.addEventListener('input', (e) => { 
                    const text = e.target.textContent; 
                    const parentCellForOverlay = e.target.parentElement; 
                    if (parentCellForOverlay && (parentCellForOverlay.tagName === 'TD' || (parentCellForOverlay.tagName === 'TH' && parentCellForOverlay.closest('tbody'))) && !parentCellForOverlay.classList.contains('date-header-cell')) {
                        showCellAutocompleteSuggestions(parentCellForOverlay, text); 
                    } else { 
                        hideCellAutocompleteSuggestions(); 
                    }
                });
            }
        });
        if(overlaysData.length > 0) updateAllMergeOverlays(); // Ensure visual consistency
        
        showMessage(`Table "${tableName}" exported to Excel.`, 'success');
    }

    // --- PDF Generation ---
    // (Keep generateSchedulePdf, cloneTableForPdf as they are)
    async function generateSchedulePdf() {
        if (!pdfContentElement || !tablesContainer || !scheduleTitleElement) { showMessage('PDF generation elements not found in the DOM.', 'error'); return; }
        showGeneralLoading(true); showMessage('Generating PDF, please wait...', 'info', 15000); // Extended duration for PDF
        pdfContentElement.innerHTML = ''; // Clear previous PDF content

        const tablesToPrint = tablesContainer.querySelectorAll('table');
        const numTables = tablesToPrint.length;

        if (numTables === 0) { // Handle case with no tables
            const pageWrapper = document.createElement('div'); pageWrapper.className = 'pdf-page-wrapper';
            const mainTitleText = scheduleTitleElement.textContent || 'Weekly Schedule';
            const mainTitleH2 = document.createElement('h2'); mainTitleH2.textContent = mainTitleText; pageWrapper.appendChild(mainTitleH2);
            const noTablesMessage = document.createElement('p'); noTablesMessage.textContent = "No tables available to print."; noTablesMessage.style.textAlign = "center"; pageWrapper.appendChild(noTablesMessage);
            const footnoteDiv = document.createElement('div'); footnoteDiv.className = 'pdf-footnote'; const today = new Date(); const dateOptions = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }; footnoteDiv.textContent = `Generated: ${today.toLocaleDateString(undefined, dateOptions)}`; pageWrapper.appendChild(footnoteDiv);
            pdfContentElement.appendChild(pageWrapper);
        } else {
            tablesToPrint.forEach((tableElement, index) => {
                const pageWrapper = document.createElement('div'); pageWrapper.className = 'pdf-page-wrapper';
                if (index === 0) { // Add main title only to the first page (or before first table)
                    const mainTitleText = scheduleTitleElement.textContent || 'Weekly Schedule'; 
                    const mainTitleH2 = document.createElement('h2'); mainTitleH2.textContent = mainTitleText; 
                    pageWrapper.appendChild(mainTitleH2); 
                }
                const tableId = tableElement.id; 
                const tableName = tableElement.dataset.tableName || tableId || `Table ${index + 1}`;
                const tableTitleH3 = document.createElement('h3'); tableTitleH3.textContent = tableName; 
                pageWrapper.appendChild(tableTitleH3);
                
                const clonedTable = cloneTableForPdf(tableElement); // Clone and prepare table for PDF
                if (clonedTable) pageWrapper.appendChild(clonedTable); 
                else { const errorMsg = document.createElement('p'); errorMsg.textContent = `Error: Table "${tableName}" could not be generated for PDF.`; pageWrapper.appendChild(errorMsg); }
                
                const footnoteDiv = document.createElement('div'); footnoteDiv.className = 'pdf-footnote'; 
                const today = new Date(); const dateOptions = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }; 
                footnoteDiv.textContent = `Generated: ${today.toLocaleDateString(undefined, dateOptions)}`; 
                pageWrapper.appendChild(footnoteDiv);
                pdfContentElement.appendChild(pageWrapper);
            });
        }

        pdfContentElement.style.display = 'block'; // Make content visible for html2pdf

        const pdfOptions = { 
            margin: [5, 5, 5, 5], // Margins in mm [top, left, bottom, right]
            filename: `${(scheduleTitleElement.textContent || 'schedule').replace(/[^a-z0-9]/gi, '_').toLowerCase()}_complete.pdf`, 
            image: { type: 'jpeg', quality: 0.95 }, 
            html2canvas: { 
                scale: 2, // Higher scale for better quality
                useCORS: true, 
                logging: false, 
                scrollX: 0, 
                scrollY: -window.scrollY, // Try to capture from top
                windowWidth: pdfContentElement.scrollWidth, 
                windowHeight: pdfContentElement.scrollHeight,
                removeContainer: true // Clean up cloned container by html2canvas
            }, 
            jsPDF: { unit: 'mm', format: 'a4', orientation: 'landscape' },
            pagebreak: { mode: ['css', 'legacy'], before: '.pdf-page-wrapper:not(:first-child)', avoid: ['h2', 'h3', 'table', 'tr', 'thead', 'tbody', '.pdf-footnote'] } 
        };
        
        try { 
            await html2pdf().from(pdfContentElement).set(pdfOptions).save(); 
            showMessage('PDF downloaded successfully!', 'success'); 
        }
        catch (error) { 
            console.error('Error generating PDF:', error); 
            showMessage(`PDF generation failed. Error: ${error.message}. Check console for details.`, 'error', 10000); 
        }
        finally { 
            pdfContentElement.style.display = 'none'; // Hide after processing
            showGeneralLoading(false); 
        }
    }
    function cloneTableForPdf(originalTable) {
        if (!originalTable || typeof originalTable.cloneNode !== 'function') { console.error("cloneTableForPdf Error: Invalid originalTable provided:", originalTable); return null; }
        const tableIdForLog = originalTable.id || 'Unknown Table ID';
        
        const clonedTable = originalTable.cloneNode(true); // Deep clone
        clonedTable.removeAttribute('id'); // Remove ID to avoid duplicates in main DOM if ever appended
        clonedTable.classList.remove('active'); // Remove active class
        clonedTable.style.width = '100%'; // Ensure full width in PDF
        clonedTable.style.tableLayout = 'fixed'; // Fixed layout for PDF consistency
        clonedTable.style.fontSize = '7pt'; // Smaller font for PDF

        // Remove contentEditable from all elements in the cloned table
        clonedTable.querySelectorAll('[contenteditable="true"]').forEach(el => el.removeAttribute('contenteditable'));

        // Process merged cells for PDF (converting overlay merges to rowspan/colspan)
        const mergeGroups = {}; // To store info about each merge group
        
        // First pass: identify all merge groups and their primary cells from the original table
        Array.from(originalTable.rows).forEach((originalRow, rowIndex) => {
            Array.from(originalRow.cells).forEach((originalCell, colIndex) => {
                const mergeId = originalCell.dataset.mergeId; 
                if (!mergeId) return; // Not part of a merge

                if (!mergeGroups[mergeId]) {
                    mergeGroups[mergeId] = { 
                        minRow: rowIndex, maxRow: rowIndex, 
                        minCol: colIndex, maxCol: colIndex, 
                        primaryCellOriginal: null, 
                        allOriginalCellsInGroup: [] 
                    };
                }
                const group = mergeGroups[mergeId];
                group.allOriginalCellsInGroup.push(originalCell);
                group.minRow = Math.min(group.minRow, rowIndex); group.maxRow = Math.max(group.maxRow, rowIndex);
                group.minCol = Math.min(group.minCol, colIndex); group.maxCol = Math.max(group.maxCol, colIndex);
                
                if (originalCell.classList.contains('merged-cell-container')) {
                    group.primaryCellOriginal = originalCell;
                }
            });
        });

        // Second pass: apply rowspan/colspan to the cloned table
        for (const mergeId in mergeGroups) {
            const group = mergeGroups[mergeId];
            if (!group.primaryCellOriginal) { 
                console.warn(`cloneTableForPdf (${tableIdForLog}): No primary cell found for mergeId: ${mergeId}. Skipping this merge for PDF.`); 
                continue; 
            }

            const rowSpan = group.maxRow - group.minRow + 1;
            const colSpan = group.maxCol - group.minCol + 1;

            // Find the corresponding primary cell in the cloned table
            // This requires knowing the original primary cell's row/col index
            let primaryCellOriginalRowIndex = -1, primaryCellOriginalColIndex = -1;
            // Find indices of primaryCellOriginal within originalTable.rows
            for(let rIdx = 0; rIdx < originalTable.rows.length; rIdx++) {
                const cIdx = Array.from(originalTable.rows[rIdx].cells).indexOf(group.primaryCellOriginal);
                if (cIdx !== -1) {
                    primaryCellOriginalRowIndex = rIdx;
                    primaryCellOriginalColIndex = cIdx;
                    break;
                }
            }
            
            if (primaryCellOriginalRowIndex === -1 || primaryCellOriginalColIndex === -1) {
                console.warn(`cloneTableForPdf (${tableIdForLog}): Could not find original primary cell's indices for mergeId ${mergeId}. Skipping PDF merge.`);
                continue;
            }

            const clonedPrimaryCell = clonedTable.rows[primaryCellOriginalRowIndex]?.cells[primaryCellOriginalColIndex];
            
            if (clonedPrimaryCell) {
                const overlayOriginal = group.primaryCellOriginal.querySelector('.merged-cell-overlay');
                clonedPrimaryCell.textContent = overlayOriginal ? overlayOriginal.textContent : group.primaryCellOriginal.textContent; // Set text from overlay
                
                // Remove overlay div from cloned cell
                const overlayCloned = clonedPrimaryCell.querySelector('.merged-cell-overlay'); 
                if (overlayCloned) overlayCloned.remove();
                clonedPrimaryCell.classList.remove('merged-cell-container'); // Remove container class

                if (rowSpan > 1) clonedPrimaryCell.rowSpan = rowSpan;
                if (colSpan > 1) clonedPrimaryCell.colSpan = colSpan;

                // Remove subsumed cells from the cloned table
                const cellsToRemoveFromClonedTable = [];
                group.allOriginalCellsInGroup.forEach(originalSubsumedCell => {
                    if (originalSubsumedCell === group.primaryCellOriginal) return; // Don't remove the primary cell itself

                    // Find indices of originalSubsumedCell
                    let subsumedOriginalRowIndex = -1, subsumedOriginalColIndex = -1;
                    for(let rIdx = 0; rIdx < originalTable.rows.length; rIdx++) {
                        const cIdx = Array.from(originalTable.rows[rIdx].cells).indexOf(originalSubsumedCell);
                        if (cIdx !== -1) {
                            subsumedOriginalRowIndex = rIdx;
                            subsumedOriginalColIndex = cIdx;
                            break;
                        }
                    }
                    if (subsumedOriginalRowIndex !== -1 && subsumedOriginalColIndex !== -1) {
                        const clonedSubsumedCell = clonedTable.rows[subsumedOriginalRowIndex]?.cells[subsumedOriginalColIndex];
                        // Important: Only add to removal list if it's not the primary cell we just modified
                        if (clonedSubsumedCell && clonedSubsumedCell !== clonedPrimaryCell) {
                             cellsToRemoveFromClonedTable.push(clonedSubsumedCell);
                        }
                    }
                });
                // Remove in reverse order or carefully to avoid index issues, though direct removal should be fine
                cellsToRemoveFromClonedTable.forEach(cell => cell.remove());
            } else {
                console.warn(`cloneTableForPdf (${tableIdForLog}): Cloned primary cell not found for mergeId: ${mergeId}. PDF merge might be incorrect.`);
            }
        }
        return clonedTable;
    }


    // --- Summary Table Logic ---
    function getTextForSummary(cellText) {
        if (typeof cellText !== 'string') return ''; 
        let textForSummary = cellText.split(' // ')[0]; // Get content before remarks
        // Remove star-prefixed words for summary matching, but keep them for display if they are the only content
        const words = textForSummary.split(/\s+/); 
        const filteredWords = words.filter(word => !word.startsWith('*'));
        return filteredWords.join(' ').trim(); // Return only non-starred words, trimmed
    }

    function parseTimeToMinutes(timeStr) {
        if (typeof timeStr !== 'string') return Infinity; // Handle non-string inputs
        // Try to match HH:MM or HH.MM format, allowing for optional spaces around separator
        const match = timeStr.match(/^(\d{1,2})\s*[:.]\s*(\d{2})/);
        if (match) {
            return parseInt(match[1], 10) * 60 + parseInt(match[2], 10);
        }
        // Fallback for simple hour numbers like "8" or "12" (less precise, assumes start of hour)
        const hourMatch = timeStr.match(/^(\d{1,2})$/);
        if (hourMatch) {
            return parseInt(hourMatch[1], 10) * 60;
        }
        return Infinity; // Return Infinity if format is not recognized, for sorting
    }
    
    function normalizeHeaderForLookup(header) {
        if (typeof header !== 'string') return '';
        return header.replace(/\s/g, "").replace(/:/g,".").toLowerCase(); // Consistent format for matching
    }


    function buildSummaryTableSkeleton(allAvailableNames) {
        if (!summaryTableElement) { console.error("buildSummaryTableSkeleton: summaryTableElement not found."); return; }
        summaryTableElement.innerHTML = ''; // Clear previous summary

        let allScheduleTableHeaders = new Set();
        if (tablesContainer) {
            tablesContainer.querySelectorAll('table').forEach(scheduleTable => {
                if (!scheduleTable.tHead) return;
                const timeSlotHeaderRow = Array.from(scheduleTable.tHead.rows).find(row => !row.classList.contains('date-header-row'));
                if (timeSlotHeaderRow) {
                    for (let hIdx = 1; hIdx < timeSlotHeaderRow.cells.length; hIdx++) { // Skip first "Class" column
                        const headerText = String(timeSlotHeaderRow.cells[hIdx].textContent || '').trim();
                        if (headerText) allScheduleTableHeaders.add(headerText);
                    }
                }
            });
        }

        // LAU/LISAH rule: if they are in "10.30-12.00", add "10.15-10.30" to summary headers
        let laulisahRuleRequiresSpecialSlot = false;
        const specialNamesForRule = ["LAU", "LISAH"];
        const targetSlotForSpecialNamesRule = "10.15-10.30";
        const sourceSlotForRule = "10.30-12.00";
        const normalizedSourceSlotForRule = normalizeHeaderForLookup(sourceSlotForRule);

        if (tablesContainer) {
            for (const scheduleTable of tablesContainer.querySelectorAll('table')) {
                if (laulisahRuleRequiresSpecialSlot) break;
                if (!scheduleTable.tHead || !scheduleTable.tBodies[0]) continue;
                
                const timeSlotHeaderRow = Array.from(scheduleTable.tHead.rows).find(row => !row.classList.contains('date-header-row'));
                if (!timeSlotHeaderRow) continue;
                const currentScheduleTableHeaders = Array.from(timeSlotHeaderRow.cells).map(th => String(th.textContent||'').trim());

                Array.from(scheduleTable.tBodies[0].rows).forEach((scheduleDataRow) => {
                    if (laulisahRuleRequiresSpecialSlot) return;
                    for (let cellIdx = 1; cellIdx < scheduleDataRow.cells.length; cellIdx++) {
                         const scheduleCell = scheduleDataRow.cells[cellIdx];
                         let entryInScheduleCellFull = String(scheduleCell.querySelector('.merged-cell-overlay')?.textContent || scheduleCell.textContent||'').trim();
                         let entryInScheduleCellForRule = getTextForSummary(entryInScheduleCellFull); // Get name without stars/remarks
                         if (specialNamesForRule.some(specialName => entryInScheduleCellForRule.toUpperCase().includes(specialName))) { // Check if LAU or LISAH is in the cell
                            const headerText = currentScheduleTableHeaders[cellIdx];
                            if (headerText && normalizeHeaderForLookup(headerText) === normalizedSourceSlotForRule) {
                                laulisahRuleRequiresSpecialSlot = true; 
                                return; 
                            }
                         }
                    }
                });
            }
        }
        if (laulisahRuleRequiresSpecialSlot) {
            allScheduleTableHeaders.add(targetSlotForSpecialNamesRule);
        }
        
        // Sort all unique headers chronologically
        let sortedUniqueHeaders = Array.from(allScheduleTableHeaders).sort((a, b) => {
            const timeA = parseTimeToMinutes(a);
            const timeB = parseTimeToMinutes(b);
            if (timeA !== Infinity && timeB !== Infinity) return timeA - timeB;
            if (timeA !== Infinity) return -1; // Valid times first
            if (timeB !== Infinity) return 1;
            return String(a).localeCompare(String(b)); // Fallback to string sort for non-time headers
        });

        const finalSummaryColumnHeaders = ['Nama/Masa', ...sortedUniqueHeaders];
        const thead = summaryTableElement.createTHead(); 
        const headerRowForSummary = thead.insertRow();
        finalSummaryColumnHeaders.forEach(headerText => { 
            const th = document.createElement('th'); 
            th.textContent = headerText; 
            headerRowForSummary.appendChild(th); 
        });
        
        const tbody = summaryTableElement.createTBody();
        if (allAvailableNames.length === 0 && sortedUniqueHeaders.length === 0) { 
            const tr = tbody.insertRow(); const td = tr.insertCell(); 
            td.textContent = "No names scheduled and no time slots defined."; 
            td.colSpan = finalSummaryColumnHeaders.length || 1; 
            td.style.textAlign = 'center'; td.style.fontStyle = 'italic'; 
        } else if (allAvailableNames.length === 0) { 
            const tr = tbody.insertRow(); const td = tr.insertCell(); 
            td.textContent = "No names found in any schedule."; 
            td.colSpan = finalSummaryColumnHeaders.length || 1; 
            td.style.textAlign = 'center'; td.style.fontStyle = 'italic'; 
        } else { 
            allAvailableNames.forEach(name => { 
                const tr = tbody.insertRow(); 
                tr.insertCell().textContent = String(name || ''); // Name column
                for (let i = 1; i < finalSummaryColumnHeaders.length; i++) {
                    tr.insertCell().textContent = ''; // Empty cells for time slots
                }
            }); 
        }
    }

    function updateSummaryTableData(allAvailableNames) {
        if (!summaryTableElement?.tBodies?.[0] || !summaryTableElement.tHead?.rows?.[0]) {
            console.warn("updateSummaryTableData: Summary table structure not ready.");
            return;
        }
        const summaryBody = summaryTableElement.tBodies[0];
        const summaryHeaderCells = Array.from(summaryTableElement.tHead.rows[0].cells);
        const summaryTableDisplayHeaders = summaryHeaderCells.map(th => String(th.textContent||'').trim());
        const normalizedSummaryHeadersForLookup = summaryTableDisplayHeaders.map(normalizeHeaderForLookup);

        // Reset summary table content before repopulating
        Array.from(summaryBody.rows).forEach(summaryRow => {
            for (let i = 1; i < summaryRow.cells.length; i++) { // Skip name cell
                const cell = summaryRow.cells[i];
                cell.textContent = '';
                cell.removeAttribute('colspan');
                cell.style.display = 'table-cell'; // Make sure it's visible
                cell.style.backgroundColor = ''; // Reset background
                cell.classList.remove('highlight-conflict', 'summary-merged-cell');
                cell.removeAttribute('data-temp-classes');
            }
        });


        allAvailableNames.forEach(name => {
            const targetSummaryRow = Array.from(summaryBody.rows).find(sr => sr.cells[0]?.textContent === name);
            if (!targetSummaryRow) return;

            tablesContainer.querySelectorAll('table').forEach(scheduleTable => {
                if (!scheduleTable.tHead || !scheduleTable.tBodies[0]) return;
                const timeSlotHeaderRow = Array.from(scheduleTable.tHead.rows).find(row => !row.classList.contains('date-header-row'));
                if (!timeSlotHeaderRow) return;
                const scheduleHeaders = Array.from(timeSlotHeaderRow.cells).map(th => String(th.textContent||'').trim());

                scheduleTable.tBodies[0].querySelectorAll('tr').forEach(scheduleDataRow => {
                    const classIdentifier = String(scheduleDataRow.cells[0]?.textContent||'').trim();
                    if (!classIdentifier) return;

                    for (let cellIdx = 1; cellIdx < scheduleDataRow.cells.length; /* cellIdx incremented inside */) {
                        const scheduleCell = scheduleDataRow.cells[cellIdx];
                        let currentOriginalHeader = scheduleHeaders[cellIdx];
                        if (!currentOriginalHeader) { cellIdx++; continue; } // Skip if no header for this cell

                        const overlay = scheduleCell.querySelector('.merged-cell-overlay');
                        let actualEntryForSummary = getTextForSummary(overlay ? overlay.textContent : scheduleCell.textContent);
                        
                        if (actualEntryForSummary.toUpperCase().includes(name.toUpperCase())) { // Check if name is part of the cell
                            let blockOriginalStartHeader = currentOriginalHeader;
                            let blockOriginalEndHeader = currentOriginalHeader;
                            let numCellsInBlockInOriginal = 1;

                            // LAU/LISAH remapping
                            const specialNamesForRule = ["LAU", "LISAH"];
                            const targetSlotForSpecialNamesRule = "10.15-10.30";
                            const sourceSlotForRule = "10.30-12.00";
                            const isLauLisahSpecialCase = specialNamesForRule.some(sn => name.toUpperCase() === sn) &&
                                                         normalizeHeaderForLookup(currentOriginalHeader) === normalizeHeaderForLookup(sourceSlotForRule);

                            if (isLauLisahSpecialCase) {
                                blockOriginalStartHeader = targetSlotForSpecialNamesRule;
                                blockOriginalEndHeader = targetSlotForSpecialNamesRule;
                            } else {
                                // Look ahead for contiguous blocks of the same name in the original table
                                // This needs to respect original table's merges if any.
                                // For simplicity, if original cell is merged, treat its text as applying to its first logical column.
                                // A more complex merge detection in original table would be needed for perfect block detection.
                                // Current getTextForSummary simplifies this.
                                for (let nextCellIdx = cellIdx + 1; nextCellIdx < scheduleDataRow.cells.length; nextCellIdx++) {
                                    const nextScheduleCell = scheduleDataRow.cells[nextCellIdx];
                                    const nextOriginalHeader = scheduleHeaders[nextCellIdx];
                                    if (!nextOriginalHeader) break; // No more headers

                                    const nextOverlay = nextScheduleCell.querySelector('.merged-cell-overlay');
                                    const nextEntry = getTextForSummary(nextOverlay ? nextOverlay.textContent : nextScheduleCell.textContent);
                                    
                                    if (nextEntry.toUpperCase().includes(name.toUpperCase())) {
                                        blockOriginalEndHeader = nextOriginalHeader;
                                        numCellsInBlockInOriginal++;
                                    } else {
                                        break;
                                    }
                                }
                            }

                            const summaryStartColIdx = normalizedSummaryHeadersForLookup.indexOf(normalizeHeaderForLookup(blockOriginalStartHeader));
                            const summaryEndColIdx = normalizedSummaryHeadersForLookup.indexOf(normalizeHeaderForLookup(blockOriginalEndHeader));

                            if (summaryStartColIdx > 0 && summaryEndColIdx >= summaryStartColIdx) {
                                const summaryCellToProcess = targetSummaryRow.cells[summaryStartColIdx];
                                if (!summaryCellToProcess) { cellIdx += numCellsInBlockInOriginal; continue;}


                                let tempClasses = summaryCellToProcess.dataset.tempClasses ? summaryCellToProcess.dataset.tempClasses.split(',') : [];
                                if (!tempClasses.includes(classIdentifier)) {
                                    tempClasses.push(classIdentifier);
                                }
                                summaryCellToProcess.dataset.tempClasses = tempClasses.join(',');
                                
                                const colspanRequired = summaryEndColIdx - summaryStartColIdx + 1;
                                const currentColspan = parseInt(summaryCellToProcess.getAttribute('colspan') || '1');
                                if (colspanRequired > currentColspan) {
                                    summaryCellToProcess.colSpan = colspanRequired;
                                }
                            }
                            cellIdx += numCellsInBlockInOriginal;
                        } else {
                            cellIdx++;
                        }
                    }
                });
            });
        });

        // Second pass: set text content, apply styles, and hide subsumed cells
        Array.from(summaryBody.rows).forEach(summaryRow => {
            for (let j = 0; j < summaryRow.cells.length; /* j incremented inside */) {
                const currentCell = summaryRow.cells[j];
                if (!currentCell) { j++; continue; } // Should not happen

                if (currentCell.dataset.tempClasses) {
                    currentCell.textContent = currentCell.dataset.tempClasses.split(',').sort().join(', ');
                    currentCell.removeAttribute('data-temp-classes');
                    if (currentCell.textContent.includes(',')) {
                        currentCell.classList.add('highlight-conflict');
                    }
                }

                const currentCellColspan = parseInt(currentCell.getAttribute('colspan') || '1');
                if (currentCellColspan > 1) {
                    currentCell.classList.add('summary-merged-cell'); // Apply specific class for styling
                    for (let k = 1; k < currentCellColspan; k++) {
                        if (summaryRow.cells[j + k]) {
                            summaryRow.cells[j + k].style.display = 'none';
                            summaryRow.cells[j + k].textContent = ''; // Clear content of hidden cells
                        }
                    }
                }
                j += currentCellColspan;
            }
        });
    }

</script>
</body>
</html>
