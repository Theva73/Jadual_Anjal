<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title></title> <!-- Empty title by default -->

  <!-- Load SheetJS via CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

  <style>
    body { font-family: Arial, Helvetica, sans-serif; margin: 28px }
    h2 { margin: 0 0 12px }
    table { border-collapse: collapse; width: 100%; margin-top: 10px }
    th, td { border: 1px solid #999; padding: 8px; text-align: center; min-width: 90px; position: relative }
    th { background: #f2f2f2 } /* Grey color for table header row */
    td.selected, th.selected { outline: 3px solid #ffdf6a }
    .merged { background: #e0e0e0; font-style: italic; }
    .bar { display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 10px }
    .bar button { padding: 8px 12px; font-size: 14px; border-radius: 4px; cursor: pointer; border: 1px solid #666; background: #fff }
    #excelBtn { background: #2e8b57; color: #fff; border: none }
    #saveDraftBtn { background: #0b65c2; color: #fff; border: none }
    #loadDraftBtn { background: #ff8c00; color: #fff; border: none }
    #mergeBtn { background: #6a5acd; color: #fff; border: none }
    #unmergeBtn { background: #cd5c5c; color: #fff; border: none }
    #msg { color: #c00; margin-top: 10px; display: none }
    #draftList { margin-top: 10px; padding: 5px; border: 1px solid #ccc; max-height: 150px; overflow-y: auto; display: none; }
    #draftList div { padding: 5px; cursor: pointer; }
    #draftList div:hover { background: #f0f0f0; }
    #fileInput { display: none; }
  </style>
</head>
<body>
  <!-- Page header, completely empty by default but editable -->
  <h2 contenteditable="true"></h2>

  <!-- ===== persistence & export ===== -->
  <div class="bar">
    <button id="excelBtn" onclick="promptExcelExport()">üíæ Save to Excel</button>
    <input type="file" id="fileInput" accept=".xlsx" onchange="handleExcelFile(event)" style="display: none;" />
    <button id="saveDraftBtn" onclick="promptSaveDraft()">üí† Save Draft</button>
    <button id="loadDraftBtn" onclick="toggleDraftList()">üìÇ Load Draft</button>
    <button onclick="clearDraft()">üóëÔ∏è Clear Draft</button>
    <button id="mergeBtn" onclick="mergeCells()">üîó Merge Cells</button>
    <button id="unmergeBtn" onclick="unmergeCells()">üîó Unmerge Cells</button>
  </div>

  <!-- Draft list for loading -->
  <div id="draftList"></div>

  <!-- ===== targeted actions ===== -->
  <div class="bar">
    <button onclick="addRowAbove()">‚¨ÜÔ∏è Row Above</button>
    <button onclick="addRowBelow()">‚¨áÔ∏è Row Below</button>
    <button onclick="addColLeft()">‚¨ÖÔ∏è Col Left</button>
    <button onclick="addColRight()">‚û°Ô∏è Col Right</button>
  </div>

  <table id="tbl">
    <thead>
      <tr>
        <!-- Editable table header cells with default time slots -->
        <th contenteditable="true">7.15 ‚Äì 8.15</th>
        <th contenteditable="true">8.15 ‚Äì 9.15</th>
        <th contenteditable="true">9.15 ‚Äì 10.15</th>
        <th contenteditable="true">10.15 ‚Äì 10.30 (REHAT)</th>
        <th contenteditable="true">10.30 ‚Äì 11.30</th>
        <th contenteditable="true">11.30 ‚Äì 12.30</th>
        <th contenteditable="true">12.30 ‚Äì 13.00</th>
      </tr>
    </thead>
    <tbody>
      <!-- Default rows, all cells empty -->
      <tr>
        <td contenteditable="true"></td>
        <td contenteditable="true"></td>
        <td contenteditable="true"></td>
        <td contenteditable="true"></td>
        <td contenteditable="true"></td>
        <td contenteditable="true"></td>
        <td contenteditable="true"></td>
      </tr>
      <tr>
        <td contenteditable="true"></td>
        <td contenteditable="true"></td>
        <td contenteditable="true"></td>
        <td contenteditable="true"></td>
        <td contenteditable="true"></td>
        <td contenteditable="true"></td>
        <td contenteditable="true"></td>
      </tr>
      <tr>
        <td contenteditable="true"></td>
        <td contenteditable="true"></td>
        <td contenteditable="true"></td>
        <td contenteditable="true"></td>
        <td contenteditable="true"></td>
        <td contenteditable="true"></td>
        <td contenteditable="true"></td>
      </tr>
      <tr>
        <td contenteditable="true"></td>
        <td contenteditable="true"></td>
        <td contenteditable="true"></td>
        <td contenteditable="true"></td>
        <td contenteditable="true"></td>
        <td contenteditable="true"></td>
        <td contenteditable="true"></td>
      </tr>
    </tbody>
  </table>

  <p id="msg">‚ö†Ô∏è SheetJS not found ‚Äì export disabled.</p>

  <script>
      const T = document.getElementById('tbl'),
          DRAFTS_KEY = 'jadual_drafts',
          pageHeader = document.querySelector('h2');
    let sel = { r: 0, c: 0 }; /* selected cell coords */
    let lastFileName = null; // Store the name of the last uploaded Excel file
    let selectedCells = []; // Track selected cells for merging

    /* ---------- selection highlight with multi-select ---------- */
    T.addEventListener('click', e => {
      if (e.target.tagName !== 'TD' && e.target.tagName !== 'TH') return;
      const cell = e.target;
      const isCtrlKey = e.ctrlKey || e.metaKey;
      const isShiftKey = e.shiftKey;

      if (isCtrlKey || isShiftKey) {
        cell.classList.add('selected');
        selectedCells.push(cell);
        if (isShiftKey && selectedCells.length > 1) {
          const start = selectedCells[0];
          const end = cell;
          const startRow = start.parentNode.rowIndex;
          const startCol = start.cellIndex;
          const endRow = end.parentNode.rowIndex;
          const endCol = end.cellIndex;
          for (let r = Math.min(startRow, endRow); r <= Math.max(startRow, endRow); r++) {
            for (let c = Math.min(startCol, endCol); c <= Math.max(startCol, endCol); c++) {
              const cellToSelect = T.rows[r].cells[c];
              if (!cellToSelect.classList.contains('selected')) {
                cellToSelect.classList.add('selected');
                selectedCells.push(cellToSelect);
              }
            }
          }
        }
      } else {
        [...T.querySelectorAll('.selected')].forEach(c => c.classList.remove('selected'));
        selectedCells = [cell];
        cell.classList.add('selected');
      }
      sel = { r: cell.parentNode.rowIndex, c: cell.cellIndex };
    });

    /* ---------- helper: create empty cell ---------- */
    function makeCell(row, isHeader = false) {
      const cell = isHeader ? row.insertCell(-1) : row.insertCell(-1);
      if (isHeader) cell.outerHTML = '<th contenteditable="true"></th>';
      else { cell.contentEditable = 'true'; cell.textContent = ''; }
    }

    /* ---------- flexible row / col ops ---------- */
    function addRowAbove() {
      const r = T.insertRow(sel.r);
      for (let i = 0; i < T.rows[0].cells.length; i++) makeCell(r);
    }

    function addRowBelow() {
      const r = T.insertRow(sel.r + 1);
      for (let i = 0; i < T.rows[0].cells.length; i++) makeCell(r);
    }

    function addColLeft() {
      for (const row of T.rows) {
        const c = row.insertCell(sel.c);
        if (row.rowIndex) c.contentEditable = 'true';
        else c.outerHTML = '<th contenteditable="true"></th>';
      }
    }

    function addColRight() {
      for (const row of T.rows) {
        const c = row.insertCell(sel.c + 1);
        if (row.rowIndex) c.contentEditable = 'true';
        else c.outerHTML = '<th contenteditable="true"></th>';
      }
    }

    /* ---------- localStorage draft management ---------- */
    function tblArray() { 
      return {
        table: [...T.rows].map(r => [...r.cells].map(c => {
          const colspan = c.getAttribute('colspan') || 1;
          const rowspan = c.getAttribute('rowspan') || 1;
          return { text: c.innerText.trim(), colspan, rowspan };
        })),
        header: pageHeader.innerText.trim()
      };
    }

    function arrayToTbl(a) {
      [...T.tBodies].forEach(tb => tb.remove());
      const tb = T.createTBody();
      for (let r = 1; r < a.table.length; r++) {
        const tr = tb.insertRow(-1);
        for (let c = 0; c < a.table[r].length; c++) {
          const { text, colspan, rowspan } = a.table[r][c];
          const td = tr.insertCell(-1);
          td.contentEditable = 'true';
          td.textContent = text;
          if (colspan > 1) td.setAttribute('colspan', colspan);
          if (rowspan > 1) td.setAttribute('rowspan', rowspan);
          if (colspan > 1 || rowspan > 1) td.classList.add('merged');
        }
      }
      /* sync header width if draft had more cols */
      while (T.rows[0].cells.length < a.table[0].length) addColRight();
      /* Update the table header row with saved values */
      for (let c = 0; c < a.table[0].length; c++) {
        T.rows[0].cells[c].innerText = a.table[0][c].text;
        if (a.table[0][c].colspan > 1) T.rows[0].cells[c].setAttribute('colspan', a.table[0][c].colspan);
        if (a.table[0][c].rowspan > 1) T.rows[0].cells[c].setAttribute('rowspan', a.table[0][c].rowspan);
        if (a.table[0][c].colspan > 1 || a.table[0][c].rowspan > 1) T.rows[0].cells[c].classList.add('merged');
      }
      /* Update the page header */
      pageHeader.innerText = a.header || '';
    }

    function getDrafts() {
      const drafts = localStorage.getItem(DRAFTS_KEY);
      return drafts ? JSON.parse(drafts) : {};
    }

    function saveDraft(title) {
      const drafts = getDrafts();
      drafts[title] = tblArray();
      localStorage.setItem(DRAFTS_KEY, JSON.stringify(drafts));
      alert(`Draft saved as "${title}"!`);
      updateDraftList();
    }

    function promptSaveDraft() {
      const title = prompt('Enter a title for this draft:');
      if (title && title.trim()) {
        const drafts = getDrafts();
        const trimmedTitle = title.trim();
        if (drafts[trimmedTitle] && !confirm(`A draft named "${trimmedTitle}" already exists. Do you want to overwrite it?`)) {
          return;
        }
        saveDraft(trimmedTitle);
      } else if (title !== null) {
        alert('Please enter a valid title.');
      }
    }

    function loadDraft(title) {
      const drafts = getDrafts();
      if (drafts[title]) {
        arrayToTbl(drafts[title]);
        alert(`Loaded draft "${title}"!`);
      }
      toggleDraftList(); // Hide the draft list after loading
    }

    function updateDraftList() {
      const drafts = getDrafts();
      const draftList = document.getElementById('draftList');
      draftList.innerHTML = '';
      const titles = Object.keys(drafts);
      if (titles.length === 0) {
        draftList.style.display = 'none';
        return;
      }
      titles.forEach(title => {
        const div = document.createElement('div');
        div.innerText = title;
        div.onclick = () => loadDraft(title);
        draftList.appendChild(div);
      });
      draftList.style.display = 'block';
    }

    function toggleDraftList() {
      const draftList = document.getElementById('draftList');
      if (draftList.style.display === 'block') {
        draftList.style.display = 'none';
      } else {
        updateDraftList();
      }
    }

    function clearDraft() {
      alert('Draft cleared! Reverting to empty table...');
      // Clear all rows in tbody
      [...T.tBodies].forEach(tb => tb.remove());
      const tb = T.createTBody();
      // Clear the header row content (but keep the structure)
      for (let c = 0; c < T.rows[0].cells.length; c++) {
        T.rows[0].cells[c].innerText = '';
        T.rows[0].cells[c].removeAttribute('colspan');
        T.rows[0].cells[c].removeAttribute('rowspan');
        T.rows[0].cells[c].classList.remove('merged');
      }
      // Clear the page header
      pageHeader.innerText = '';
      // Hide the draft list
      document.getElementById('draftList').style.display = 'none';
      // Reset last file name
      lastFileName = null;
    }
        /* ---------- Excel file handling ---------- */
    function promptExcelExport() {
      const sheetName = prompt('Enter the Excel sheet title (max 31 characters):', 'Schedule');
      if (sheetName && sheetName.trim()) {
        const trimmedSheetName = sheetName.trim().slice(0, 31); // Limit to 31 characters
        handleExcelFile({ target: { files: [] } }, trimmedSheetName); // Trigger export with custom sheet name
      } else if (sheetName !== null) {
        alert('Please enter a valid sheet title.');
      }
    }

    function handleExcelFile(event, customSheetName = null) {
      const file = event.target.files[0];
      if (file) {
        lastFileName = file.name; // Store the file name for future saves
        const reader = new FileReader();
        reader.onload = function(e) {
          const data = new Uint8Array(e.target.result);
          const workbook = XLSX.read(data, { type: 'array' });
          exportExcel(workbook, customSheetName || 'Schedule');
        };
        reader.readAsArrayBuffer(file);
        event.target.value = ''; // Reset the file input
      } else {
        exportExcel(null, customSheetName || 'Schedule'); // Export new file with custom sheet name
      }
    }

    function exportExcel(existingWorkbook, sheetName) {
      const msg = document.getElementById('msg');
      msg.style.display = 'none'; // Hide the message initially
      if (typeof XLSX === 'undefined') {
        msg.style.display = 'block';
        return;
      }

      // Prepare the data with the page header as the title
      const headerText = pageHeader.innerText.trim();
      const hasHeader = headerText !== '';
      const tableData = [...T.rows].map(r => [...r.cells].map(c => {
        const colspan = c.getAttribute('colspan') || 1;
        const rowspan = c.getAttribute('rowspan') || 1;
        return { text: c.innerText.trim(), colspan, rowspan };
      }));
      
      // Add the page header as the first row if it exists
      const aoa = hasHeader ? [[headerText]] : [];
      aoa.push(...tableData.map(row => row.map(cell => cell.text)));

      // Convert to worksheet
      const ws = XLSX.utils.aoa_to_sheet(aoa);

      // Calculate column widths dynamically based on content
      const colWidths = Array(tableData[0].length).fill(0);
      aoa.forEach((row, rIdx) => {
        row.forEach((cell, cIdx) => {
          if (cIdx < colWidths.length) {
            const len = (cell || '').toString().length;
            colWidths[cIdx] = Math.max(colWidths[cIdx], len);
          }
        });
      });
      ws['!cols'] = colWidths.map(w => ({ wch: Math.max(w + 2, 10) })); // Add padding, minimum width 10

      // Define merges, adjusting for the title row if present
      ws['!merges'] = tableData.reduce((merges, row, rIdx) => {
        row.forEach((cell, cIdx) => {
          if (cell.colspan > 1 || cell.rowspan > 1) {
            merges.push({
              s: { r: rIdx + (hasHeader ? 1 : 0), c: cIdx },
              e: { r: rIdx + (hasHeader ? 1 : 0) + cell.rowspan - 1, c: cIdx + cell.colspan - 1 }
            });
          }
        });
        return merges;
      }, []);
      if (hasHeader) {
        ws['!merges'].push({ s: { r: 0, c: 0 }, e: { r: 0, c: tableData[0].length - 1 } }); // Merge title row
      }

      // Apply cell styling
      const range = XLSX.utils.decode_range(ws['!ref']);
      for (let r = range.s.r; r <= range.e.r; r++) {
        for (let c = range.s.c; c <= range.e.c; c++) {
          const cellAddress = XLSX.utils.encode_cell({ r, c });
          if (!ws[cellAddress]) continue;

          // Default style: center alignment, thin borders
          ws[cellAddress].s = {
            alignment: { horizontal: 'center', vertical: 'center', wrapText: true },
            border: {
              top: { style: 'thin', color: { rgb: '000000' } },
              bottom: { style: 'thin', color: { rgb: '000000' } },
              left: { style: 'thin', color: { rgb: '000000' } },
              right: { style: 'thin', color: { rgb: '000000' } }
            }
          };

          // Title row styling (first row if header exists)
          if (hasHeader && r === 0) {
            ws[cellAddress].s.font = { bold: true, sz: 14 };
            ws[cellAddress].s.fill = { fgColor: { rgb: 'E6E6FA' } }; // Lavender background
          }
          // Header row styling (first row of table)
          else if (r === (hasHeader ? 1 : 0)) {
            ws[cellAddress].s.font = { bold: true };
            ws[cellAddress].s.fill = { fgColor: { rgb: 'D3D3D3' } }; // Light grey background
          }
          // Highlight merged cells in the table body
          else if (r > (hasHeader ? 1 : 0)) {
            const rowIdx = r - (hasHeader ? 1 : 0);
            const cellData = tableData[rowIdx][c];
            if (cellData && (cellData.colspan > 1 || cellData.rowspan > 1)) {
              ws[cellAddress].s.fill = { fgColor: { rgb: 'F0F0F0' } }; // Very light grey for merged cells
              ws[cellAddress].s.font = { italic: true };
            }
          }
        }
      }

      // Freeze the header row (and title row if present)
      ws['!freeze'] = { xSplit: 0, ySplit: hasHeader ? 2 : 1 };

      // Set print options
      ws['!pageSetup'] = { paperSize: 9, orientation: 'landscape', fitToWidth: 1, fitToHeight: 0 };
      ws['!margins'] = { left: 0.5, right: 0.5, top: 0.75, bottom: 0.75, header: 0.3, footer: 0.3 };

      // Define print area
      ws['!printArea'] = { s: { r: 0, c: 0 }, e: { r: tableData.length + (hasHeader ? 1 : 0) - 1, c: tableData[0].length - 1 } };

      const wb = existingWorkbook || XLSX.utils.book_new();
      const trimmedSheetName = sheetName.slice(0, 31); // Excel sheet names are limited to 31 chars
      
      // If an existing workbook was provided, replace the first sheet; otherwise append a new one
      if (existingWorkbook && existingWorkbook.SheetNames.length > 0) {
        const existingSheetName = existingWorkbook.SheetNames[0];
        existingWorkbook.Sheets[existingSheetName] = ws;
        existingWorkbook.SheetNames[0] = trimmedSheetName;
      } else {
        XLSX.utils.book_append_sheet(wb, ws, trimmedSheetName);
      }

      // Use the last file name if available; otherwise, generate a new one with current date
      const currentDate = new Date().toISOString().slice(0, 10); // e.g., "2025-05-23"
      const fileName = lastFileName || `${trimmedSheetName.replace(/[^a-zA-Z0-9]/g, '_') || 'Jadual'}_${currentDate}.xlsx`;
      XLSX.writeFile(wb, fileName);
    }

    /* ---------- Merge and Unmerge Cells ---------- */
    function mergeCells() {
      if (selectedCells.length < 2) {
        alert('Please select at least 2 cells to merge.');
        return;
      }

      const rows = selectedCells.map(cell => cell.parentNode.rowIndex);
      const cols = selectedCells.map(cell => cell.cellIndex);
      const minRow = Math.min(...rows);
      const maxRow = Math.max(...rows);
      const minCol = Math.min(...cols);
      const maxCol = Math.max(...cols);
      const rowspan = maxRow - minRow + 1;
      const colspan = maxCol - minCol + 1;

      // Get the top-left cell to keep its content
      const topLeftCell = T.rows[minRow].cells[minCol];
      const mergedContent = topLeftCell.innerText;

      // Remove all selected cells except the top-left one
      selectedCells.forEach(cell => {
        if (cell !== topLeftCell) cell.remove();
      });

      // Update the top-left cell with merged properties
      topLeftCell.setAttribute('rowspan', rowspan);
      topLeftCell.setAttribute('colspan', colspan);
      topLeftCell.classList.add('merged');
      topLeftCell.innerText = mergedContent; // Retain the top-left cell's content

      // Clear selection
      selectedCells = [];
      [...T.querySelectorAll('.selected')].forEach(c => c.classList.remove('selected'));
    }

    function unmergeCells() {
      const mergedCells = [...T.querySelectorAll('.merged')];
      if (mergedCells.length === 0) {
        alert('No merged cells to unmerge.');
        return;
      }

      mergedCells.forEach(cell => {
        const rowspan = parseInt(cell.getAttribute('rowspan') || 1);
        const colspan = parseInt(cell.getAttribute('colspan') || 1);
        const rowIdx = cell.parentNode.rowIndex;
        const colIdx = cell.cellIndex;

        // Remove merged attributes and class
        cell.removeAttribute('rowspan');
        cell.removeAttribute('colspan');
        cell.classList.remove('merged');

        // Reconstruct individual cells
        if (rowspan > 1 || colspan > 1) {
          const content = cell.innerText;
          for (let r = 0; r < rowspan; r++) {
            for (let c = 0; c < colspan; c++) {
              if (r === 0 && c === 0) continue; // Skip the original cell
              const newCell = T.rows[rowIdx + r].insertCell(colIdx + c);
              newCell.contentEditable = 'true';
              newCell.textContent = ''; // Distribute content if needed (currently empty)
            }
          }
          cell.innerText = content; // Reset content to original cell
        }
      });

      // Clear selection
      selectedCells = [];
      [...T.querySelectorAll('.selected')].forEach(c => c.classList.remove('selected'));
    }

    // Test if SheetJS is loaded
    console.log('SheetJS loaded:', typeof XLSX !== 'undefined');
  </script>
</body>
</html>
