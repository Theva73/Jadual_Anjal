<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>Weekly Schedule with Firestore Names & Drafts</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', 'Roboto', Arial, sans-serif; /* Modern font stack */
            margin: 0;
            background-color: #f0f2f5; /* Lighter grey background */
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            box-sizing: border-box; /* Ensure padding doesn't add to width */
        }
        .main-container {
            width: 100%;
            max-width: 1400px; /* Increased max-width */
            background-color: #ffffff;
            padding: 25px;
            border-radius: 12px; /* Softer radius */
            box-shadow: 0 6px 20px rgba(0,0,0,0.08); /* More subtle shadow */
            box-sizing: border-box;
        }
        h2, h3 {
            color: #1c1e21; /* Darker, less harsh color */
            text-align: center;
            margin-bottom: 20px;
        }
        #scheduleTitle {
            font-size: 2.2em;
            color: #0056b3;
            border-bottom: 2px solid #0056b3;
            padding-bottom: 10px;
        }
        #userIdDisplay {
            text-align: center;
            font-size: 0.9em;
            color: #555;
            margin-bottom: 20px;
            min-height: 1.2em; /* Prevent layout shift while loading */
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin-top: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            background-color: #fff;
            table-layout: auto; /* Let browser determine column widths, good for varying content */
        }
        #tablesContainer {
            overflow-x: auto; /* Allows horizontal scrolling for tables on small screens */
            position: relative; /* For potential absolute positioned children if any */
            width: 100%;
        }
        #tablesContainer > table {
            display: none; /* Tables are hidden by default, active one shown by JS */
        }
        #tablesContainer > table.active {
            display: table; /* Show the active table */
        }
        #summaryTable {
            display: table; /* Summary table is always visible below others */
            margin-top: 25px;
        }
        th, td {
            border: 1px solid #dee2e6; /* Lighter border color */
            padding: 12px 15px; /* Increased padding for better touch targets and readability */
            text-align: center;
            min-width: 100px; /* Minimum width for cells, helps with layout */
            box-sizing: border-box;
            position: relative; /* For positioning autocomplete suggestions */
        }
        table th {
            background-color: #f8f9fa; /* Lighter header background */
            color: #343a40; /* Darker header text */
            font-weight: 600; /* Slightly bolder font */
            white-space: nowrap; /* Prevent header text from wrapping */
        }
        td.selected, th.selected { /* Styling for selected cells */
            outline: 3px solid #007bff;
            background-color: #dbeafe; /* Adjusted selection color */
        }
        .bar {
            display: flex;
            flex-wrap: wrap; /* Allow buttons to wrap on smaller screens */
            gap: 10px;
            margin-bottom: 20px;
            align-items: center;
            justify-content: center; /* Center buttons in the bar */
        }
        .bar button, .table-tabs button, .name-session-tabs button {
            padding: 10px 18px;
            font-size: 14px;
            border-radius: 6px;
            cursor: pointer;
            border: 1px solid #ced4da;
            background-color: #fff;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 1px 3px rgba(0,0,0,0.06);
            display: inline-flex;
            align-items: center;
            gap: 8px;
            flex-shrink: 0; /* Prevent buttons from shrinking too much */
        }
        .bar button:hover, .table-tabs button:hover, .name-session-tabs button:hover {
            background-color: #f8f9fa;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }
        .bar button:active, .table-tabs button:active, .name-session-tabs button:active {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }

        #rowColManipulationBar button {
            background-image: linear-gradient(to bottom, #ffffff 0%, #f1f3f5 100%);
            border: 1px solid #ced4da;
            color: #343a40;
            box-shadow: 0 2px 3px rgba(0,0,0,0.08), inset 0 1px 0 rgba(255,255,255,0.2);
            padding: 8px 14px;
        }
        #rowColManipulationBar button:hover {
            background-image: linear-gradient(to bottom, #e9ecef 0%, #dee2e6 100%);
            border-color: #adb5bd;
            box-shadow: 0 2px 5px rgba(0,0,0,0.12), inset 0 1px 0 rgba(255,255,255,0.1);
        }
         #rowColManipulationBar button.delete-btn {
            background-image: linear-gradient(to bottom, #f8d7da 0%, #f1c6cb 100%);
            border-color: #f5c6cb;
            color: #721c24;
        }
        #rowColManipulationBar button.delete-btn:hover {
            background-image: linear-gradient(to bottom, #f5c6cb 0%, #ebaeb3 100%);
            border-color: #f1b0b7;
        }
        /* Specific button styling */
        #directCopyFullHtmlBtn { background-color: #545b62; color: white; border-color: #545b62;}
        #excelBtnTrigger, #importExcelBtn { background-color: #28a745; color: white; border-color: #28a745;}
        #saveDraftBtn { background-color: #007bff; color: white; border-color: #007bff;}
        #loadDraftBtn { background-color: #ffc107; color: #212529; border-color: #ffc107;}
        #clearActiveTableContentBtn { background-color: #fd7e14; color: white; border-color: #fd7e14;}
        #selectBtn { background-color: #17a2b8; color: white; border-color: #17a2b8;}
        #selectBtn.active { background-color: #fd7e14; border-color: #fd7e14;}
        #mergeBtn { background-color: #6f42c1; color: white; border-color: #6f42c1;}
        #unmergeBtn { background-color: #e83e8c; color: white; border-color: #e83e8c;}
        #addTableBtn { background-color: #20c997; color: white; border-color: #20c997;}
        #renameTableBtn { background-color: #6c757d; color: white; border-color: #6c757d;}
        #deleteTableBtn { background-color: #dc3545; color: white; border-color: #dc3545;}
        #nameListBtn { background-color: #fd7e14; color: white; border-color: #fd7e14;}
        #deselectBtn { background-color: #6c757d; color: white; border-color: #6c757d;}
        #exportDraftsBtn { background-color: #4e54c8; color: white; border-color: #4e54c8;}
        #importDraftsBtn { background-color: #8f94fb; color: white; border-color: #8f94fb;}

        .table-tabs {
            margin-bottom: 15px;
            border-bottom: 2px solid #007bff;
            padding-bottom: 0;
            display: flex; /* Use flex for tabs */
            flex-wrap: wrap; /* Allow tabs to wrap */
            gap: 5px; /* Space between tab buttons */
        }
        .table-tabs button {
            background-color: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            border-radius: 6px 6px 0 0;
            color: #0056b3;
            font-weight: 500;
            padding: 10px 15px; /* Adjust padding for tabs */
        }
        .table-tabs button.active {
            background-color: #007bff;
            color: white;
            border-color: #007bff;
        }
        
        .name-session-tabs {
            margin-bottom: 20px;
            border-bottom: 2px solid #dee2e6;
            padding-bottom: 8px;
            display: flex; /* Use flex for tabs */
            flex-wrap: wrap; /* Allow tabs to wrap */
            gap: 5px;
        }
        .name-session-tabs button {
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
            border-bottom: none;
            margin-bottom: -2px; /* Align with bottom border */
            padding: 10px 15px;
            font-size: 1em;
        }
        .name-session-tabs button.active {
            background-color: #007bff;
            color: white;
            border-color: #007bff #007bff #fff; /* Creates the tab effect */
            font-weight: bold;
        }

        #summaryTable th {
            background-color: #ffc107; /* Brighter, more distinct color for summary header */
            color: #212529;
        }
        #summaryTable td {
            background-color: #fff9e6; /* Lighter version of header for summary data cells */
        }
        .highlight-conflict { /* Style for cells with conflicting entries */
            background-color: #f8d7da !important;
            font-weight: bold;
            color: #721c24 !important;
        }

        .modal {
            display: none; /* Hidden by default */
            position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%;
            overflow: hidden; /* Prevent scrolling of background when modal is open */
            background-color: rgba(0,0,0,0.5);
            align-items: center; justify-content: center;
            pointer-events: none; /* Allow clicks to pass through overlay to content */
        }
        .modal-content {
            background-color: #fff;
            padding: 25px; border: 1px solid #ccc; width: 90%; max-width: 650px; /* Responsive width */
            border-radius: 10px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.3); position: relative;
            pointer-events: auto; /* Modal content should be interactive */
            max-height: 90vh; /* Max height to prevent overflow on small screens */
            overflow-y: auto; /* Allow scrolling within modal if content is too tall */
            box-sizing: border-box;
        }
        .modal-content.dragging { transform: none; /* Disable transform while dragging for smoother movement */ }
        .modal-header {
            padding-bottom: 15px;
            border-bottom: 1px solid #e9ecef; margin-bottom: 20px;
            font-size: 1.3em; color: #333; display: flex; justify-content: space-between; align-items: center;
            cursor: move; user-select: none; /* Prevent text selection while dragging header */
        }
        .modal-close-btn {
            font-size: 1.8rem;
            font-weight: bold; line-height: 1; color: #555;
            text-shadow: none; opacity: .7; background: transparent; border: 0; cursor: pointer;
            padding: 0 5px; /* Add some padding for easier touch */
            transition: color 0.2s;
        }
        .modal-close-btn:hover { opacity: 1; color: #dc3545; }

        .name-item {
            display: flex;
            justify-content: space-between; align-items: center;
            padding: 10px 8px; border-bottom: 1px solid #f1f3f5;
            transition: background-color 0.2s;
        }
        .name-item:hover { background-color: #f8f9fa; }
        .name-item:last-child { border-bottom: none; }
        .name-item span { flex-grow: 1; cursor: pointer; color: #007bff; font-weight: 500; }
        .name-item span:hover { text-decoration: none; color: #0056b3; }
        .name-item button { background-color: #dc3545; color: white; border: none; border-radius: 5px;
            padding: 6px 12px; font-size: 0.9em; transition: background-color 0.2s; }
        .name-item button:hover { background-color: #c82333; }
        .highlighted { background-color: #cfe2ff !important; font-weight: bold; }

        #draftListContainer { /* Changed ID from draftList to draftListContainer */
            border: 1px solid #ddd; padding: 15px; margin-bottom: 20px; border-radius: 8px;
            background-color: #f8f9fa;
            max-height: 300px; /* Added max-height */
            overflow-y: auto; /* Added overflow-y */
        }
        .draft-item { display: flex; justify-content: space-between; align-items: center;
            padding: 10px 8px; border-bottom: 1px solid #e9ecef; }
        .draft-item:last-child { border-bottom: none; }
        .draft-item span { cursor: pointer; color: #007bff; flex-grow: 1; margin-right: 10px; }
        .draft-item span:hover { text-decoration: underline; }
        .draft-item .draft-date { font-size: 0.8em; color: #6c757d; margin-right: 10px; white-space: nowrap;}
        .draft-item button { background-color: #dc3545; color: white; border: none; border-radius: 5px;
            padding: 6px 12px; font-size: 0.9em; flex-shrink: 0; }


        #newNameInput, #searchNameInput {
            padding: 10px;
            margin-right: 8px; border: 1px solid #ccc; border-radius: 5px; flex-grow: 1;
            width: calc(100% - 120px); /* Adjusted for button width and margin */
            box-sizing: border-box;
        }
         #searchNameInput {
            margin-bottom: 15px;
            width: 100%; /* Full width for search */
            box-sizing: border-box;
            margin-right: 0; /* No right margin needed if full width */
         }
        .input-group {
            display: flex;
            margin-bottom: 15px;
            width: 100%; /* Ensure input group takes full width */
        }
        .input-group button, #importNameListBtn {
            background-color: #28a745;
            color: white; border-color: #28a745; padding: 10px 15px;
            font-size: 1em; border-radius: 5px; cursor: pointer; flex-shrink: 0;
            transition: background-color 0.2s;
        }
        .input-group button:hover, #importNameListBtn:hover { background-color: #218838; }
        #importNameListBtn {
            margin-top: 10px;
            width: 100%; /* Full width button */
        }
        #nameList {
            margin-top:15px;
            max-height:250px; /* Reduced from 300px to better fit modal */
            overflow-y:auto;
        }
        /* Responsive columns for name list */
        @media (min-width: 480px) { /* Apply two columns on screens wider than 480px */
            #nameList {
                column-count: 2;
                column-gap: 20px; /* Slightly reduced gap */
            }
        }


        .custom-message-box {
            display: none;
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            background-color: #333; color: white; padding: 15px 25px; border-radius: 8px;
            z-index: 2000;
            box-shadow: 0 4px 15px rgba(0,0,0,0.25); font-size: 1.05em;
            text-align: center; /* Center text in message box */
            width: 90%; /* Responsive width */
            max-width: 400px; /* Max width for message box */
        }
        .custom-message-box.success { background-color: #28a745; }
        .custom-message-box.error { background-color: #dc3545; }
        .custom-message-box.info { background-color: #007bff; }

        .merged-cell-container { position: relative; z-index: 2; vertical-align: top; }
        .merged-cell-overlay {
            position: absolute;
            top: 0; left: 0; width: var(--merged-width); height: var(--merged-height);
            background-color: rgba(240, 248, 255, 0.95); font-style: italic; border: 1px solid #add8e6;
            display: flex; align-items: center;
            justify-content: center; overflow: hidden;
            box-sizing: border-box; z-index: 5;
        }
        .subsumed-cell { visibility: hidden; }

        #loadingIndicatorModal, #generalLoadingIndicator { /* Combined styles */
            position: absolute; 
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(255, 255, 255, 0.85);
            display: flex; align-items: center; justify-content: center;
            z-index: 10; 
            border-radius: 10px; 
        }
        #generalLoadingIndicator { /* Specific for general use */
            position: fixed; /* Cover whole screen */
            z-index: 3000; /* Above everything */
            border-radius: 0; /* No radius for full screen */
        }
        .spinner {
            border: 5px solid rgba(0, 0, 0, 0.1);
            width: 40px; height: 40px;
            border-radius: 50%;
            border-left-color: #007bff; /* Spinner color */
            animation: spin 1s ease infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Ensure hidden file inputs don't take up space */
        input[type="file"][style*="display:none"],
        input[type="file"][style*="display: none"] {
            position: absolute;
            left: -9999px;
            width: 1px;
            height: 1px;
            opacity: 0;
        }

        /* Styles for inline autocomplete suggestions */
        #autocompleteSuggestions {
            display: none; /* Hidden by default */
            position: absolute;
            border: 1px solid #ccc;
            background-color: white;
            z-index: 1001; /* Must be above table cells */
            max-height: 150px;
            overflow-y: auto;
            min-width: 120px; /* Or set dynamically */
            box-shadow: 0 2px 5px rgba(0,0,0,0.15);
            border-radius: 4px;
        }
        .suggestion-item {
            padding: 8px 10px;
            cursor: pointer;
            font-size: 0.9em;
            white-space: nowrap;
        }
        .suggestion-item:hover, .suggestion-item.active-suggestion {
            background-color: #e9ecef; /* Light grey hover */
            color: #0056b3;
        }

    </style>
</head>
<body>
<div class="main-container">
    <h2 contenteditable="true" id="scheduleTitle">Weekly Schedule</h2>
    <div id="userIdDisplay">User ID: Loading...</div>

    <div class="bar">
        <button id="directCopyFullHtmlBtn" title="Copy the entire page's HTML to clipboard">üìã Copy Full HTML (Direct)</button>
    </div>
    <div class="bar">
        <button id="excelBtnTrigger" title="Export the currently active table to an Excel file">üíæ Export Active Table to Excel</button>
        <button id="importExcelBtn" title="Import data from an Excel file into a new table">üìÇ Import from Excel</button>
        <input type="file" id="fileInput" accept=".xlsx, .xls" style="display:none">
    </div>
    <div class="bar">
        <button id="saveDraftBtn" title="Save current schedule to Firebase">üí† Save Schedule to Cloud</button>
        <button id="loadDraftBtn" title="Show list of saved drafts from Firebase to load">‚òÅÔ∏è Load Schedule from Cloud</button>
        <button id="exportDraftsBtn" title="Export all Firebase drafts to a JSON file">üì§ Export All Cloud Drafts</button>
        <button id="importDraftsBtn" title="Import drafts from a JSON file to Firebase">üì• Import Drafts to Cloud</button>
        <input type="file" id="draftImportFile" accept=".json" style="display:none;">
        <button id="clearActiveTableContentBtn" title="Clear all data from the cells of the active table">üßπ Clear Active Table</button>
    </div>
    <div class="bar">
        <button id="selectBtn" title="Toggle cell selection mode on/off">‚ú® Select Cells</button>
        <button id="mergeBtn" title="Merge the currently selected cells">üîó Merge Cells</button>
        <button id="deselectBtn" title="Clear current cell selection">üö´ Deselect All</button>
        <button id="unmergeBtn" title="Unmerge the cell that was last clicked if it's part of a merge">üíî Unmerge Cell</button>
    </div>
    <div class="bar">
        <button id="addTableBtn" title="Add a new, empty table/sheet">‚ûï Add New Table</button>
        <button id="renameTableBtn" title="Rename the currently active table/sheet">üìù Rename Active Table</button>
        <button id="deleteTableBtn" title="Delete the currently active table/sheet">‚ùå Delete Active Table</button>
        <button id="nameListBtn" title="Open a dialog to manage a list of names for quick insertion">üë• Manage Names (Firestore)</button>
    </div>

    <div id="draftListContainer" style="display:none;"></div> <div class="bar table-tabs" id="tableTabs"></div>
    <div id="tablesContainer">
        <table id="tbl_1" class="active" data-table-name="Table 1">
            <thead>
                <tr>
                    <th contenteditable="true">Class</th>
                    <th contenteditable="true">08:00</th>
                    <th contenteditable="true">09:00</th>
                    <th contenteditable="true">10:00</th>
                    <th contenteditable="true">11:00</th>
                    <th contenteditable="true">12:00</th>
                    <th contenteditable="true">13:00</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td contenteditable="true">5S1</td>
                    <td contenteditable="true"></td><td contenteditable="true">JAMES</td><td contenteditable="true"></td>
                    <td contenteditable="true"></td><td contenteditable="true"></td><td contenteditable="true"></td>
                </tr>
                 <tr>
                    <td contenteditable="true">5S2</td>
                    <td contenteditable="true"></td><td contenteditable="true"></td><td contenteditable="true">LILY</td>
                    <td contenteditable="true"></td><td contenteditable="true"></td><td contenteditable="true"></td>
                </tr>
            </tbody>
        </table>
    </div>

    <div class="bar" id="rowColManipulationBar">
        <button id="addRowAboveBtn" title="Add a new row above the currently selected/clicked row">‚¨ÜÔ∏è Add Row Above</button>
        <button id="addRowBelowBtn" title="Add a new row below the currently selected/clicked row">‚¨áÔ∏è Add Row Below</button>
        <button id="addColLeftBtn" title="Add a new column to the left of the currently selected/clicked column">‚¨ÖÔ∏è Add Column Left</button>
        <button id="addColRightBtn" title="Add a new column to the right of the currently selected/clicked column">‚û°Ô∏è Add Column Right</button>
        <button id="deleteRowBtn" class="delete-btn" title="Delete the currently selected/clicked row">üóëÔ∏è Delete Row</button>
        <button id="deleteColBtn" class="delete-btn" title="Delete the currently selected/clicked column">üóëÔ∏è Delete Column</button>
    </div>

    <div id="nameModal" class="modal">
        <div class="modal-content" id="nameModalContent">
            <div class="modal-header" id="nameModalHeader">
                <h3 id="nameModalTitle">Name List Manager</h3>
                <button type="button" class="modal-close-btn" id="closeNameModalBtnStandard" title="Close name manager">√ó</button>
            </div>
            <div class="name-session-tabs">
                <button id="namePagiTab" data-session="pagi" class="active">Pagi (Morning)</button>
                <button id="namePetangTab" data-session="petang">Petang (Afternoon)</button>
            </div>
             <div class="input-group">
                <input id="newNameInput" placeholder="Add new name to current session">
                <button id="addNameBtnInModal" title="Add the name to the list">Add</button>
            </div>
            <button id="importNameListBtn" title="Import names from a .txt file (one name per line) to current session">üìÇ Import Names (.txt) to Session</button>
            <input type="file" id="nameListImportFile" accept=".txt" style="display:none;">
            <input type="text" id="searchNameInput" placeholder="üîç Search names in current session..." title="Filter the list of names">
            <div id="nameList">
                </div>
            <div id="loadingIndicatorModal" style="display:none;"><div class="spinner"></div></div>
        </div>
    </div>

    <h3 style="margin-top:32px">Teacher/Subject Attendance Summary</h3>
    <table id="summaryTable">
        </table>
    <div id="customMessageBox" class="custom-message-box"></div>
    <div id="generalLoadingIndicator" style="display:none;"><div class="spinner"></div></div>
</div>

<script type="module">
    // Firebase App (the core Firebase SDK) is always required and must be listed first
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    // Add SDKs for Firebase products that you want to use
    import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, setDoc, onSnapshot, collection, addDoc, getDocs, getDoc, deleteDoc, updateDoc, query, serverTimestamp, orderBy } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js"; // Added more imports

    // --- Firebase Configuration ---
    // This is the user-provided Firebase configuration.
    // It will be used if __firebase_config is not available (e.g., when running locally outside the platform).
    const userProvidedFirebaseConfig = {
      apiKey: "AIzaSyBgvyb95-jujtCC2HPiHXLdYMJgQquIEx4",
      authDomain: "jadual-3f0aa.firebaseapp.com",
      projectId: "jadual-3f0aa",
      storageBucket: "jadual-3f0aa.firebasestorage.app",
      messagingSenderId: "496526436851",
      appId: "1:496526436851:web:78ff48b28bfc8c31f14a86"
    };

    // Attempt to use the platform-provided Firebase config, otherwise fallback to userProvidedFirebaseConfig.
    // The __firebase_config variable is expected to be injected by the platform.
    const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : userProvidedFirebaseConfig;
    // Attempt to use the platform-provided App ID, otherwise fallback to the one in firebaseConfig or a default.
    // The __app_id variable is expected to be injected by the platform.
    const appId = typeof __app_id !== 'undefined' ? __app_id : (firebaseConfig.appId || 'default-app-id');
    
    // Log a warning if the platform-provided config is not found, indicating a local or misconfigured environment.
    if (typeof __firebase_config === 'undefined') {
        console.warn("Using user-provided Firebase config. Ensure it's correctly set up if this is unexpected (e.g., not running locally).");
    }
    // Log a warning if the platform-provided App ID is not found.
    if (typeof __app_id === 'undefined') {
        console.warn("Using App ID from Firebase config or a default value. Ensure it's correctly set up for Firestore paths if this is unexpected.");
    }


    // --- Initialize Firebase ---
    let fbApp, fbAuth, fbDb;
    let fbUserId = null;
    let fbIsAuthReady = false;
    let unsubscribePagi = null;
    let unsubscribePetang = null;

    try {
        fbApp = initializeApp(firebaseConfig);
        fbAuth = getAuth(fbApp);
        fbDb = getFirestore(fbApp);
        console.log("Firebase services initialized.");
    } catch (e) {
        console.error("CRITICAL Error initializing Firebase services:", e);
        showMessage("Critical Error: Firebase initialization failed. Cloud features will not work.", "error", 10000);
        const userIdDisplayInitError = document.getElementById('userIdDisplay');
        if (userIdDisplayInitError) userIdDisplayInitError.textContent = "User ID: Firebase Init Error!";
    }

    // --- Global State and Configuration ---
    const SCHEDULE_TITLE_KEY = 'jadual_title_v3'; // For localStorage title
    let activeTableId = 'tbl_1';
    let tableCount = 1;
    let selectionMode = false;
    let selectedCells = [];
    let lastClickedCell = null;
    let selectedNameFromList = null; 

    let currentNameListSession = 'pagi'; 
    let namesPagi = [];
    let namesPetang = [];

    let isDraggingModal = false;
    let modalDragOffsetX, modalDragOffsetY;

    let autocompleteSuggestionsDiv = null;
    let activeCellForAutocomplete = null;
    let currentAutocompleteIndex = -1; 

    let scheduleTitleElement, tablesContainer, tableTabs, nameModal, nameModalContent, nameModalHeader, nameListContainer, newNameInput, draftListContainerElement, summaryTableElement, customMessageBox, fileInputElement, directCopyFullHtmlButtonElement, closeNameModalButtonStandardElement, nameListImportFileInputElement, searchNameInputElement, draftImportFileInputElement, userIdDisplayElement, namePagiTabElement, namePetangTabElement, loadingIndicatorModalElement, nameModalTitleElement, generalLoadingIndicatorElement;

    // --- Utility Functions ---
    function showMessage(message, type = 'info', duration = 3000) {
        if (!customMessageBox) {
            customMessageBox = document.getElementById('customMessageBox');
            if (!customMessageBox) {
                console.warn("showMessage called but customMessageBox element not found. Message:", message);
                return;
            }
        }
        customMessageBox.textContent = message;
        customMessageBox.className = `custom-message-box ${type}`;
        customMessageBox.style.display = 'block';
        setTimeout(() => { if (customMessageBox) customMessageBox.style.display = 'none'; }, duration);
    }

    function customPrompt(message, defaultValue = "") {
        return prompt(message, defaultValue);
    }

    function customConfirm(message) {
        return new Promise((resolve) => {
            const confirmModalId = 'customConfirmModal';
            let existingModal = document.getElementById(confirmModalId);
            if (existingModal) existingModal.remove();
            const modal = document.createElement('div');
            modal.id = confirmModalId;
            modal.style.cssText = `display: flex; position: fixed; z-index: 2001; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5); align-items: center; justify-content: center;`;
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `background-color: #fff; padding: 25px; border-radius: 8px; text-align: center; box-shadow: 0 5px 15px rgba(0,0,0,0.3); min-width: 300px; max-width: 90%;`;
            const messageP = document.createElement('p');
            messageP.textContent = message;
            messageP.style.marginBottom = '20px'; messageP.style.fontSize = '1.1em';
            const yesButton = document.createElement('button');
            yesButton.textContent = 'Yes';
            yesButton.style.cssText = `padding: 10px 20px; margin: 0 10px; border-radius: 5px; cursor: pointer; background-color: #28a745; color: white; border: none; font-size: 1em;`;
            const noButton = document.createElement('button');
            noButton.textContent = 'No';
            noButton.style.cssText = `padding: 10px 20px; margin: 0 10px; border-radius: 5px; cursor: pointer; background-color: #dc3545; color: white; border: none; font-size: 1em;`;
            const closeModal = (value) => { modal.remove(); resolve(value); };
            yesButton.onclick = () => closeModal(true);
            noButton.onclick = () => closeModal(false);
            modalContent.appendChild(messageP);
            modalContent.appendChild(yesButton);
            modalContent.appendChild(noButton);
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
        });
    }

    function showGeneralLoading(isLoading) {
        if (generalLoadingIndicatorElement) {
            generalLoadingIndicatorElement.style.display = isLoading ? 'flex' : 'none';
        }
    }


    // --- Firestore Name List Functions ---
    function showNameModalLoading(isLoading) {
        if (loadingIndicatorModalElement) {
            loadingIndicatorModalElement.style.display = isLoading ? 'flex' : 'none';
        }
    }

    async function saveNameListToFirestore(session, namesArray) {
        if (!fbDb || !fbUserId || !fbIsAuthReady) {
            showMessage("Firebase not ready. Cannot save name list.", "error");
            return;
        }
        showNameModalLoading(true);
        const uniqueSortedNames = [...new Set(namesArray.map(n => String(n||'').trim()).filter(n => n))]
                                .sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));
        if (!appId || appId === 'default-app-id') {
            showMessage("Configuration error: App ID is missing. Cannot save name list.", "error");
            showNameModalLoading(false);
            return;
        }
        const docRef = doc(fbDb, "artifacts", appId, "users", fbUserId, "nameLists", session);
        try {
            await setDoc(docRef, { names: uniqueSortedNames });
            showMessage(`Name list uploaded to ${session} session.`, "success");
        } catch (error) {
            console.error(`Error saving list to ${session}:`, error);
            showMessage(`Failed to save list to ${session}. Error: ${error.message}`, "error");
        } finally {
            showNameModalLoading(false);
        }
    }

    async function addNameToCurrentSessionInFirestore(name) {
        if (!fbDb || !fbUserId || !fbIsAuthReady) {
            showMessage("Firebase not ready. Cannot add name.", "error");
            return;
        }
        const trimmedName = String(name || '').trim();
        if (!trimmedName) {
            showMessage("Name cannot be empty.", "info");
            return;
        }
        showNameModalLoading(true);
        const sessionNames = currentNameListSession === 'pagi' ? namesPagi : namesPetang;
        if (sessionNames.map(n => String(n || '').toLowerCase()).includes(trimmedName.toLowerCase())) {
            showMessage(`Name "${trimmedName}" already exists in ${currentNameListSession} session.`, "info");
            showNameModalLoading(false);
            return;
        }
        if (!appId || appId === 'default-app-id') {
            showMessage("Configuration error: App ID is missing. Cannot add name.", "error");
            showNameModalLoading(false);
            return;
        }
        const updatedNames = [...sessionNames, trimmedName].sort((a, b) => String(a).localeCompare(String(b), undefined, { sensitivity: 'base' }));
        const docRef = doc(fbDb, "artifacts", appId, "users", fbUserId, "nameLists", currentNameListSession);
        try {
            await setDoc(docRef, { names: updatedNames });
            if(newNameInput) {
                newNameInput.value = '';
                newNameInput.focus();
            }
        } catch (error) {
            console.error(`Error adding name to ${currentNameListSession}:`, error);
            showMessage(`Failed to add name. Error: ${error.message}`, "error");
        } finally {
            showNameModalLoading(false);
        }
    }

    async function deleteNameFromCurrentSessionInFirestore(nameToDelete) {
        if (!fbDb || !fbUserId || !fbIsAuthReady) {
            showMessage("Firebase not ready. Cannot delete name.", "error");
            return;
        }
        const nameToDeleteStr = String(nameToDelete || '');
        if (await customConfirm(`Delete "${nameToDeleteStr}" from ${currentNameListSession} session? This also removes it from all schedule tables.`)) {
            showNameModalLoading(true);
            if (!appId || appId === 'default-app-id') {
                showMessage("Configuration error: App ID is missing. Cannot delete name.", "error");
                showNameModalLoading(false);
                return;
            }
            const currentNames = currentNameListSession === 'pagi' ? namesPagi : namesPetang;
            const updatedNames = currentNames.filter(name => String(name || '') !== nameToDeleteStr);
            const docRef = doc(fbDb, "artifacts", appId, "users", fbUserId, "nameLists", currentNameListSession);
            try {
                await setDoc(docRef, { names: updatedNames });
                tablesContainer.querySelectorAll('table').forEach(table => {
                    table.querySelectorAll('tbody td, tbody th, .merged-cell-overlay').forEach(cell => {
                        if (cell.textContent.trim() === nameToDeleteStr) {
                            cell.textContent = '';
                        }
                    });
                });
                rebuildAndRenderSummary();
                if (selectedNameFromList === nameToDeleteStr) clearNameSelection();
            } catch (error) {
                console.error(`Error deleting name from ${currentNameListSession}:`, error);
                showMessage(`Failed to delete name. Error: ${error.message}`, "error");
            } finally {
                showNameModalLoading(false);
            }
        }
    }

    function listenToNameList(sessionToListen) {
        if (!fbDb || !fbUserId || !fbIsAuthReady) {
            console.warn(`listenToNameList (${sessionToListen}): Firestore not ready.`);
            return () => {};
        }
        if (!appId || appId === 'default-app-id') {
            console.error(`listenToNameList (${sessionToListen}): Invalid appId.`);
            return () => {};
        }
        const docRef = doc(fbDb, "artifacts", appId, "users", fbUserId, "nameLists", sessionToListen);
        return onSnapshot(docRef, (docSnap) => {
            showNameModalLoading(true);
            if (docSnap.exists()) {
                const data = docSnap.data();
                const namesFromDb = data.names || [];
                const sanitizedNames = namesFromDb.map(name => String(name || '').trim()).filter(name => name.length > 0);
                if (sessionToListen === 'pagi') namesPagi = sanitizedNames;
                else namesPetang = sanitizedNames;
            } else {
                if (sessionToListen === 'pagi') namesPagi = [];
                else namesPetang = [];
            }
            if (sessionToListen === currentNameListSession && nameModal && nameModal.style.display === 'flex' && searchNameInputElement) {
                renderNameListFromFirestore(searchNameInputElement.value);
            }
            rebuildAndRenderSummary(); 
            showNameModalLoading(false);
        }, (error) => {
            console.error(`Error listening to ${sessionToListen} names:`, error);
            showMessage(`Error fetching ${sessionToListen} names.`, "error");
            showNameModalLoading(false);
        });
    }

    // --- Firestore Schedule Draft Functions ---
    async function saveDraftToFirestore() {
        if (!fbDb || !fbUserId || !fbIsAuthReady) {
            showMessage("Firebase not ready. Cannot save draft.", "error"); return;
        }
        if (!tablesContainer || tablesContainer.children.length === 0) {
            showMessage('No schedule data to save.', 'error'); return;
        }
        const draftName = customPrompt('Enter a name for this schedule draft:', `Schedule Draft ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`);
        if (!draftName || draftName.trim() === "") {
            showMessage('Draft save cancelled or name is empty.', 'info'); return;
        }

        showGeneralLoading(true);
        const allTablesData = tablesContainer.innerHTML;
        const allTableMeta = {};
        tablesContainer.querySelectorAll('table').forEach(table => {
            allTableMeta[table.id] = { name: table.dataset.tableName || table.id };
        });

        const draftData = {
            name: draftName.trim(),
            html: allTablesData,
            meta: allTableMeta,
            activeTableId: activeTableId,
            createdAt: serverTimestamp() // Use server timestamp
        };

        try {
            const draftsCollectionRef = collection(fbDb, "artifacts", appId, "users", fbUserId, "scheduleDrafts");
            await addDoc(draftsCollectionRef, draftData);
            showMessage(`Draft "${draftName.trim()}" saved to Cloud!`, 'success');
            if (draftListContainerElement && draftListContainerElement.style.display === 'block') {
                await loadAndRenderDraftsFromFirestore(); // Refresh list
            }
        } catch (error) {
            console.error("Error saving draft to Firestore:", error);
            showMessage(`Failed to save draft. Error: ${error.message}`, "error");
        } finally {
            showGeneralLoading(false);
        }
    }

    async function loadAndRenderDraftsFromFirestore() {
        if (!fbDb || !fbUserId || !fbIsAuthReady) {
            showMessage("Firebase not ready. Cannot load drafts.", "error");
            if (draftListContainerElement) draftListContainerElement.innerHTML = '<p>Connect to Firebase to see drafts.</p>';
            return;
        }
        if (!draftListContainerElement) return;

        showGeneralLoading(true);
        draftListContainerElement.innerHTML = '<p>Loading drafts from Cloud...</p>';
        try {
            const draftsCollectionRef = collection(fbDb, "artifacts", appId, "users", fbUserId, "scheduleDrafts");
            const q = query(draftsCollectionRef, orderBy("createdAt", "desc")); // Order by most recent
            const querySnapshot = await getDocs(q);
            
            const drafts = [];
            querySnapshot.forEach((docSnap) => {
                drafts.push({ id: docSnap.id, ...docSnap.data() });
            });

            renderDraftList(drafts);
            draftListContainerElement.style.display = 'block';
        } catch (error) {
            console.error("Error loading drafts from Firestore:", error);
            showMessage(`Failed to load drafts. Error: ${error.message}`, "error");
            draftListContainerElement.innerHTML = '<p>Error loading drafts.</p>';
        } finally {
            showGeneralLoading(false);
        }
    }
    
    function renderDraftList(draftsArray) { // Takes drafts from Firestore
        if (!draftListContainerElement) return;
        draftListContainerElement.innerHTML = ''; 
        if (!draftsArray || draftsArray.length === 0) {
            draftListContainerElement.innerHTML = '<p>No drafts saved to Cloud yet.</p>'; return;
        }
        draftsArray.forEach(draft => {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'draft-item';
            const draftDate = draft.createdAt && draft.createdAt.toDate ? draft.createdAt.toDate().toLocaleString() : 'N/A';
            itemDiv.innerHTML = `
                <span data-draft-id="${draft.id}" title="Load draft: ${draft.name}">${draft.name}</span>
                <span class="draft-date">${draftDate}</span>
                <button data-draft-id="${draft.id}" title="Delete draft '${draft.name}' from Cloud">Delete</button>
            `;
            draftListContainerElement.appendChild(itemDiv);
        });
    }

    async function loadSelectedDraftFromFirestore(draftDocId) {
        if (!fbDb || !fbUserId || !fbIsAuthReady) {
            showMessage("Firebase not ready. Cannot load draft.", "error"); return;
        }
        if (!tablesContainer || !tableTabs) return;

        showGeneralLoading(true);
        try {
            const docRef = doc(fbDb, "artifacts", appId, "users", fbUserId, "scheduleDrafts", draftDocId);
            const docSnap = await getDoc(docRef);

            if (docSnap.exists()) {
                const draftData = docSnap.data();
                tablesContainer.innerHTML = draftData.html;
                const tableMeta = draftData.meta || {};
                tableTabs.innerHTML = ''; 
                tablesContainer.querySelectorAll('table').forEach(table => {
                    const id = table.id;
                    const metaInfo = tableMeta[id] || {};
                    const name = metaInfo.name || `Table ${tableTabs.children.length + 1}`;
                    table.dataset.tableName = name;
                    addTabButton(id, name);
                    table.querySelectorAll('td, th, .merged-cell-overlay').forEach(cell => cell.contentEditable = 'true');
                });
                activeTableId = draftData.activeTableId || tablesContainer.querySelector('table')?.id || 'tbl_1';
                
                if (document.getElementById(activeTableId)) {
                    switchTable(activeTableId);
                } else if (tablesContainer.querySelector('table')) {
                    switchTable(tablesContainer.querySelector('table').id);
                } else {
                    addNewTable(true); 
                }
                showMessage(`Draft "${draftData.name}" loaded from Cloud!`, 'success');
                if (draftListContainerElement) draftListContainerElement.style.display = 'none';
                rebuildAndRenderSummary();
                updateAllMergeOverlays(); 
            } else {
                showMessage(`Draft with ID "${draftDocId}" not found in Cloud.`, "error");
            }
        } catch (error) {
            console.error("Error loading selected draft from Firestore:", error);
            showMessage(`Failed to load draft. Error: ${error.message}`, "error");
        } finally {
            showGeneralLoading(false);
        }
    }

    async function confirmAndDeleteDraftFromFirestore(draftDocId, draftName) {
        if (!fbDb || !fbUserId || !fbIsAuthReady) {
            showMessage("Firebase not ready. Cannot delete draft.", "error"); return;
        }
        if (await customConfirm(`Are you sure you want to delete cloud draft "${draftName}"? This cannot be undone.`)) {
            showGeneralLoading(true);
            try {
                const docRef = doc(fbDb, "artifacts", appId, "users", fbUserId, "scheduleDrafts", draftDocId);
                await deleteDoc(docRef);
                showMessage(`Cloud draft "${draftName}" deleted.`, 'success');
                await loadAndRenderDraftsFromFirestore(); // Refresh the list
            } catch (error) {
                console.error("Error deleting draft from Firestore:", error);
                showMessage(`Failed to delete draft. Error: ${error.message}`, "error");
            } finally {
                showGeneralLoading(false);
            }
        }
    }

    async function exportAllFirestoreDrafts() {
        if (!fbDb || !fbUserId || !fbIsAuthReady) {
            showMessage("Firebase not ready. Cannot export drafts.", "error"); return;
        }
        showGeneralLoading(true);
        try {
            const draftsCollectionRef = collection(fbDb, "artifacts", appId, "users", fbUserId, "scheduleDrafts");
            const q = query(draftsCollectionRef, orderBy("createdAt", "desc"));
            const querySnapshot = await getDocs(q);
            
            const draftsToExport = [];
            querySnapshot.forEach((docSnap) => {
                const data = docSnap.data();
                // We don't export the serverTimestamp object directly, but its representation if needed.
                // For simplicity, we'll export the core data.
                draftsToExport.push({
                    name: data.name,
                    html: data.html,
                    meta: data.meta,
                    activeTableId: data.activeTableId,
                    // Firebase Timestamps are objects; convert to string for JSON if desired, or omit for re-import
                    createdAt: data.createdAt && data.createdAt.toDate ? data.createdAt.toDate().toISOString() : null 
                });
            });

            if (draftsToExport.length === 0) {
                showMessage('No drafts in Cloud to export.', 'info'); return;
            }

            const blob = new Blob([JSON.stringify(draftsToExport, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = `firebase_schedule_drafts_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a); a.click(); document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showMessage('All Cloud drafts exported successfully!', 'success');

        } catch (error) {
            console.error("Error exporting drafts from Firestore:", error);
            showMessage(`Failed to export drafts. Error: ${error.message}`, "error");
        } finally {
            showGeneralLoading(false);
        }
    }

    async function handleFirestoreDraftsImport(event) {
        if (!fbDb || !fbUserId || !fbIsAuthReady) {
            showMessage("Firebase not ready. Cannot import drafts.", "error"); return;
        }
        const file = event.target.files[0];
        if (!file) { showMessage('No file selected for import.', 'info'); return; }
        if (file.type !== 'application/json') {
            showMessage('Invalid file type. Please select a .json file exported from this app.', 'error');
            event.target.value = ''; return;
        }
        
        showGeneralLoading(true);
        const reader = new FileReader();
        reader.onload = async (e) => {
            try {
                const importedDraftsData = JSON.parse(e.target.result);
                if (!Array.isArray(importedDraftsData)) {
                    showMessage('Invalid draft file format. Expected an array of drafts.', 'error'); return;
                }

                let importedCount = 0, skippedCount = 0;
                const draftsCollectionRef = collection(fbDb, "artifacts", appId, "users", fbUserId, "scheduleDrafts");

                for (const draft of importedDraftsData) {
                    if (draft && typeof draft.name === 'string' && typeof draft.html === 'string' && typeof draft.meta === 'object' && typeof draft.activeTableId === 'string') {
                        // Simple check for existing draft by name (can be made more robust)
                        const q = query(draftsCollectionRef, where("name", "==", draft.name));
                        const existingSnapshot = await getDocs(q);

                        if (!existingSnapshot.empty) {
                             if (await customConfirm(`A cloud draft named "${draft.name}" already exists. Overwrite?`)) {
                                // For simplicity, we'll delete and add. A more robust way would be to update.
                                for(const docToDel of existingSnapshot.docs) {
                                    await deleteDoc(docToDel.ref);
                                }
                            } else {
                                skippedCount++;
                                continue; // Skip this draft
                            }
                        }
                        
                        await addDoc(draftsCollectionRef, {
                            name: draft.name,
                            html: draft.html,
                            meta: draft.meta,
                            activeTableId: draft.activeTableId,
                            createdAt: serverTimestamp() // New timestamp for imported draft
                        });
                        importedCount++;
                    } else {
                        console.warn("Skipping invalid draft object during import:", draft);
                        skippedCount++;
                    }
                }
                showMessage(`Drafts import to Cloud: ${importedCount} imported/overwritten, ${skippedCount} skipped.`, 'success', 5000);
                if (draftListContainerElement && (draftListContainerElement.style.display === 'block' || importedCount > 0)) {
                    await loadAndRenderDraftsFromFirestore(); 
                }
            } catch (error) { 
                console.error("Error processing draft file for Firestore import:", error);
                showMessage('Error processing draft file. Ensure it is a valid JSON export from this app.', 'error', 5000); 
            }
            finally { 
                event.target.value = ''; 
                showGeneralLoading(false);
            } 
        };
        reader.onerror = () => { 
            showMessage('Failed to read the draft file.', 'error'); 
            event.target.value = ''; 
            showGeneralLoading(false);
        };
        reader.readAsText(file);
    }


    // --- Inline Autocomplete Functions ---
    function showCellAutocompleteSuggestions(cell, inputText) {
        if (!autocompleteSuggestionsDiv) return;

        const namesForAutocomplete = currentNameListSession === 'pagi' ? namesPagi : namesPetang;
        const normalizedInput = String(inputText || '').toLowerCase().trim();
        
        if (!normalizedInput) {
            hideCellAutocompleteSuggestions();
            return;
        }

        const filteredSuggestions = namesForAutocomplete.filter(name => {
            const nameStr = String(name || '').toLowerCase().trim();
            return nameStr.startsWith(normalizedInput) && nameStr !== normalizedInput;
        });

        if (filteredSuggestions.length > 0) {
            activeCellForAutocomplete = cell;
            autocompleteSuggestionsDiv.innerHTML = ''; 
            filteredSuggestions.slice(0, 10).forEach(suggestion => { 
                const item = document.createElement('div');
                item.className = 'suggestion-item';
                item.textContent = suggestion;
                item.addEventListener('mousedown', (e) => { 
                    e.preventDefault(); 
                    selectCellAutocompleteSuggestion(suggestion);
                });
                autocompleteSuggestionsDiv.appendChild(item);
            });

            const cellRect = cell.getBoundingClientRect();
            autocompleteSuggestionsDiv.style.left = `${cellRect.left + window.scrollX}px`;
            autocompleteSuggestionsDiv.style.top = `${cellRect.bottom + window.scrollY}px`;
            autocompleteSuggestionsDiv.style.minWidth = `${cellRect.width}px`;
            autocompleteSuggestionsDiv.style.display = 'block';
            currentAutocompleteIndex = -1; 
        } else {
            hideCellAutocompleteSuggestions();
        }
    }

    function hideCellAutocompleteSuggestions() {
        if (autocompleteSuggestionsDiv) {
            autocompleteSuggestionsDiv.style.display = 'none';
        }
        activeCellForAutocomplete = null;
        currentAutocompleteIndex = -1;
    }

    function selectCellAutocompleteSuggestion(suggestionText) {
        if (activeCellForAutocomplete) {
            const targetCell = activeCellForAutocomplete; 
            
            const overlay = targetCell.querySelector('.merged-cell-overlay');
            if (overlay) {
                overlay.textContent = suggestionText;
            } else {
                targetCell.textContent = suggestionText;
            }
            
            hideCellAutocompleteSuggestions();
            rebuildAndRenderSummary();

            targetCell.focus(); 
            const range = document.createRange();
            const sel = window.getSelection();
            if (targetCell.childNodes.length > 0) {
                range.selectNodeContents(overlay ? overlay : targetCell); 
                range.collapse(false); 
            } else {
                range.setStart(targetCell, 0);
                range.collapse(true);
            }
            sel.removeAllRanges();
            sel.addRange(range);
        }
    }
    
    function updateCellSuggestionHighlight() {
        if (!autocompleteSuggestionsDiv || autocompleteSuggestionsDiv.style.display === 'none') return;
        const items = autocompleteSuggestionsDiv.querySelectorAll('.suggestion-item');
        items.forEach((item, index) => {
            item.classList.toggle('active-suggestion', index === currentAutocompleteIndex);
        });
    }


    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', () => {
        scheduleTitleElement = document.getElementById('scheduleTitle');
        tablesContainer = document.getElementById('tablesContainer');
        tableTabs = document.getElementById('tableTabs');
        nameModal = document.getElementById('nameModal');
        nameModalContent = document.getElementById('nameModalContent');
        nameModalHeader = document.getElementById('nameModalHeader');
        nameListContainer = document.getElementById('nameList');
        newNameInput = document.getElementById('newNameInput');
        draftListContainerElement = document.getElementById('draftListContainer'); // Updated ID
        summaryTableElement = document.getElementById('summaryTable');
        customMessageBox = document.getElementById('customMessageBox');
        fileInputElement = document.getElementById('fileInput');
        directCopyFullHtmlButtonElement = document.getElementById('directCopyFullHtmlBtn');
        closeNameModalButtonStandardElement = document.getElementById('closeNameModalBtnStandard');
        nameListImportFileInputElement = document.getElementById('nameListImportFile');
        searchNameInputElement = document.getElementById('searchNameInput');
        draftImportFileInputElement = document.getElementById('draftImportFile');
        userIdDisplayElement = document.getElementById('userIdDisplay');
        namePagiTabElement = document.getElementById('namePagiTab');
        namePetangTabElement = document.getElementById('namePetangTab');
        loadingIndicatorModalElement = document.getElementById('loadingIndicatorModal');
        nameModalTitleElement = document.getElementById('nameModalTitle');
        generalLoadingIndicatorElement = document.getElementById('generalLoadingIndicator');


        autocompleteSuggestionsDiv = document.createElement('div');
        autocompleteSuggestionsDiv.id = 'autocompleteSuggestions';
        document.body.appendChild(autocompleteSuggestionsDiv);


        if (!tablesContainer || !tableTabs || !nameModal || !summaryTableElement || !scheduleTitleElement || !draftListContainerElement || !generalLoadingIndicatorElement) {
            console.error("CRITICAL DOM elements missing.");
            document.body.innerHTML = "<p style='color:red; text-align:center;'>Error: App failed to init (missing elements).</p>";
            return;
        }

        if (fbAuth) {
            onAuthStateChanged(fbAuth, async (user) => {
                if (user) {
                    fbUserId = user.uid;
                    fbIsAuthReady = true;
                    if(userIdDisplayElement) userIdDisplayElement.textContent = `User ID: ${fbUserId}`;
                    if (unsubscribePagi) unsubscribePagi();
                    if (unsubscribePetang) unsubscribePetang();
                    unsubscribePagi = listenToNameList('pagi');
                    unsubscribePetang = listenToNameList('petang');
                    if (nameModal && nameModal.style.display === 'flex' && searchNameInputElement) {
                        renderNameListFromFirestore(searchNameInputElement.value);
                    }
                    // Optionally load drafts if the list was open or on initial load
                    // if (draftListContainerElement && draftListContainerElement.style.display === 'block') {
                    //    await loadAndRenderDraftsFromFirestore();
                    // }
                } else {
                    fbIsAuthReady = false; fbUserId = null;
                    if(userIdDisplayElement) userIdDisplayElement.textContent = "User ID: Authenticating...";
                    try {
                        if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                            await signInWithCustomToken(fbAuth, __initial_auth_token);
                        } else {
                            await signInAnonymously(fbAuth);
                        }
                    } catch (error) {
                        console.error("Error during Firebase sign-in:", error);
                        showMessage(`Firebase Auth failed. Cloud features may not work. Error: ${error.message}`, "error", 7000);
                        if(userIdDisplayElement) userIdDisplayElement.textContent = `User ID: Auth Error`;
                    }
                }
            });
        } else {
             if(userIdDisplayElement) userIdDisplayElement.textContent = "User ID: Firebase Auth Not Initialized";
             showMessage("Critical Error: Firebase Auth service could not be initialized.", "error", 10000);
        }

        loadScheduleTitleFromLocalStorage(); // Title is still local
        initializeEventListeners();
        setupInitialTableState();
        rebuildAndRenderSummary();
        handleNameListSessionSwitch('pagi');
    });

    function setupInitialTableState() {
        const existingTables = tablesContainer.querySelectorAll('table');
        if (existingTables.length > 0) {
            tableTabs.innerHTML = '';
            existingTables.forEach((table, index) => {
                const tableId = table.id || `tbl_init_${Date.now()}_${index + 1}`;
                table.id = tableId;
                const tableName = table.dataset.tableName || `Table ${index + 1}`;
                table.dataset.tableName = tableName;
                addTabButton(tableId, tableName);
                if (index === 0) activeTableId = tableId;
            });
        } else {
            addNewTable(true); 
        }
        if (activeTableId && document.getElementById(activeTableId)) {
            switchTable(activeTableId);
        } else if (tablesContainer.querySelector('table')) {
            switchTable(tablesContainer.querySelector('table').id);
        }
    }

    function loadScheduleTitleFromLocalStorage() { // Renamed for clarity
        const savedTitle = localStorage.getItem(SCHEDULE_TITLE_KEY);
        if (savedTitle && scheduleTitleElement) scheduleTitleElement.textContent = savedTitle;
        if (scheduleTitleElement) {
            scheduleTitleElement.addEventListener('blur', () => { 
                localStorage.setItem(SCHEDULE_TITLE_KEY, scheduleTitleElement.textContent);
                showMessage('Schedule title saved (locally)!', 'success');
            });
        }
    }

    function initializeEventListeners() {
        if(directCopyFullHtmlButtonElement) directCopyFullHtmlButtonElement.addEventListener('click', attemptDirectCopyToClipboard);
        if(closeNameModalButtonStandardElement) closeNameModalButtonStandardElement.addEventListener('click', closeNameModal);
        if(nameModalHeader) {
            nameModalHeader.addEventListener('mousedown', startDragModal);
            nameModalHeader.addEventListener('touchstart', startDragModal, { passive: false });
        }
        document.addEventListener('mousemove', dragModal);
        document.addEventListener('mouseup', stopDragModal);
        document.addEventListener('touchmove', dragModal, { passive: false });
        document.addEventListener('touchend', stopDragModal);
        document.getElementById('excelBtnTrigger')?.addEventListener('click', exportActiveTableToExcel);
        document.getElementById('importExcelBtn')?.addEventListener('click', () => fileInputElement?.click());
        if(fileInputElement) fileInputElement.addEventListener('change', handleExcelFileImport);
        
        // Draft buttons
        document.getElementById('saveDraftBtn')?.addEventListener('click', saveDraftToFirestore);
        document.getElementById('loadDraftBtn')?.addEventListener('click', loadAndRenderDraftsFromFirestore);
        document.getElementById('exportDraftsBtn')?.addEventListener('click', exportAllFirestoreDrafts);
        document.getElementById('importDraftsBtn')?.addEventListener('click', () => draftImportFileInputElement?.click());
        if(draftImportFileInputElement) draftImportFileInputElement.addEventListener('change', handleFirestoreDraftsImport);
        
        if(draftListContainerElement) draftListContainerElement.addEventListener('click', async (e) => {
            const targetSpan = e.target.closest('.draft-item span[data-draft-id]');
            const targetButton = e.target.closest('.draft-item button[data-draft-id]');
            if (targetSpan) {
                loadSelectedDraftFromFirestore(targetSpan.dataset.draftId);
            } else if (targetButton) {
                const draftId = targetButton.dataset.draftId;
                const draftName = targetButton.parentElement.querySelector('span[data-draft-id]').textContent;
                await confirmAndDeleteDraftFromFirestore(draftId, draftName);
            }
        });

        document.getElementById('clearActiveTableContentBtn')?.addEventListener('click', confirmAndClearActiveTableContent);
        document.getElementById('selectBtn')?.addEventListener('click', toggleCellSelectionMode);
        document.getElementById('mergeBtn')?.addEventListener('click', mergeSelectedTableCells);
        document.getElementById('deselectBtn')?.addEventListener('click', deselectAllTableCells);
        document.getElementById('unmergeBtn')?.addEventListener('click', unmergeActiveCellIfMerged);
        document.getElementById('addTableBtn')?.addEventListener('click', () => addNewTable());
        document.getElementById('renameTableBtn')?.addEventListener('click', promptAndRenameActiveTable);
        document.getElementById('deleteTableBtn')?.addEventListener('click', confirmAndDeleteActiveTable);
        document.getElementById('addRowAboveBtn')?.addEventListener('click', addRowAboveToActiveTable);
        document.getElementById('addRowBelowBtn')?.addEventListener('click', addRowBelowToActiveTable);
        document.getElementById('addColLeftBtn')?.addEventListener('click', addColumnLeftToActiveTable);
        document.getElementById('addColRightBtn')?.addEventListener('click', addColumnRightToActiveTable);
        document.getElementById('deleteRowBtn')?.addEventListener('click', deleteClickedRowFromActiveTable);
        document.getElementById('deleteColBtn')?.addEventListener('click', deleteClickedColumnFromActiveTable);
        document.getElementById('nameListBtn')?.addEventListener('click', toggleNameListModalVisibility);
        document.getElementById('addNameBtnInModal')?.addEventListener('click', () => {
            if(newNameInput) addNameToCurrentSessionInFirestore(newNameInput.value);
        });
        document.getElementById('importNameListBtn')?.addEventListener('click', () => nameListImportFileInputElement?.click());
        if(nameListImportFileInputElement) nameListImportFileInputElement.addEventListener('change', handleNameListImportFirestore);
        if(searchNameInputElement) searchNameInputElement.addEventListener('input', (e) => renderNameListFromFirestore(e.target.value));
        if(namePagiTabElement) namePagiTabElement.addEventListener('click', () => handleNameListSessionSwitch('pagi'));
        if(namePetangTabElement) namePetangTabElement.addEventListener('click', () => handleNameListSessionSwitch('petang'));
        if(nameListContainer) nameListContainer.addEventListener('click', async (e) => {
            const nameItemSpan = e.target.closest('.name-item span[data-name]');
            const deleteButton = e.target.closest('.name-item button[data-name-delete]');
            if (nameItemSpan) {
                selectNameForCellInsertion(nameItemSpan.dataset.name);
            } else if (deleteButton) {
                await deleteNameFromCurrentSessionInFirestore(deleteButton.dataset.nameDelete);
            }
        });
        if(tablesContainer) {
            tablesContainer.addEventListener('click', handleTableCellClick);
            
            tablesContainer.addEventListener('input', (e) => {
                const cell = e.target;
                if ((cell.tagName === 'TD' || (cell.tagName === 'TH' && cell.closest('tbody'))) && cell.isContentEditable) {
                    const text = cell.textContent;
                    if (cell.cellIndex > 0 || cell.closest('table')?.querySelector('thead th:first-child')?.textContent?.toLowerCase() !== 'class') {
                         showCellAutocompleteSuggestions(cell, text);
                    } else {
                        hideCellAutocompleteSuggestions();
                    }
                    setTimeout(rebuildAndRenderSummary, 300);
                } else if (cell.classList.contains('merged-cell-overlay')) {
                    const text = cell.textContent;
                    const parentCell = cell.parentElement;
                     if (parentCell && (parentCell.cellIndex > 0 || parentCell.closest('table')?.querySelector('thead th:first-child')?.textContent?.toLowerCase() !== 'class')) {
                        showCellAutocompleteSuggestions(parentCell, text); 
                    } else {
                        hideCellAutocompleteSuggestions();
                    }
                    setTimeout(rebuildAndRenderSummary, 300);
                }
            });

            tablesContainer.addEventListener('blur', (e) => { 
                const cell = e.target;
                if ((cell.tagName === 'TD' || cell.tagName === 'TH' || cell.classList.contains('merged-cell-overlay')) && cell.isContentEditable !== false) { 
                    setTimeout(rebuildAndRenderSummary, 0);
                    setTimeout(() => {
                        if (autocompleteSuggestionsDiv && autocompleteSuggestionsDiv.style.display === 'block' &&
                            !autocompleteSuggestionsDiv.contains(document.activeElement) &&
                            activeCellForAutocomplete !== document.activeElement && 
                            (activeCellForAutocomplete && activeCellForAutocomplete.querySelector('.merged-cell-overlay') !== document.activeElement) 
                           ) {
                           hideCellAutocompleteSuggestions();
                        }
                    }, 150); 
                }
            }, true); 
        }
        window.addEventListener('resize', () => {
            updateAllMergeOverlays();
            hideCellAutocompleteSuggestions(); 
        }); 

        document.addEventListener('keydown', (e) => {
            if (autocompleteSuggestionsDiv && autocompleteSuggestionsDiv.style.display === 'block' && activeCellForAutocomplete) {
                const items = autocompleteSuggestionsDiv.querySelectorAll('.suggestion-item');
                if (items.length === 0 && e.key !== 'Escape') return;

                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    currentAutocompleteIndex = (currentAutocompleteIndex + 1) % items.length;
                    updateCellSuggestionHighlight();
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    currentAutocompleteIndex = (currentAutocompleteIndex - 1 + items.length) % items.length;
                    updateCellSuggestionHighlight();
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    if (currentAutocompleteIndex >= 0 && currentAutocompleteIndex < items.length) {
                        selectCellAutocompleteSuggestion(items[currentAutocompleteIndex].textContent);
                    } else {
                        hideCellAutocompleteSuggestions();
                        if(activeCellForAutocomplete) activeCellForAutocomplete.blur(); 
                    }
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    hideCellAutocompleteSuggestions();
                } else if (e.key === 'Tab') {
                    hideCellAutocompleteSuggestions(); 
                }
            }
        });

        document.addEventListener('click', (event) => {
            if (autocompleteSuggestionsDiv && autocompleteSuggestionsDiv.style.display === 'block') {
                const isClickInsideCell = activeCellForAutocomplete && activeCellForAutocomplete.contains(event.target);
                const isClickInsideOverlay = activeCellForAutocomplete && activeCellForAutocomplete.querySelector('.merged-cell-overlay')?.contains(event.target);
                const isClickInsideSuggestions = autocompleteSuggestionsDiv.contains(event.target);
                
                if (!isClickInsideCell && !isClickInsideSuggestions && !isClickInsideOverlay) {
                    hideCellAutocompleteSuggestions();
                }
            }
        });
    }

    function startDragModal(e) {
        if (e.target.closest('.modal-close-btn')) { isDraggingModal = false; return; } 
        isDraggingModal = true;
        if(nameModalContent) nameModalContent.classList.add('dragging');
        const clientX = e.clientX || (e.touches && e.touches[0].clientX);
        const clientY = e.clientY || (e.touches && e.touches[0].clientY);
        const rect = nameModalContent.getBoundingClientRect();
        nameModalContent.style.position = 'fixed';
        nameModalContent.style.left = `${rect.left}px`;
        nameModalContent.style.top = `${rect.top}px`;
        nameModalContent.style.transform = 'none'; 
        modalDragOffsetX = clientX - nameModalContent.offsetLeft;
        modalDragOffsetY = clientY - nameModalContent.offsetTop;
        if (e.type === 'touchstart') e.preventDefault(); 
    }

    function dragModal(e) {
        if (!isDraggingModal || !nameModalContent) return;
        const clientX = e.clientX || (e.touches && e.touches[0].clientX);
        const clientY = e.clientY || (e.touches && e.touches[0].clientY);
        let newLeft = clientX - modalDragOffsetX;
        let newTop = clientY - modalDragOffsetY;
        const modalRect = nameModalContent.getBoundingClientRect(); 
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        if (newLeft < 0) newLeft = 0;
        if (newTop < 0) newTop = 0;
        if (newLeft + modalRect.width > viewportWidth) newLeft = viewportWidth - modalRect.width;
        if (newTop + modalRect.height > viewportHeight) newTop = viewportHeight - modalRect.height;
        nameModalContent.style.left = `${newLeft}px`;
        nameModalContent.style.top = `${newTop}px`;
        if (e.type === 'touchmove') e.preventDefault(); 
    }

    function stopDragModal() {
        if (isDraggingModal && nameModalContent) {
            isDraggingModal = false;
            nameModalContent.classList.remove('dragging');
        }
    }

    async function attemptDirectCopyToClipboard() {
        const fullHtml = document.documentElement.outerHTML;
        try {
            await navigator.clipboard.writeText(fullHtml);
            showMessage('Full HTML copied to clipboard!', 'success');
        } catch (err) {
            const textarea = document.createElement('textarea');
            textarea.value = fullHtml;
            textarea.style.position = 'fixed'; textarea.style.left = '-9999px';
            document.body.appendChild(textarea);
            textarea.select();
            try {
                document.execCommand('copy') ? showMessage('Full HTML copied! (fallback)', 'success') : showMessage('Direct copy failed.', 'error', 5000);
            } catch (execErr) { showMessage('Direct copy failed.', 'error', 5000); }
            document.body.removeChild(textarea);
        }
    }

    async function confirmAndClearActiveTableContent() {
        const activeTableElement = document.getElementById(activeTableId);
        if (!activeTableElement) { showMessage('No active table to clear.', 'error'); return; }
        const tableName = activeTableElement.dataset.tableName || `Table ${activeTableId.split('_').pop()}`;
        if (await customConfirm(`Are you sure you want to clear all content and unmerge cells in "${tableName}"? This will not delete saved drafts.`)) {
            activeTableElement.querySelectorAll('.merged-cell-container').forEach(containerCell => {
                const mergeId = containerCell.dataset.mergeId;
                if(mergeId){
                    const cellsInGroup = activeTableElement.querySelectorAll(`[data-merge-id="${mergeId}"]`);
                    cellsInGroup.forEach(c => {
                        c.removeAttribute('data-merge-id');
                        c.classList.remove('merged-cell-container', 'subsumed-cell');
                        const overlay = c.querySelector('.merged-cell-overlay');
                        if (overlay) c.textContent = overlay.textContent; 
                        else c.innerHTML = ''; 
                        const overlayChild = c.querySelector('.merged-cell-overlay'); 
                        if(overlayChild) overlayChild.remove();
                    });
                }
            });
            activeTableElement.querySelectorAll('tbody td, tbody th').forEach(cell => {
                cell.innerHTML = ''; 
                cell.classList.remove('selected'); 
            });
            selectedCells = []; 
            rebuildAndRenderSummary();
            updateAllMergeOverlays();
            showMessage(`Content of "${tableName}" cleared.`, 'success');
        }
    }

    function addTabButton(id, label) {
        if (!tableTabs) return null;
        const button = document.createElement('button');
        button.textContent = label; button.dataset.tableId = id;
        button.title = `Switch to table: ${label}`;
        button.onclick = () => switchTable(id);
        tableTabs.appendChild(button);
        return button;
    }

    function switchTable(id) {
        const targetTable = document.getElementById(id);
        if (!targetTable && tablesContainer) { 
            const firstTableInDOM = tablesContainer.querySelector('table');
            if (firstTableInDOM) id = firstTableInDOM.id; 
            else { 
                if (tablesContainer && tablesContainer.children.length === 0) addNewTable(true); 
                return;
            }
        }
        activeTableId = id;
        if(tablesContainer) tablesContainer.querySelectorAll('table').forEach(t => t.classList.toggle('active', t.id === id));
        if(tableTabs) tableTabs.querySelectorAll('button').forEach(b => { b.classList.toggle('active', b.dataset.tableId === id); });
        deselectAllTableCells(); 
        rebuildAndRenderSummary();
        updateAllMergeOverlays();
        hideCellAutocompleteSuggestions(); 
    }

    function addNewTable(isInitial = false) {
        if (!tablesContainer || !tableTabs) return;
        tableCount++; 
        const defaultTableName = `Schedule ${tableTabs.children.length + 1}`;
        const label = isInitial ? defaultTableName : customPrompt('Enter new table name:', defaultTableName);
        if (!label && !isInitial) return; 
        const newTable = document.createElement('table');
        newTable.id = `tbl_${Date.now()}_${tableCount}`; 
        newTable.dataset.tableName = label || defaultTableName;
        const thead = newTable.createTHead();
        const headerRow = thead.insertRow();
        const defaultHeaders = ['Class/Time', '08:00-09:00', '09:00-10:00', '10:00-11:00', '11:00-12:00', '12:00-13:00'];
        defaultHeaders.forEach(headerText => {
            const th = document.createElement('th');
            th.contentEditable = 'true'; th.textContent = headerText;
            headerRow.appendChild(th);
        });
        const tbody = newTable.createTBody();
        for (let r = 0; r < 2; r++) {
            const dataRow = tbody.insertRow();
            for (let c = 0; c < headerRow.cells.length; c++) {
                const td = dataRow.insertCell(); td.contentEditable = 'true';
                if (c === 0) td.textContent = `Sample Class ${String.fromCharCode(65 + r)}`; 
            }
        }
        tablesContainer.appendChild(newTable);
        addTabButton(newTable.id, label || defaultTableName);
        switchTable(newTable.id); 
        if (!isInitial) showMessage(`Table "${label || defaultTableName}" added.`, 'success');
    }

    async function promptAndRenameActiveTable() {
        if (!tableTabs) return;
        const currentTab = tableTabs.querySelector('button.active');
        if (!currentTab) { showMessage('No active table to rename.', 'error'); return; }
        let tableIdToRename = currentTab.dataset.tableId;
        if (!tableIdToRename) {
            const match = currentTab.getAttribute('onclick')?.match(/'(tbl_.*?)'/);
            if (match && match[1]) tableIdToRename = match[1];
            else { showMessage('Could not identify table ID for renaming.', 'error'); return; }
        }
        const tableElement = document.getElementById(tableIdToRename);
        if (!tableElement) { showMessage(`Table element for ID ${tableIdToRename} not found.`, 'error'); return; }
        const oldName = tableElement.dataset.tableName || currentTab.textContent;
        const newName = customPrompt('Enter new table name:', oldName);
        if (newName && newName.trim() && newName.trim() !== oldName) {
            const trimmedNewName = newName.trim();
            currentTab.textContent = trimmedNewName; currentTab.title = `Switch to table: ${trimmedNewName}`; 
            tableElement.dataset.tableName = trimmedNewName;
            showMessage(`Table renamed to "${trimmedNewName}".`, 'success');
        } else if (newName && newName.trim() === oldName) showMessage('Name unchanged.', 'info');
        else if (newName === null) showMessage('Rename cancelled.', 'info');
        else showMessage('Invalid new name.', 'error');
    }

    async function confirmAndDeleteActiveTable() {
        if (!tablesContainer || !tableTabs || tablesContainer.children.length <= 1) {
            showMessage('Cannot delete the last table.', 'error'); return;
        }
        const activeTab = tableTabs.querySelector('button.active');
        const tableIdToDelete = activeTab?.dataset.tableId;
        const tableElement = tableIdToDelete ? document.getElementById(tableIdToDelete) : null;
        const tableName = tableElement?.dataset.tableName || activeTab?.textContent || 'the active table';
        if (await customConfirm(`Delete table "${tableName}"? This cannot be undone.`)) {
            if (tableElement) tableElement.remove();
            else if (document.getElementById(activeTableId)) document.getElementById(activeTableId).remove();
            activeTab?.remove(); 
            const firstRemainingTab = tableTabs.querySelector('button');
            if (firstRemainingTab) { 
                const nextActiveId = firstRemainingTab.dataset.tableId || firstRemainingTab.getAttribute('onclick').match(/'(tbl_.*?)'/)[1]; 
                switchTable(nextActiveId);
            } else { activeTableId = null; addNewTable(true); }
            showMessage(`Table "${tableName}" deleted.`, 'success');
        }
    }

    function addRowToTable(tableBody, rowIndex, numCols) {
        const row = tableBody.insertRow(rowIndex); 
        for (let i = 0; i < numCols; i++) {
            const cell = row.insertCell(); cell.contentEditable = 'true';
        }
    }
    function addRowAboveToActiveTable() {
        const table = document.getElementById(activeTableId);
        if (!table || !table.tBodies[0] || table.rows.length === 0) return; 
        const numCols = table.rows[0].cells.length; 
        let insertAtIndex = (lastClickedCell && lastClickedCell.closest('tbody') && lastClickedCell.parentElement.rowIndex >= 0) ? lastClickedCell.parentElement.rowIndex : 0; 
        addRowToTable(table.tBodies[0], insertAtIndex, numCols);
        rebuildAndRenderSummary(); updateAllMergeOverlays();
    }
    function addRowBelowToActiveTable() {
        const table = document.getElementById(activeTableId);
        if (!table || !table.tBodies[0] || table.rows.length === 0) return;
        const numCols = table.rows[0].cells.length;
        let insertAtIndex = (lastClickedCell && lastClickedCell.closest('tbody') && lastClickedCell.parentElement.rowIndex >= 0) ? lastClickedCell.parentElement.rowIndex + 1 : -1; 
        addRowToTable(table.tBodies[0], insertAtIndex, numCols);
        rebuildAndRenderSummary(); updateAllMergeOverlays();
    }
    function addColumnToTable(table, colIndex) { 
        for (const row of table.rows) {
            const isHeaderRow = row.parentElement.tagName === 'THEAD';
            const cell = isHeaderRow ? document.createElement('th') : row.insertCell(colIndex === -1 ? row.cells.length : colIndex);
            cell.contentEditable = 'true';
            if (isHeaderRow) {
                cell.textContent = "New Header";
                if (colIndex !== -1 && row.cells[colIndex]) row.insertBefore(cell, row.cells[colIndex]);
                else row.appendChild(cell);
            }
        }
    }
    function addColumnLeftToActiveTable() {
        const table = document.getElementById(activeTableId);
        if (!table) return;
        let insertAtIndex = (lastClickedCell && lastClickedCell.cellIndex >= 0) ? lastClickedCell.cellIndex : 0;
        addColumnToTable(table, insertAtIndex);
        rebuildAndRenderSummary(); updateAllMergeOverlays();
    }
    function addColumnRightToActiveTable() {
        const table = document.getElementById(activeTableId);
        if (!table) return;
        let insertAtIndex = (lastClickedCell && lastClickedCell.cellIndex >= 0) ? lastClickedCell.cellIndex + 1 : -1;
        addColumnToTable(table, insertAtIndex);
        rebuildAndRenderSummary(); updateAllMergeOverlays();
    }
    async function deleteClickedRowFromActiveTable() {
        if (!lastClickedCell) { showMessage('Click a cell in the row to delete.', 'info'); return; }
        const table = document.getElementById(activeTableId);
        if (!table || !table.tBodies[0]) { showMessage('No active table body.', 'error'); return; }
        const rowToDelete = lastClickedCell.closest('tr');
        if (!rowToDelete || rowToDelete.parentElement.tagName !== 'TBODY') {
            showMessage('Cannot delete header. Click a data row cell.', 'error'); return;
        }
        if (table.tBodies[0].rows.length <= 1) { showMessage('Cannot delete the last data row.', 'error'); return; }
        if (await customConfirm('Delete this row?')) {
            rowToDelete.remove(); lastClickedCell = null; 
            deselectAllTableCells(); 
            rebuildAndRenderSummary(); updateAllMergeOverlays();
            showMessage('Row deleted.', 'success');
        }
    }
    async function deleteClickedColumnFromActiveTable() {
        if (!lastClickedCell) { showMessage('Click a cell in the column to delete.', 'info'); return; }
        const table = document.getElementById(activeTableId);
        if (!table) { showMessage('No active table.', 'error'); return; }
        if (table.rows[0] && table.rows[0].cells.length <= 1) { showMessage('Cannot delete the last column.', 'error'); return; }
        const colIndexToDelete = lastClickedCell.cellIndex;
        if (await customConfirm('Delete this column?')) {
            for (const row of table.rows) {
                if (row.cells[colIndexToDelete]) row.cells[colIndexToDelete].remove();
            }
            lastClickedCell = null; deselectAllTableCells();
            rebuildAndRenderSummary(); updateAllMergeOverlays();
            showMessage('Column deleted.', 'success');
        }
    }

    function toggleCellSelectionMode() {
        selectionMode = !selectionMode;
        const btn = document.getElementById('selectBtn');
        if(btn) {
            btn.classList.toggle('active', selectionMode);
            btn.textContent = selectionMode ? '‚ú® Selecting...' : '‚ú® Select Cells';
        }
        if (!selectionMode) deselectAllTableCells(); 
        hideCellAutocompleteSuggestions(); 
    }

    function handleTableCellClick(event) {
        const cell = event.target.closest('td, th');
        if (!cell || !cell.closest(`#${activeTableId}`)) return; 
        lastClickedCell = cell; 
        if (autocompleteSuggestionsDiv && autocompleteSuggestionsDiv.style.display === 'block' && !autocompleteSuggestionsDiv.contains(event.target) && activeCellForAutocomplete !== cell) {
            hideCellAutocompleteSuggestions();
        }

        if (selectedNameFromList) { 
            if (cell.tagName === 'TD' || (cell.tagName === 'TH' && cell.closest('tbody'))) { 
                const overlay = cell.querySelector('.merged-cell-overlay');
                if (overlay) overlay.textContent = selectedNameFromList;
                else cell.textContent = selectedNameFromList;
                rebuildAndRenderSummary(); 
                showMessage(`Inserted "${selectedNameFromList}".`, 'success', 2500);
                clearNameSelection(); 
            } else {
                showMessage('Click an editable data cell to insert name.', 'info');
            }
            return; 
        }
        if (selectionMode) { 
            if (cell.classList.contains('subsumed-cell') ||
                (cell.classList.contains('merged-cell-container') && selectedCells.some(sc => sc !== cell && sc.dataset.mergeId !== cell.dataset.mergeId))) {
                showMessage('Cannot select subsumed cells or mix merge groups.', 'warning'); return;
            }
            cell.classList.toggle('selected');
            if (cell.classList.contains('selected')) selectedCells.push(cell);
            else selectedCells = selectedCells.filter(c => c !== cell);
        }
    }

    function deselectAllTableCells() {
        selectedCells.forEach(c => c.classList.remove('selected'));
        selectedCells = [];
    }

    function mergeSelectedTableCells() {
        if (selectedCells.length < 2) { showMessage('Select at least two cells to merge.', 'error'); return; }
        if (selectedCells.some(cell => cell.dataset.mergeId)) {
            showMessage('Cannot merge already merged cells. Unmerge first.', 'warning'); return;
        }
        let primaryCell = selectedCells[0];
        let minRowGUI = primaryCell.parentElement.getBoundingClientRect().top;
        let minColGUI = primaryCell.getBoundingClientRect().left;
        selectedCells.forEach(cell => {
            const cellRowRect = cell.parentElement.getBoundingClientRect();
            const cellRect = cell.getBoundingClientRect();
            if (cellRowRect.top < minRowGUI || (cellRowRect.top === minRowGUI && cellRect.left < minColGUI)) {
                primaryCell = cell; minRowGUI = cellRowRect.top; minColGUI = cellRect.left;
            }
        });
        let minLeft = Infinity, maxRight = -Infinity, minTop = Infinity, maxBottom = -Infinity;
        selectedCells.forEach(cell => {
            const rect = cell.getBoundingClientRect();
            minLeft = Math.min(minLeft, rect.left); maxRight = Math.max(maxRight, rect.right);
            minTop = Math.min(minTop, rect.top); maxBottom = Math.max(maxBottom, rect.bottom);
        });
        const totalWidth = maxRight - minLeft; const totalHeight = maxBottom - minTop;
        const mergeId = `merge-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const overlay = document.createElement('div');
        overlay.className = 'merged-cell-overlay';
        overlay.textContent = primaryCell.textContent; 
        overlay.contentEditable = 'true'; 
        overlay.style.setProperty('--merged-width', `${totalWidth}px`);
        overlay.style.setProperty('--merged-height', `${totalHeight}px`);
        overlay.addEventListener('blur', () => { rebuildAndRenderSummary(); });
        overlay.addEventListener('input', (e) => { 
            const text = e.target.textContent;
            if (primaryCell && (primaryCell.cellIndex > 0 || primaryCell.closest('table')?.querySelector('thead th:first-child')?.textContent?.toLowerCase() !== 'class')) {
                 showCellAutocompleteSuggestions(primaryCell, text);
            } else {
                 hideCellAutocompleteSuggestions();
            }
        });


        primaryCell.innerHTML = ''; primaryCell.appendChild(overlay);
        primaryCell.classList.add('merged-cell-container');
        primaryCell.setAttribute('data-merge-id', mergeId);
        selectedCells.forEach(cell => {
            if (cell !== primaryCell) {
                cell.textContent = ''; cell.classList.add('subsumed-cell');
                cell.setAttribute('data-merge-id', mergeId);
            }
        });
        deselectAllTableCells();
        if (selectionMode) toggleCellSelectionMode(); 
        showMessage('Cells visually merged.', 'success');
    }

    function unmergeActiveCellIfMerged() {
        const cell = lastClickedCell; 
        if (!cell) { showMessage('Click a merged cell to unmerge.', 'info'); return; }
        const containerCell = cell.closest('[data-merge-id]'); 
        if (!containerCell) { showMessage('Clicked cell is not merged.', 'error'); return; }
        const mergeId = containerCell.dataset.mergeId;
        const table = containerCell.closest('table');
        if (!table) return;
        const cellsInGroup = table.querySelectorAll(`[data-merge-id="${mergeId}"]`);
        let originalText = '';
        const primaryCellInGroup = Array.from(cellsInGroup).find(c => c.classList.contains('merged-cell-container'));
        if (primaryCellInGroup) {
            const overlay = primaryCellInGroup.querySelector('.merged-cell-overlay');
            if (overlay) originalText = overlay.textContent;
            else originalText = primaryCellInGroup.textContent; 
        }
        cellsInGroup.forEach(c => {
            c.removeAttribute('data-merge-id');
            c.classList.remove('merged-cell-container', 'subsumed-cell');
            const overlayChild = c.querySelector('.merged-cell-overlay');
            if (overlayChild) overlayChild.remove(); 
            c.innerHTML = ''; 
        });
        if (primaryCellInGroup) primaryCellInGroup.textContent = originalText;
        else if (cellsInGroup.length > 0) cellsInGroup[0].textContent = originalText;
        rebuildAndRenderSummary();
        showMessage('Cells unmerged.', 'success');
    }

    function updateAllMergeOverlays() {
        const activeTable = document.getElementById(activeTableId);
        if (!activeTable) return;
        const mergedContainers = activeTable.querySelectorAll('.merged-cell-container');
        mergedContainers.forEach(containerCell => {
            const mergeId = containerCell.dataset.mergeId; if (!mergeId) return;
            const overlay = containerCell.querySelector('.merged-cell-overlay'); if (!overlay) return;
            const cellsInGroup = Array.from(activeTable.querySelectorAll(`[data-merge-id="${mergeId}"]`));
            if (cellsInGroup.length === 0) return;
            let minLeft = Infinity, maxRight = -Infinity, minTop = Infinity, maxBottom = -Infinity;
            cellsInGroup.forEach(cellInvolved => {
                const rect = cellInvolved.getBoundingClientRect();
                minLeft = Math.min(minLeft, rect.left); maxRight = Math.max(maxRight, rect.right);
                minTop = Math.min(minTop, rect.top); maxBottom = Math.max(maxBottom, rect.bottom);
            });
            if (minLeft === Infinity) return; 
            overlay.style.setProperty('--merged-width', `${maxRight - minLeft}px`);
            overlay.style.setProperty('--merged-height', `${maxBottom - minTop}px`);
        });
    }

    function handleNameListSessionSwitch(session) {
        currentNameListSession = session;
        if(namePagiTabElement) namePagiTabElement.classList.toggle('active', session === 'pagi');
        if(namePetangTabElement) namePetangTabElement.classList.toggle('active', session === 'petang');
        if(nameModalTitleElement) nameModalTitleElement.textContent = `Name List Manager (${session === 'pagi' ? 'Pagi' : 'Petang'})`;
        if(searchNameInputElement) searchNameInputElement.value = ''; 
        renderNameListFromFirestore(); 
        hideCellAutocompleteSuggestions(); 
    }

    function highlightSelectedNameInList(nameToHighlight) { 
        if (!nameListContainer) return;
        const nameToHighlightStr = String(nameToHighlight || '');
        nameListContainer.querySelectorAll('.name-item span').forEach(span => {
            span.classList.toggle('highlighted', String(span.dataset.name || '') === nameToHighlightStr);
        });
    }

    function clearNameSelection() { 
        selectedNameFromList = null;
        if (nameListContainer) {
            nameListContainer.querySelectorAll('.name-item span.highlighted').forEach(span => {
                span.classList.remove('highlighted');
            });
        }
    }

    function closeNameModal() {
        if (nameModal) nameModal.style.display = 'none';
        clearNameSelection(); 
        if(searchNameInputElement) searchNameInputElement.value = ''; 
    }

    function toggleNameListModalVisibility() {
        if (!nameModal || !nameModalContent || !newNameInput) return;
        const isDisplayed = nameModal.style.display === 'flex';
        if (isDisplayed) closeNameModal();
        else {
            nameModalContent.style.position = 'relative'; 
            nameModalContent.style.left = 'auto'; nameModalContent.style.top = 'auto';
            nameModalContent.style.transform = 'none'; 
            nameModal.style.display = 'flex';
            if(searchNameInputElement) searchNameInputElement.value = ''; 
            handleNameListSessionSwitch(currentNameListSession); 
            if(newNameInput) newNameInput.focus();
            clearNameSelection();
        }
        hideCellAutocompleteSuggestions(); 
    }

    function renderNameListFromFirestore(filterText = '') { 
        if (!nameListContainer) return;
        if (!fbIsAuthReady) {
            nameListContainer.innerHTML = '<p style="text-align:center; grid-column: 1 / -1;">Loading names...</p>'; return;
        }
        nameListContainer.innerHTML = ''; 
        const namesToRender = currentNameListSession === 'pagi' ? namesPagi : namesPetang;
        const normalizedFilterText = String(filterText || '').toLowerCase().trim();
        if (!Array.isArray(namesToRender)) {
            nameListContainer.innerHTML = '<p style="text-align:center; color:red;">Error: Name list data invalid.</p>'; return;
        }
        const filteredNames = namesToRender.filter(name => String(name || '').toLowerCase().trim().includes(normalizedFilterText));
        if (filteredNames.length === 0) {
            nameListContainer.innerHTML = `<p style="text-align:center; grid-column: 1 / -1;">${normalizedFilterText ? 'No names match.' : `No names in ${currentNameListSession} session.`}</p>`; return;
        }
        filteredNames.forEach(name => {
            const itemDiv = document.createElement('div'); itemDiv.className = 'name-item';
            const nameStr = String(name || '');
            const safeNameAttr = nameStr.replace(/"/g, '&quot;');
            itemDiv.innerHTML = `<span data-name="${safeNameAttr}" title="Select '${safeNameAttr}'">${nameStr}</span><button data-name-delete="${safeNameAttr}" title="Delete '${safeNameAttr}'">Delete</button>`;
            nameListContainer.appendChild(itemDiv);
        });
        highlightSelectedNameInList(selectedNameFromList); 
    }

    function selectNameForCellInsertion(name) { 
        selectedNameFromList = String(name || '');
        highlightSelectedNameInList(selectedNameFromList); 
        showMessage(`Selected "${selectedNameFromList}". Click a cell to insert.`, 'info', 4000);
    }

    function handleNameListImportFirestore(event) {
        const file = event.target.files[0];
        if (!file) { showMessage('No file selected.', 'info'); return; }
        if (file.type !== 'text/plain') {
            showMessage('Invalid file type (.txt only).', 'error');
            event.target.value = ''; return;
        }
        const reader = new FileReader();
        reader.onload = async (e) => {
            try {
                const importedNames = e.target.result.split(/\r?\n/).map(n => String(n||'').trim()).filter(n => n);
                if (importedNames.length === 0) { showMessage('No names in file.', 'info'); return; }
                const currentSessionNames = (currentNameListSession === 'pagi' ? namesPagi : namesPetang).map(n => String(n||'').trim());
                const combinedNames = [...new Set([...currentSessionNames, ...importedNames])];
                await saveNameListToFirestore(currentNameListSession, combinedNames);
            } catch (error) { showMessage('Error processing name list file.', 'error'); }
            finally { event.target.value = ''; }
        };
        reader.onerror = () => { showMessage('Failed to read name list file.', 'error'); event.target.value = ''; };
        reader.readAsText(file);
    }

    function handleExcelFileImport(event) {
        const file = event.target.files[0];
        if (!file || !tablesContainer) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const workbook = XLSX.read(new Uint8Array(e.target.result), { type: 'array' });
                const sheetName = workbook.SheetNames[0]; 
                const worksheet = workbook.Sheets[sheetName];
                const htmlTableString = XLSX.utils.sheet_to_html(worksheet, { raw: false }); 
                tableCount++;
                const newTableId = `tbl_imported_${Date.now()}_${tableCount}`;
                const importedTableName = file.name.replace(/\.xlsx?$/i, '') || `Imported ${tableCount}`;
                const tempDiv = document.createElement('div'); tempDiv.innerHTML = htmlTableString;
                const importedTableElement = tempDiv.querySelector('table');
                if (importedTableElement) {
                    importedTableElement.id = newTableId;
                    importedTableElement.dataset.tableName = importedTableName;
                    importedTableElement.querySelectorAll('td, th, .merged-cell-overlay').forEach(cell => cell.contentEditable = 'true');
                    tablesContainer.appendChild(importedTableElement);
                    addTabButton(newTableId, importedTableName);
                    switchTable(newTableId); 
                    showMessage('Excel data imported!', 'success');
                } else showMessage('Could not parse table from Excel.', 'error');
            } catch (error) { showMessage('Error processing Excel file.', 'error'); }
            finally { event.target.value = ''; } 
        };
        reader.readAsArrayBuffer(file);
    }

    function exportActiveTableToExcel() {
        const tableToExport = document.getElementById(activeTableId);
        if (!tableToExport) { showMessage('No active table to export.', 'error'); return; }
        const overlaysData = []; 
        tableToExport.querySelectorAll('.merged-cell-overlay').forEach(overlay => {
            const parentCell = overlay.parentElement;
            overlaysData.push({ parent: parentCell, originalHTML: parentCell.innerHTML });
            parentCell.textContent = overlay.textContent; 
        });
        const tableName = tableToExport.dataset.tableName || activeTableId;
        const wb = XLSX.utils.table_to_book(tableToExport, { sheet: tableName });
        XLSX.writeFile(wb, `${tableName}_${new Date().toISOString().split('T')[0]}.xlsx`);
        overlaysData.forEach(data => { 
            data.parent.innerHTML = data.originalHTML; 
            const newOverlay = data.parent.querySelector('.merged-cell-overlay');
            if (newOverlay) {
                newOverlay.addEventListener('blur', () => rebuildAndRenderSummary());
                newOverlay.addEventListener('input', (e) => {
                    const text = e.target.textContent;
                    if (data.parent && (data.parent.cellIndex > 0 || data.parent.closest('table')?.querySelector('thead th:first-child')?.textContent?.toLowerCase() !== 'class')) {
                        showCellAutocompleteSuggestions(data.parent, text);
                    } else {
                        hideCellAutocompleteSuggestions();
                    }
                });
            }
        });
        if(overlaysData.length > 0) updateAllMergeOverlays(); 
        showMessage(`Table "${tableName}" exported.`, 'success');
    }

    function rebuildAndRenderSummary() {
        const scheduledNames = new Set(); 
        if (tablesContainer) {
            tablesContainer.querySelectorAll('table').forEach(scheduleTable => { // Iterate over ALL tables
                if (!scheduleTable.tBodies[0]) return; 
                scheduleTable.tBodies[0].querySelectorAll('tr').forEach(row => {
                    Array.from(row.cells).forEach((cell, cellIndex) => {
                        // Only collect names from cells that are NOT in the first column (cellIndex > 0).
                        // The first column (cellIndex === 0) is assumed to contain class identifiers
                        // and should not be added to the list of teacher/subject names for the summary.
                        if (cellIndex > 0) {
                            const overlay = cell.querySelector('.merged-cell-overlay');
                            const nameFromCell = String(overlay ? overlay.textContent : cell.textContent || '').trim();
                            if (nameFromCell) { // Ensure the cell is not empty
                                scheduledNames.add(nameFromCell);
                            }
                        }
                    });
                });
            });
        }
        const allSummaryNames = [...scheduledNames].sort((a, b) => String(a).localeCompare(String(b), undefined, { sensitivity: 'base' }));
        buildSummaryTableSkeleton(allSummaryNames);
        updateSummaryTableData(allSummaryNames);
    }

    function parseTimeToMinutes(timeStr) {
        if (typeof timeStr !== 'string') return Infinity; 
        const match = timeStr.match(/^(\d{1,2})\s*[:.]\s*(\d{2})/);
        if (match) return parseInt(match[1], 10) * 60 + parseInt(match[2], 10);
        return Infinity; 
    }

    function buildSummaryTableSkeleton(allAvailableNames) { 
        if (!summaryTableElement) return; 
        summaryTableElement.innerHTML = ''; 
        const tempRawHeadersFromSchedules = new Set(); 
        if (tablesContainer) {
            tablesContainer.querySelectorAll('table').forEach(scheduleTable => {
                if (scheduleTable.tHead && scheduleTable.tHead.rows.length > 0) {
                    for (let hIdx = 1; hIdx < scheduleTable.tHead.rows[0].cells.length; hIdx++) { 
                        const headerText = String(scheduleTable.tHead.rows[0].cells[hIdx].textContent || '').trim();
                        if (headerText) tempRawHeadersFromSchedules.add(headerText);
                    }
                }
            });
        }
        let laulisahRuleRequiresSpecialSlot = false;
        const specialNamesForRule = ["LAU", "LISAH"];
        const targetSlotForSpecialNamesRule = "10.15-10.30";
        const sourceSlotToShiftRule = "10.30-12.00";
        if (tablesContainer) {
            for (const scheduleTable of tablesContainer.querySelectorAll('table')) {
                if (laulisahRuleRequiresSpecialSlot) break; 
                if (!scheduleTable.tHead?.rows.length > 0 || !scheduleTable.tBodies[0]) continue;
                const currentScheduleTableHeaders = Array.from(scheduleTable.tHead.rows[0].cells).map(th => String(th.textContent||'').trim());
                Array.from(scheduleTable.tBodies[0].rows).forEach((scheduleDataRow) => {
                    if (laulisahRuleRequiresSpecialSlot) return;
                    for (let cellIdx = 1; cellIdx < scheduleDataRow.cells.length; cellIdx++) {
                         const scheduleCell = scheduleDataRow.cells[cellIdx];
                         let entryInScheduleCell = String(scheduleCell.querySelector('.merged-cell-overlay')?.textContent || scheduleCell.textContent||'').trim();
                         if (specialNamesForRule.includes(entryInScheduleCell)) {
                            const headerText = currentScheduleTableHeaders[cellIdx];
                            if (headerText && headerText.replace(/\s/g, "").replace(/:/g,".") === sourceSlotToShiftRule.replace(/\s/g, "").replace(/:/g,".")) {
                                laulisahRuleRequiresSpecialSlot = true; return; 
                            }
                         }
                    }
                });
            }
        }
        if (laulisahRuleRequiresSpecialSlot) tempRawHeadersFromSchedules.add(targetSlotForSpecialNamesRule);
        
        let sortedOriginalUniqueHeaders = Array.from(tempRawHeadersFromSchedules).sort((a, b) => {
            const timeA = parseTimeToMinutes(a); const timeB = parseTimeToMinutes(b);
            if (timeA !== Infinity && timeB !== Infinity) return timeA - timeB;
            if (timeA !== Infinity) return -1; if (timeB !== Infinity) return 1;  
            return String(a).localeCompare(String(b));
        });
        const finalSummaryColumnHeaders = ['Nama/Masa', ...sortedOriginalUniqueHeaders];
        const thead = summaryTableElement.createTHead();
        const headerRowForSummary = thead.insertRow();
        finalSummaryColumnHeaders.forEach(headerText => {
            const th = document.createElement('th'); th.textContent = headerText;
            headerRowForSummary.appendChild(th);
        });
        const tbody = summaryTableElement.createTBody();
        if (allAvailableNames.length === 0) { 
            const tr = tbody.insertRow(); const td = tr.insertCell();
            td.textContent = "No names scheduled yet.";
            td.colSpan = finalSummaryColumnHeaders.length || 1;
            td.style.textAlign = 'center'; td.style.fontStyle = 'italic';
        } else {
            allAvailableNames.forEach(name => {
                const tr = tbody.insertRow();
                tr.insertCell().textContent = String(name || '');
                for (let i = 1; i < finalSummaryColumnHeaders.length; i++) tr.insertCell().textContent = '';
            });
        }
    }

    function updateSummaryTableData(allAvailableNames) { 
        if (!summaryTableElement?.tBodies?.[0] || !summaryTableElement.tHead?.rows?.[0]) return; 
        const summaryBody = summaryTableElement.tBodies[0];
        if (summaryBody.rows.length === 0 && !(summaryBody.rows[0]?.cells[0]?.colSpan > 1)) return;
        
        const summaryTableDisplayHeaders = Array.from(summaryTableElement.tHead.rows[0].cells).map(th => String(th.textContent||'').trim());
        const normalizedSummaryHeadersForLookup = summaryTableDisplayHeaders.map(h => h.replace(/\s/g, "").replace(/:/g,"."));
        
        Array.from(summaryBody.rows).forEach(summaryRow => { 
            if (summaryRow.cells.length > 1) Array.from(summaryRow.cells).slice(1).forEach(cell => {
                cell.textContent = ''; cell.classList.remove('highlight-conflict'); 
            });
        });

        if (tablesContainer) {
            tablesContainer.querySelectorAll('table').forEach(scheduleTable => {
                if (!scheduleTable.tHead?.rows.length > 0 || !scheduleTable.tBodies[0]) return; 
                const scheduleHeaders = Array.from(scheduleTable.tHead.rows[0].cells).map(th => String(th.textContent||'').trim());
                Array.from(scheduleTable.tBodies[0].rows).forEach((scheduleDataRow) => {
                    const classIdentifier = String(scheduleDataRow.cells[0]?.textContent||'').trim();
                    if (!classIdentifier) return; 
                    for (let cellIdx = 1; cellIdx < scheduleDataRow.cells.length; cellIdx++) {
                        const scheduleCell = scheduleDataRow.cells[cellIdx];
                        let entryInScheduleCell = String(scheduleCell.querySelector('.merged-cell-overlay')?.textContent || scheduleCell.textContent||'').trim();
                        if (entryInScheduleCell) { 
                            let scheduleColumnHeaderForThisCell = scheduleHeaders[cellIdx];
                            if (!scheduleColumnHeaderForThisCell) continue; 
                            let summaryColumnToUse = scheduleColumnHeaderForThisCell;
                            const specialNamesForRule = ["LAU", "LISAH"];
                            const targetSlotForSpecialNamesRule = "10.15-10.30";
                            const sourceSlotToShiftRule = "10.30-12.00";
                            if (specialNamesForRule.includes(entryInScheduleCell) && scheduleColumnHeaderForThisCell.replace(/\s/g, "").replace(/:/g,".") === sourceSlotToShiftRule.replace(/\s/g, "").replace(/:/g,".")) {
                                summaryColumnToUse = targetSlotForSpecialNamesRule;
                            }
                            const targetSummaryRow = Array.from(summaryBody.rows).find(sr => String(sr.cells[0]?.textContent||'') === entryInScheduleCell);
                            if (targetSummaryRow?.cells.length > 1) {
                                const targetSummaryColumnCellIndex = normalizedSummaryHeadersForLookup.indexOf(summaryColumnToUse.replace(/\s/g, "").replace(/:/g,"."));
                                if (targetSummaryColumnCellIndex > 0) { 
                                    const summaryCellToUpdate = targetSummaryRow.cells[targetSummaryColumnCellIndex];
                                    let existingClasses = summaryCellToUpdate.textContent.trim() ? summaryCellToUpdate.textContent.trim().split(',').map(s => s.trim()) : [];
                                    if (!existingClasses.includes(classIdentifier)) {
                                        existingClasses.push(classIdentifier);
                                        summaryCellToUpdate.textContent = existingClasses.sort((a,b) => String(a).localeCompare(String(b), undefined, { sensitivity: 'base' })).join(', ');
                                    }
                                }
                            }
                        }
                    }
                });
            });
        }
        Array.from(summaryBody.rows).forEach(summaryRow => { 
            if (summaryRow.cells.length > 1) Array.from(summaryRow.cells).forEach((cell, cellIndex) => {
                if (cellIndex > 0 && cell.textContent.includes(',')) cell.classList.add('highlight-conflict');
            });
        });
    }

</script>
</body>
</html>