<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title></title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <style>
    body { font-family: Arial, Helvetica, sans-serif; margin: 28px }
    h2 { margin: 0 0 12px }
    table { border-collapse: collapse; width: 100%; margin-top: 10px }
    th, td { border: 1px solid #999; padding: 8px; text-align: center; min-width: 90px }
    th { background: #f2f2f2 }
    td.selected, th.selected { outline: 3px solid #ffdf6a }
    .merged { background: #e0e0e0; font-style: italic }
    .bar { display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 10px }
    .bar button { padding: 8px 12px; font-size: 14px; border-radius: 4px; cursor: pointer; border: 1px solid #666; background: #fff }
    #excelBtn { background: #2e8b57; color: #fff; border: none }
    #saveDraftBtn { background: #0b65c2; color: #fff; border: none }
    #loadDraftBtn { background: #ff8c00; color: #fff; border: none }
    #mergeBtn { background: #6a5acd; color: #fff; border: none }
    #unmergeBtn { background: #cd5c5c; color: #fff; border: none }
    #msg { color: #c00; margin-top: 10px; display: none }
    #draftList { margin-top: 10px; padding: 5px; border: 1px solid #ccc; max-height: 150px; overflow-y: auto; display: none }
    #draftList div { padding: 5px; cursor: pointer }
    #draftList div:hover { background: #f0f0f0 }
    #fileInput { display: none }
  </style>
</head>
<body>
  <h2 contenteditable="true"></h2>
  <div class="bar">
    <button id="excelBtn" onclick="promptExcelExport()">üíæ Save to Excel</button>
    <input type="file" id="fileInput" accept=".xlsx" onchange="handleExcelFile(event)" style="display: none" />
    <button id="saveDraftBtn" onclick="promptSaveDraft()">üí† Save Draft</button>
    <button id="loadDraftBtn" onclick="toggleDraftList()">üìÇ Load Draft</button>
    <button onclick="clearDraft()">üóëÔ∏è Clear Draft</button>
    <button id="mergeBtn" onclick="mergeCells()">üîó Merge Cells</button>
    <button id="unmergeBtn" onclick="unmergeCells()">üîó Unmerge Cells</button>
  </div>
  <div id="draftList"></div>
  <div class="bar">
    <button onclick="addRowAbove()">‚¨ÜÔ∏è Row Above</button>
    <button onclick="addRowBelow()">‚¨áÔ∏è Row Below</button>
    <button onclick="addColLeft()">‚¨ÖÔ∏è Col Left</button>
    <button onclick="addColRight()">‚û°Ô∏è Col Right</button>
  </div>
  <table id="tbl">
    <thead>
      <tr>
        <th contenteditable="true">7.15 ‚Äì 8.15</th>
        <th contenteditable="true">8.15 ‚Äì 9.15</th>
        <th contenteditable="true">9.15 ‚Äì 10.15</th>
        <th contenteditable="true">10.15 ‚Äì 10.30 (REHAT)</th>
        <th contenteditable="true">10.30 ‚Äì 11.30</th>
        <th contenteditable="true">11.30 ‚Äì 12.30</th>
        <th contenteditable="true">12.30 ‚Äì 13.00</th>
      </tr>
    </thead>
    <tbody>
      <tr><td contenteditable="true"></td><td contenteditable="true"></td><td contenteditable="true"></td><td contenteditable="true"></td><td contenteditable="true"></td><td contenteditable="true"></td><td contenteditable="true"></td></tr>
      <tr><td contenteditable="true"></td><td contenteditable="true"></td><td contenteditable="true"></td><td contenteditable="true"></td><td contenteditable="true"></td><td contenteditable="true"></td><td contenteditable="true"></td></tr>
      <tr><td contenteditable="true"></td><td contenteditable="true"></td><td contenteditable="true"></td><td contenteditable="true"></td><td contenteditable="true"></td><td contenteditable="true"></td><td contenteditable="true"></td></tr>
      <tr><td contenteditable="true"></td><td contenteditable="true"></td><td contenteditable="true"></td><td contenteditable="true"></td><td contenteditable="true"></td><td contenteditable="true"></td><td contenteditable="true"></td></tr>
    </tbody>
  </table>
  <p id="msg">‚ö†Ô∏è SheetJS not found ‚Äì export disabled.</p>
  <script>
    const T = document.getElementById('tbl'), DRAFTS_KEY = 'jadual_drafts', pageHeader = document.querySelector('h2');
    let sel = { r: 0, c: 0 }, lastFileName = null, selectedCells = [];
    T.addEventListener('click', e => { if (e.target.tagName !== 'TD' && e.target.tagName !== 'TH') return; const cell = e.target, isCtrlKey = e.ctrlKey || e.metaKey, isShiftKey = e.shiftKey; if (isCtrlKey || isShiftKey) { cell.classList.add('selected'); selectedCells.push(cell); if (isShiftKey && selectedCells.length > 1) { const start = selectedCells[0], end = cell, startRow = start.parentNode.rowIndex, startCol = start.cellIndex, endRow = end.parentNode.rowIndex, endCol = end.cellIndex; for (let r = Math.min(startRow, endRow); r <= Math.max(startRow, endRow); r++) for (let c = Math.min(startCol, endCol); c <= Math.max(startCol, endCol); c++) { const cellToSelect = T.rows[r].cells[c]; if (!cellToSelect.classList.contains('selected')) { cellToSelect.classList.add('selected'); selectedCells.push(cellToSelect); } } } } else { [...T.querySelectorAll('.selected')].forEach(c => c.classList.remove('selected')); selectedCells = [cell]; cell.classList.add('selected'); } sel = { r: cell.parentNode.rowIndex, c: cell.cellIndex }; });
    function makeCell(row, isHeader = false) { const cell = isHeader ? row.insertCell(-1) : row.insertCell(-1); if (isHeader) cell.outerHTML = '<th contenteditable="true"></th>'; else { cell.contentEditable = 'true'; cell.textContent = ''; } }
    function addRowAbove() { const r = T.insertRow(sel.r); for (let i = 0; i < T.rows[0].cells.length; i++) makeCell(r); }
    function addRowBelow() { const r = T.insertRow(sel.r + 1); for (let i = 0; i < T.rows[0].cells.length; i++) makeCell(r); }
    function addColLeft() { for (const row of T.rows) { const c = row.insertCell(sel.c); if (row.rowIndex) c.contentEditable = 'true'; else c.outerHTML = '<th contenteditable="true"></th>'; } }
    function addColRight() { for (const row of T.rows) { const c = row.insertCell(sel.c + 1); if (row.rowIndex) c.contentEditable = 'true'; else c.outerHTML = '<th contenteditable="true"></th>'; } }
    function tblArray() { return { table: [...T.rows].map(r => [...r.cells].map(c => { const colspan = c.getAttribute('colspan') || 1, rowspan = c.getAttribute('rowspan') || 1; return { text: c.innerText.trim(), colspan, rowspan }; })), header: pageHeader.innerText.trim() }; }
    function arrayToTbl(a) { [...T.tBodies].forEach(tb => tb.remove()); const tb = T.createTBody(); for (let r = 1; r < a.table.length; r++) { const tr = tb.insertRow(-1); for (let c = 0; c < a.table[r].length; c++) { const { text, colspan, rowspan } = a.table[r][c]; const td = tr.insertCell(-1); td.contentEditable = 'true'; td.textContent = text; if (colspan > 1) td.setAttribute('colspan', colspan); if (rowspan > 1) td.setAttribute('rowspan', rowspan); if (colspan > 1 || rowspan > 1) td.classList.add('merged'); } } while (T.rows[0].cells.length < a.table[0].length) addColRight(); for (let c = 0; c < a.table[0].length; c++) { T.rows[0].cells[c].innerText = a.table[0][c].text; if (a.table[0][c].colspan > 1) T.rows[0].cells[c].setAttribute('colspan', a.table[0][c].colspan); if (a.table[0][c].rowspan > 1) T.rows[0].cells[c].setAttribute('rowspan', a.table[0][c].rowspan); if (a.table[0][c].colspan > 1 || a.table[0][c].rowspan > 1) T.rows[0].cells[c].classList.add('merged'); } pageHeader.innerText = a.header || ''; }
    function getDrafts() { const drafts = localStorage.getItem(DRAFTS_KEY); return drafts ? JSON.parse(drafts) : {}; }
    function saveDraft(title) { const drafts = getDrafts(); drafts[title] = tblArray(); localStorage.setItem(DRAFTS_KEY, JSON.stringify(drafts)); alert(`Draft saved as "${title}"!`); updateDraftList(); }
    function promptSaveDraft() { const title = prompt('Enter a title for this draft:'); if (title && title.trim()) { const drafts = getDrafts(); const trimmedTitle = title.trim(); if (drafts[trimmedTitle] && !confirm(`A draft named "${trimmedTitle}" already exists. Do you want to overwrite it?`)) return; saveDraft(trimmedTitle); } else if (title !== null) alert('Please enter a valid title.'); }
    function loadDraft(title) { const drafts = getDrafts(); if (drafts[title]) { arrayToTbl(drafts[title]); alert(`Loaded draft "${title}"!`); } toggleDraftList(); }
    function updateDraftList() { const drafts = getDrafts(); const draftList = document.getElementById('draftList'); draftList.innerHTML = ''; const titles = Object.keys(drafts); if (titles.length === 0) { draftList.style.display = 'none'; return; } titles.forEach(title => { const div = document.createElement('div'); div.innerText = title; div.onclick = () => loadDraft(title); draftList.appendChild(div); }); draftList.style.display = 'block'; }
    function toggleDraftList() { const draftList = document.getElementById('draftList'); draftList.style.display = draftList.style.display === 'block' ? 'none' : 'block'; updateDraftList(); }
    function clearDraft() { alert('Draft cleared! Reverting to empty table...'); [...T.tBodies].forEach(tb => tb.remove()); const tb = T.createTBody(); for (let c = 0; c < T.rows[0].cells.length; c++) { T.rows[0].cells[c].innerText = ''; T.rows[0].cells[c].removeAttribute('colspan'); T.rows[0].cells[c].removeAttribute('rowspan'); T.rows[0].cells[c].classList.remove('merged'); } pageHeader.innerText = ''; document.getElementById('draftList').style.display = 'none'; lastFileName = null; }
    function promptExcelExport() { const sheetName = prompt('Enter the Excel sheet title (max 31 characters):', 'Schedule'); if (sheetName && sheetName.trim()) { const trimmedSheetName = sheetName.trim().slice(0, 31); handleExcelFile({ target: { files: [] } }, trimmedSheetName); } else if (sheetName !== null) alert('Please enter a valid sheet title.'); }
    function handleExcelFile(event, customSheetName = null) { const file = event.target.files[0]; if (file) { lastFileName = file.name; const reader = new FileReader(); reader.onload = e => { const data = new Uint8Array(e.target.result); const workbook = XLSX.read(data, { type: 'array' }); exportExcel(workbook, customSheetName || 'Schedule'); }; reader.readAsArrayBuffer(file); event.target.value = ''; } else exportExcel(null, customSheetName || 'Schedule'); }
    function exportExcel(existingWorkbook, sheetName) { const msg = document.getElementById('msg'); msg.style.display = 'none'; if (typeof XLSX === 'undefined') { msg.style.display = 'block'; return; } const headerText = pageHeader.innerText.trim(); const hasHeader = headerText !== ''; const tableData = [...T.rows].map(r => [...r.cells].map(c => { const colspan = c.getAttribute('colspan') || 1, rowspan = c.getAttribute('rowspan') || 1; return { text: c.innerText.trim(), colspan, rowspan }; })); const aoa = hasHeader ? [[headerText]] : []; aoa.push(...tableData.map(row => row.map(cell => cell.text))); const ws = XLSX.utils.aoa_to_sheet(aoa); const colWidths = Array(tableData[0].length).fill(0); aoa.forEach((row, rIdx) => row.forEach((cell, cIdx) => { if (cIdx < colWidths.length) colWidths[cIdx] = Math.max(colWidths[cIdx], (cell || '').toString().length); })); ws['!cols'] = colWidths.map(w => ({ wch: Math.max(w + 2, 10) })); ws['!merges'] = tableData.reduce((merges, row, rIdx) => { row.forEach((cell, cIdx) => { if (cell.colspan > 1 || cell.rowspan > 1) merges.push({ s: { r: rIdx + (hasHeader ? 1 : 0), c: cIdx }, e: { r: rIdx + (hasHeader ? 1 : 0) + cell.rowspan - 1, c: cIdx + cell.colspan - 1 } }); }); return merges; }, []); if (hasHeader) ws['!merges'].push({ s: { r: 0, c: 0 }, e: { r: 0, c: tableData[0].length - 1 } }); const range = XLSX.utils.decode_range(ws['!ref']); for (let r = range.s.r; r <= range.e.r; r++) for (let c = range.s.c; c <= range.e.c; c++) { const cellAddress = XLSX.utils.encode_cell({ r, c }); if (!ws[cellAddress]) continue; ws[cellAddress].s = { alignment: { horizontal: 'center', vertical: 'center', wrapText: true }, border: { top: { style: 'thin', color: { rgb: '000000' } }, bottom: { style: 'thin', color: { rgb: '000000' } }, left: { style: 'thin', color: { rgb: '000000' } }, right: { style: 'thin', color: { rgb: '000000' } } } }; if (hasHeader && r === 0) { ws[cellAddress].s.font = { bold: true, sz: 14 }; ws[cellAddress].s.fill = { fgColor: { rgb: 'E6E6FA' } }; } else if (r === (hasHeader ? 1 : 0)) { ws[cellAddress].s.font = { bold: true }; ws[cellAddress].s.fill = { fgColor: { rgb: 'D3D3D3' } }; } else if (r > (hasHeader ? 1 : 0)) { const rowIdx = r - (hasHeader ? 1 : 0); const cellData = tableData[rowIdx][c]; if (cellData && (cellData.colspan > 1 || cellData.rowspan > 1)) { ws[cellAddress].s.fill = { fgColor: { rgb: 'F0F0F0' } }; ws[cellAddress].s.font = { italic: true }; } } } ws['!freeze'] = { xSplit: 0, ySplit: hasHeader ? 2 : 1 }; ws['!pageSetup'] = { paperSize: 9, orientation: 'landscape', fitToWidth: 1, fitToHeight: 0 }; ws['!margins'] = { left: 0.5, right: 0.5, top: 0.75, bottom: 0.75, header: 0.3, footer: 0.3 }; ws['!printArea'] = { s: { r: 0, c: 0 }, e: { r: tableData.length + (hasHeader ? 1 : 0) - 1, c: tableData[0].length - 1 } }; const wb = existingWorkbook || XLSX.utils.book_new(); const trimmedSheetName = sheetName.slice(0, 31); if (existingWorkbook && existingWorkbook.SheetNames.length > 0) { const existingSheetName = existingWorkbook.SheetNames[0]; existingWorkbook.Sheets[existingSheetName] = ws; existingWorkbook.SheetNames[0] = trimmedSheetName; } else XLSX.utils.book_append_sheet(wb, ws, trimmedSheetName); const currentDate = new Date().toISOString().slice(0, 10); const fileName = lastFileName || `${trimmedSheetName.replace(/[^a-zA-Z0-9]/g, '_') || 'Jadual'}_${currentDate}.xlsx`; XLSX.writeFile(wb, fileName); }
    function mergeCells() { if (selectedCells.length < 2) { alert('Please select at least 2 cells to merge.'); return; } const rows = selectedCells.map(cell => cell.parentNode.rowIndex), cols = selectedCells.map(cell => cell.cellIndex), minRow = Math.min(...rows), maxRow = Math.max(...rows), minCol = Math.min(...cols), maxCol = Math.max(...cols), rowspan = maxRow - minRow + 1, colspan = maxCol - minCol + 1; const topLeftCell = T.rows[minRow].cells[minCol], mergedContent = topLeftCell.innerText; selectedCells.forEach(cell => { if (cell !== topLeftCell) cell.remove(); }); topLeftCell.setAttribute('rowspan', rowspan); topLeftCell.setAttribute('colspan', colspan); topLeftCell.classList.add('merged'); topLeftCell.innerText = mergedContent; selectedCells = []; [...T.querySelectorAll('.selected')].forEach(c => c.classList.remove('selected')); }
    function unmergeCells() { const mergedCells = [...T.querySelectorAll('.merged')]; if (mergedCells.length === 0) { alert('No merged cells to unmerge.'); return; } mergedCells.forEach(cell => { const rowspan = parseInt(cell.getAttribute('rowspan') || 1), colspan = parseInt(cell.getAttribute('colspan') || 1), rowIdx = cell.parentNode.rowIndex, colIdx = cell.cellIndex; cell.removeAttribute('rowspan'); cell.removeAttribute('colspan'); cell.classList.remove('merged'); if (rowspan > 1 || colspan > 1) { const content = cell.innerText; for (let r = 0; r < rowspan; r++) for (let c = 0; c < colspan; c++) if (r === 0 && c === 0) continue; else { const newCell = T.rows[rowIdx + r].insertCell(colIdx + c); newCell.contentEditable = 'true'; newCell.textContent = ''; } cell.innerText = content; } }); selectedCells = []; [...T.querySelectorAll('.selected')].forEach(c => c.classList.remove('selected')); }
    console.log('SheetJS loaded:', typeof XLSX !== 'undefined');
  </script>
</body>
</html>