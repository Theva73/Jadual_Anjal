<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=0.1, maximum-scale=5.0">
    <title>Shared Weekly Schedule with Firestore</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', 'Roboto', Arial, sans-serif;
            margin: 0;
            background-color: #f0f2f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            box-sizing: border-box;
            min-height: 100vh;
        }
        .main-container {
            width: 100%;
            max-width: 1400px;
            background-color: #ffffff;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 6px 20px rgba(0,0,0,0.08);
            box-sizing: border-box;
        }
        h2, h3 {
            color: #1c1e21;
            text-align: center;
            margin-bottom: 20px;
        }
        #scheduleTitle {
            font-size: 2em;
            color: #0056b3;
            border-bottom: 2px solid #0056b3;
            padding-bottom: 10px;
        }
        #userIdDisplay {
            text-align: center;
            font-size: 0.9em;
            color: #555;
            margin-bottom: 15px;
            min-height: 1.2em;
            word-break: break-all;
        }

        /* --- Top Action Buttons Bar --- */
        #topActionButtonsBar {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: stretch;
            justify-content: center;
            margin-bottom: 20px;
            width: 100%;
        }

        .top-action-btn {
            padding: 10px 15px;
            font-size: 0.9em;
            font-weight: 500;
            border-radius: 8px;
            cursor: pointer;
            border: 1px solid transparent;
            color: #ffffff;
            transition: all 0.25s ease-out;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05), 0 1px 2px rgba(0,0,0,0.03);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            white-space: nowrap;
            flex-grow: 1;
            flex-basis: 150px;
            text-align: center;
            min-height: 40px;
            box-sizing: border-box;
        }

        #controlsToggler.top-action-btn {
            background-image: linear-gradient(to right, #007bff 0%, #0056b3 100%);
        }
        #controlsToggler.top-action-btn:hover {
            background-image: linear-gradient(to right, #0069d9 0%, #004085 100%);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1), 0 2px 4px rgba(0,0,0,0.06);
            transform: translateY(-1px);
        }

        #manualSaveBtn.top-action-btn {
            background-image: linear-gradient(to right, #17a2b8 0%, #117a8b 100%);
        }
        #manualSaveBtn.top-action-btn:hover {
            background-image: linear-gradient(to right, #138496 0%, #0c6270 100%);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1), 0 2px 4px rgba(0,0,0,0.06);
            transform: translateY(-1px);
        }

        #downloadPdfBtn.top-action-btn {
             background-image: linear-gradient(to right, #28a745 0%, #1e7e34 100%);
        }
        #downloadPdfBtn.top-action-btn:hover {
             background-image: linear-gradient(to right, #218838 0%, #155724 100%);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1), 0 2px 4px rgba(0,0,0,0.06);
            transform: translateY(-1px);
        }
        
        #clearScheduledNamesBtn.top-action-btn {
            background-image: linear-gradient(to right, #6f42c1 0%, #563d7c 100%);
        }
        #clearScheduledNamesBtn.top-action-btn:hover {
            background-image: linear-gradient(to right, #5a2a9e 0%, #452863 100%);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1), 0 2px 4px rgba(0,0,0,0.06);
            transform: translateY(-1px);
        }

        .top-action-btn:active {
            transform: translateY(0px);
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }

        #controlsToggler .toggler-icon {
            transition: transform 0.3s ease-out;
            width: 18px;
            height: 18px;
        }
        #controlsToggler[aria-expanded="false"] .toggler-icon {
            transform: rotate(180deg);
        }
         #controlsToggler[aria-expanded="true"] .toggler-icon {
            transform: rotate(0deg);
        }

        /* --- Collapsible Button Bars --- */
        #collapsibleButtonBars {
            max-height: 1000px;
            overflow: hidden;
            transition: max-height 0.4s ease-in-out, margin-top 0.4s ease-in-out, padding-top 0.4s ease-in-out, padding-bottom 0.4s ease-in-out;
            padding-top: 5px;
            padding-bottom: 5px;
            width: 100%;
        }
        #collapsibleButtonBars:not(.open) {
            max-height: 0;
            padding-top: 0;
            padding-bottom: 0;
            margin-top: 0;
        }

        .bar {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 15px;
            align-items: stretch;
            justify-content: center;
        }
        .bar button {
            padding: 10px 15px;
            font-size: 0.9em;
            font-weight: 500;
            border-radius: 8px;
            cursor: pointer;
            border: 1px solid #ced4da;
            background-color: #f8f9fa;
            color: #212529;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 1px 2px rgba(0,0,0,0.04);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            flex-grow: 1;
            flex-basis: 120px;
            text-align: center;
            min-width: 100px;
        }
        .bar button:hover {
            border-color: #adb5bd;
            background-color: #e9ecef;
            box-shadow: 0 2px 5px rgba(0,0,0,0.08);
            transform: translateY(-1px);
        }
        .bar button:active {
            transform: translateY(0px);
            background-color: #dee2e6;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.06);
        }

        #directCopyFullHtmlBtn { background-color: #545b62; color: white; border-color: #4e555b;}
        #excelBtnTrigger, #importExcelBtn, #importNameListBtn, .input-group button { background-color: #28a745; color: white; border-color: #23923d;}
        #saveSharedScheduleBtn { background-color: #007bff; color: white; border-color: #0069d9;}
        #loadSharedScheduleBtn { background-color: #ffc107; color: #212529; border-color: #e0a800;}
        #restoreBackupBtn { background-color: #fd7e0f; color: white; border-color: #df6e0d; }
        #clearAndResetScheduleBtn, #nameListBtn { background-color: #fd7e14; color: white; border-color: #e66a04;}
        #selectBtn { background-color: #17a2b8; color: white; border-color: #117a8b;}
        #selectBtn.active { background-color: #e66a04; border-color: #d05f03;}
        #mergeBtn { background-color: #6f42c1; color: white; border-color: #5d37a2;}
        #unmergeBtn { background-color: #e83e8c; color: white; border-color: #d9307b;}
        #addTableBtn { background-color: #20c997; color: white; border-color: #1aa87f;}
#addIndependentTableBtn.top-action-btn {
    background-image: linear-gradient(to right, #ff7f50 0%, #ff4500 100%);
}
#addIndependentTableBtn.top-action-btn:hover {
    background-image: linear-gradient(to right, #ff9966 0%, #cc3700 100%);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1), 0 2px 4px rgba(0,0,0,0.06);
    transform: translateY(-1px);
}

        #renameTableBtn, #deselectBtn { background-color: #6c757d; color: white; border-color: #5a6268;}
        #deleteTableBtn, #rowColManipulationBar button.delete-btn { background-color: #dc3545; color: white; border-color: #c82333;}
        #exportSharedSchedulesBtn { background-color: #4e54c8; color: white; border-color: #3b40a0;}
        #importSharedSchedulesBtn { background-color: #8f94fb; color: white; border-color: #7076f9;}
        
        #directCopyFullHtmlBtn:hover { background-color: #434a50; }
        #excelBtnTrigger:hover, #importExcelBtn:hover, #importNameListBtn:hover, .input-group button:hover { background-color: #1e7e34; }
        #saveSharedScheduleBtn:hover { background-color: #0056b3; }
        #loadSharedScheduleBtn:hover { background-color: #d39e00; }
        #restoreBackupBtn:hover { background-color: #e07010; }
        #clearAndResetScheduleBtn:hover, #nameListBtn:hover { background-color: #d05f03; }
        #selectBtn:hover { background-color: #0f6674; }
        #selectBtn.active:hover { background-color: #c25202;}
        #mergeBtn:hover { background-color: #563299; }
        #unmergeBtn:hover { background-color: #d9307b; }
        #addTableBtn:hover { background-color: #178d6f; }
        #renameTableBtn:hover, #deselectBtn:hover { background-color: #545b62; }
        #deleteTableBtn:hover, #rowColManipulationBar button.delete-btn:hover { background-color: #b21f2d; }
        #exportSharedSchedulesBtn:hover { background-color: #3b40a0; }
        #importSharedSchedulesBtn:hover { background-color: #7076f9; }

        #rowColManipulationBar button { padding: 8px 12px; font-size: 0.85em; }

        table {
            border-collapse: collapse;
            width: 100%;
            margin-top: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            background-color: #fff;
            table-layout: auto; 
        }
        #tablesContainer, #summaryTableContainer {
            overflow-x: auto;
            position: relative;
            width: 100%;
        }
        #tablesContainer > table { display: none; }
        #tablesContainer > table.active { display: table; }
        #summaryTable { margin-top: 25px; }

        th, td {
            border: 1px solid #dee2e6;
            padding: 10px 12px;
            text-align: center;
            min-width: 90px; 
            box-sizing: border-box;
            position: relative;
            font-size: 0.9em;
        }
        table th {
            background-color: #f8f9fa;
            color: #343a40;
            font-weight: 600;
            white-space: nowrap;
        }
        #tablesContainer > table > thead > tr:not(.date-header-row) > th {
            font-weight: bold;
            background-color: #e9ecef;
            color: #343a40;
        }
        #tablesContainer > table > thead > tr:not(.date-header-row) > th:first-child,
        #tablesContainer > table > tbody > tr > td:first-child,
        #tablesContainer > table > tbody > tr > th:first-child {
            font-weight: bold;
            background-color: #e6f7ff; 
            color: #1c1e21;
        }

        #tablesContainer > table > thead > tr.date-header-row > th.date-header-cell {
            font-weight: bold;
            background-color: #cce0ff; 
            color: #1c1e21;
            white-space: normal;
        }
        #tablesContainer > table > thead > tr.date-header-row > th.date-header-cell.merged-cell-container .merged-cell-overlay {
            background-color: #cce0ff; 
            font-weight: bold;
            color: #1c1e21;
        }


        #summaryTable > thead > tr > th {
            font-weight: bold;
            background-color: #e9ecef; 
            color: #212529;
        }
        #summaryTable > thead > tr > th:first-child,
        #summaryTable > tbody > tr > td:first-child {
            font-weight: bold;
            background-color: #e6f7ff !important; 
            color: #1c1e21;
        }
        #summaryTable td.summary-merged-cell {
            background-color: #f0f8ff !important; 
        }
        #summaryTable td { background-color: #fff9e6; } 
        
        td.selected, th.selected {
            outline: 3px solid #007bff;
            background-color: #d1e7fd;
        }
        
        .table-tabs {
            margin-bottom: 15px;
            border-bottom: 2px solid #007bff;
            padding-bottom: 0;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }
        .table-tabs button {
            background-color: transparent; border: none;
            border-bottom: 3px solid transparent; border-radius: 6px 6px 0 0;
            color: #0056b3; font-weight: 500; padding: 10px 15px;
            transition: all 0.2s ease;
        }
        .table-tabs button.active {
            background-color: #007bff; color: white;
            border-color: #0056b3;
        }
        .table-tabs button:hover:not(.active) {
            background-color: #e9f5ff; color: #004494;
        }

        .name-session-tabs {
            margin-bottom: 20px; border-bottom: 2px solid #dee2e6;
            padding-bottom: 8px; display: flex; flex-wrap: wrap; gap: 5px;
        }
        .name-session-tabs button {
            border-bottom-left-radius: 0; border-bottom-right-radius: 0;
            border-bottom: none; margin-bottom: -2px;
            padding: 10px 15px; font-size: 1em;
            background-color: #f8f9fa; border: 1px solid #dee2e6;
            border-bottom: 1px solid #dee2e6;
        }
        .name-session-tabs button.active {
            background-color: #ffffff; color: #007bff;
            border-color: #dee2e6 #dee2e6 #ffffff;
            border-bottom: 1px solid #ffffff;
            font-weight: bold; position: relative; z-index: 1;
        }
        
        .highlight-conflict {
            background-color: #f8d7da !important; font-weight: bold;
            color: #721c24 !important;
        }
        #summaryTable > tbody > tr > td.highlight-conflict:first-child {
            background-color: #e6f7ff !important; 
            color: #721c24 !important; 
        }
        .modal {
            display: none; position: fixed; z-index: 1000; left: 0; top: 0;
            width: 100%; height: 100%; overflow: hidden;
            background-color: rgba(0,0,0,0.5);
            align-items: center; justify-content: center;
            pointer-events: none;
        }
        .modal-content {
            background-color: #fff; padding: 25px; border: 1px solid #ccc;
            width: 90%; max-width: 650px; border-radius: 10px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.3); position: relative;
            pointer-events: auto; max-height: 90vh; overflow-y: auto;
            box-sizing: border-box;
        }
        .modal-content.dragging { transform: none; }
        .modal-header {
            padding-bottom: 15px; border-bottom: 1px solid #e9ecef; margin-bottom: 20px;
            font-size: 1.3em; color: #333; display: flex;
            justify-content: space-between; align-items: center;
            cursor: move; user-select: none;
        }
        .modal-close-btn {
            font-size: 1.8rem; font-weight: bold; line-height: 1; color: #555;
            text-shadow: none; opacity: .7; background: transparent; border: 0;
            cursor: pointer; padding: 0 5px; transition: color 0.2s;
        }
        .modal-close-btn:hover { opacity: 1; color: #dc3545; }
        .name-item {
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px 8px; border-bottom: 1px solid #f1f3f5;
            transition: background-color 0.2s;
        }
        .name-item:hover { background-color: #f8f9fa; }
        .name-item:last-child { border-bottom: none; }
        .name-item span {
            flex-grow: 1; cursor: pointer; color: #007bff; font-weight: 500;
        }
        .name-item span:hover { text-decoration: none; color: #0056b3; }
        .name-item button {
            background-color: #dc3545; color: white; border: none; border-radius: 5px;
            padding: 6px 12px; font-size: 0.9em; transition: background-color 0.2s;
        }
        .name-item button:hover { background-color: #c82333; }
        .highlighted { background-color: #cfe2ff !important; font-weight: bold; }
        
        #sharedScheduleListContainer, #restoreBackupListContainer {
            border: 1px solid #ddd; padding: 15px; margin-bottom: 20px;
            border-radius: 8px; background-color: #f8f9fa;
            max-height: 300px; overflow-y: auto;
        }
        .shared-schedule-item, .backup-schedule-item {
            display: flex; flex-direction: column;
            padding: 10px 8px; border-bottom: 1px solid #e9ecef;
        }
        .shared-schedule-item:last-child, .backup-schedule-item:last-child { border-bottom: none; }

        .schedule-item-main-line {
            display: flex; justify-content: space-between; align-items: center; width: 100%;
        }
        .schedule-item-main-line span {
            cursor: pointer; color: #007bff; flex-grow: 1; margin-right: 10px;
            font-weight: 500;
        }
        .schedule-item-main-line span:hover { text-decoration: underline; }
        .schedule-item-main-line button {
            background-color: #dc3545; color: white; border: none; border-radius: 5px;
            padding: 6px 12px; font-size: 0.9em; flex-shrink: 0;
        }
        .schedule-item-details {
            font-size: 0.8em; color: #6c757d; margin-top: 4px;
            display: flex; flex-direction: column;
            gap: 2px;
        }
        .schedule-item-details .schedule-date,
        .schedule-item-details .original-schedule-name {
             white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }


        #newNameInput, #searchNameInput {
            padding: 10px; margin-right: 8px; border: 1px solid #ccc;
            border-radius: 5px; flex-grow: 1; width: calc(100% - 120px);
            box-sizing: border-box;
        }
         #searchNameInput {
            margin-bottom: 15px; width: 100%; box-sizing: border-box; margin-right: 0;
         }
        .input-group { display: flex; margin-bottom: 15px; width: 100%; }
        .input-group button { padding: 10px 15px; }
        #importNameListBtn { margin-top: 10px; width: 100%; }
        #nameList { margin-top:15px; max-height:250px; overflow-y:auto; }
        @media (min-width: 480px) {
            #nameList { column-count: 2; column-gap: 20px; }
        }
        .custom-message-box {
            display: none; position: fixed; top: 20px; left: 50%;
            transform: translateX(-50%); background-color: #333; color: white;
            padding: 15px 25px; border-radius: 8px; z-index: 2000;
            box-shadow: 0 4px 15px rgba(0,0,0,0.25); font-size: 1.05em;
            text-align: center; width: 90%; max-width: 400px;
        }
        .custom-message-box.success { background-color: #28a745; }
        .custom-message-box.error { background-color: #dc3545; }
        .custom-message-box.info { background-color: #007bff; }
        .merged-cell-container { position: relative; z-index: 2; vertical-align: top; }
        .merged-cell-overlay {
            position: absolute; top: 0; left: 0;
            width: var(--merged-width); height: var(--merged-height);
            background-color: rgba(240, 248, 255, 0.95); 
            font-style: italic; border: 1px solid #add8e6;
            display: flex; align-items: center; justify-content: center;
            overflow: hidden; box-sizing: border-box; z-index: 5;
        }
        .subsumed-cell { visibility: hidden; }
        #loadingIndicatorModal, #generalLoadingIndicator, #loadingIndicatorRestoreModal {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(255, 255, 255, 0.85);
            display: flex; align-items: center; justify-content: center;
            z-index: 10; border-radius: 10px;
        }
        #generalLoadingIndicator { position: fixed; z-index: 3000; border-radius: 0; }
        .spinner {
            border: 5px solid rgba(0, 0, 0, 0.1); width: 40px; height: 40px;
            border-radius: 50%; border-left-color: #007bff;
            animation: spin 1s ease infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        input[type="file"][style*="display:none"],
        input[type="file"][style*="display: none"] {
            position: absolute; left: -9999px; width: 1px; height: 1px; opacity: 0;
        }
        #autocompleteSuggestions {
            display: none; position: absolute; border: 1px solid #ccc;
            background-color: white; z-index: 1001; max-height: 150px;
            overflow-y: auto; min-width: 120px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.15); border-radius: 4px;
        }
        .suggestion-item {
            padding: 8px 10px; cursor: pointer; font-size: 0.9em; white-space: nowrap;
        }
        .suggestion-item:hover, .suggestion-item.active-suggestion {
            background-color: #e9ecef; color: #0056b3;
        }

        /* PDF Specific Styles */
        #pdfContent {
            padding: 5mm; background-color: #fff; color: #333;
            font-family: 'Arial', sans-serif; box-sizing: border-box;
            width: 100%; display: none;
        }
        #pdfContent .pdf-page-wrapper {
            page-break-inside: avoid !important; padding-bottom: 10mm;
            box-sizing: border-box; margin-bottom: 5mm;
        }
         #pdfContent .pdf-page-wrapper:not(:first-child) { page-break-before: always !important; }
        #pdfContent .pdf-page-wrapper:last-child { page-break-after: auto !important; }
        #pdfContent h2 {
            text-align: center; color: #000; margin-bottom: 5mm; font-size: 14pt;
            page-break-after: avoid !important; page-break-inside: avoid !important;
        }
        #pdfContent h3 {
            text-align: center; color: #000; margin-top: 2mm; margin-bottom: 3mm;
            font-size: 11pt; page-break-after: avoid !important; page-break-inside: avoid !important;
        }
        #pdfContent table {
            width: 100% !important; border-collapse: collapse !important;
            margin-bottom: 5mm; box-shadow: none; background-color: #fff;
            table-layout: fixed !important; font-size: 7pt;
            page-break-inside: avoid !important;
        }
        #pdfContent th, #pdfContent td {
            border: 0.5pt solid #333 !important; padding: 1mm 1.5mm;
            text-align: center; word-wrap: break-word; overflow-wrap: break-word;
            background-color: #fff !important; page-break-inside: avoid !important;
        }
        #pdfContent th {
            background-color: #f0f0f0 !important; color: #000; font-weight: bold;
        }
        #pdfContent table thead tr.date-header-row th.date-header-cell {
            background-color: #b8d6ff !important;
            font-weight: bold !important;
            color: #000 !important;
            white-space: normal !important;
        }
        #pdfContent table thead tr:not(.date-header-row) th:first-child,
        #pdfContent table tbody tr td:first-child {
            background-color: #e6f7ff !important; font-weight: bold; white-space: normal;
        }
         #pdfContent table tr { page-break-inside: avoid !important; }
        #pdfContent .pdf-footnote {
            text-align: right; font-size: 6pt; color: #333; margin-top: 3mm;
            padding-top: 2mm; border-top: 0.5pt solid #ccc; width: 100%;
            box-sizing: border-box;
        }

        @media (max-width: 768px) {
            .main-container { padding: 15px; }
            #scheduleTitle { font-size: 1.8em; }
            h3 { font-size: 1.1em; }
            .top-action-btn {
                font-size: 0.85em;
                padding: 8px 12px;
                flex-basis: calc(25% - 6px);
                min-width: 0;
            }
            .bar button { font-size: 0.85em; padding: 8px 12px; flex-basis: 100px; }
            th, td { padding: 8px 10px; min-width: 70px; font-size: 0.85em; }
            .table-tabs button, .name-session-tabs button { padding: 8px 10px; font-size: 0.9em; }
        }
        @media (max-width: 600px) {
             .top-action-btn {
                flex-basis: calc(50% - 4px);
            }
        }
        @media (max-width: 480px) {
            body { padding: 5px; }
            .main-container { padding: 10px; }
            #scheduleTitle { font-size: 1.5em; }
            #controlsToggler .toggler-icon { width: 16px; height: 16px; }
             .bar button { font-size: 0.8em; padding: 6px 10px; gap: 4px; flex-basis: calc(50% - 4px); }
            th, td { padding: 6px 8px; min-width: 60px; font-size: 0.8em; }
             #nameList { column-count: 1; }
        }
    
/* Standalone tables ‚Äì visually dimmed */
.independent-table {
    opacity: 0.9;
}
</style>
</head>
<body>
<div class="main-container">
    <h2 contenteditable="true" id="scheduleTitle">Jadual Anjal</h2>
    <div id="userIdDisplay">User ID: Loading...</div>

    <div id="topActionButtonsBar">
        <button id="controlsToggler" class="top-action-btn" aria-expanded="false" aria-controls="collapsibleButtonBars" title="Toggle button controls visibility">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="toggler-icon"><polyline points="18 15 12 9 6 15"></polyline></svg>
            <span>Show Controls</span>
        </button>
        <button id="manualSaveBtn" class="top-action-btn" title="Manually save current page state to Cloud (also creates a backup)">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg>
            <span>Save Page</span>
        </button>
        <button id="downloadPdfBtn" class="top-action-btn" title="Download schedule tables as PDF">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>
            <span>PDF</span>
        </button>
        <button id="clearScheduledNamesBtn" class="top-action-btn" title="Clear scheduled names from the ACTIVE table (retains merged cell content)">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><line x1="17" y1="8" x2="22" y2="13"></line><line x1="22" y1="8" x2="17" y2="13"></line></svg>
            <span>Clear Names (Active Table)</span>
        </button>
    </div>

    <div id="collapsibleButtonBars">
        <div class="bar">
            <button id="directCopyFullHtmlBtn" title="Copy the entire page's HTML to clipboard">üìã Copy HTML</button>
        </div>
        <div class="bar">
            <button id="excelBtnTrigger" title="Export the currently active table to an Excel file">üíæ Export Excel</button>
            <button id="importExcelBtn" title="Import data from an Excel file into a new table">üìÇ Import Excel</button>
            <input type="file" id="fileInput" accept=".xlsx, .xls" style="display:none">
        </div>
        <div class="bar">
            <button id="saveSharedScheduleBtn" title="Save current schedule to the shared Cloud space (also creates a backup)">üí† Save Shared</button>
            <button id="loadSharedScheduleBtn" title="Show list of shared schedules from Cloud to load">‚òÅÔ∏è Load Shared</button>
            <button id="restoreBackupBtn" title="Restore a schedule from a backup copy">üõ°Ô∏è Restore Backup</button>
            <button id="exportSharedSchedulesBtn" title="Export all shared schedules from Cloud to a JSON file">üì§ Export All</button>
            <button id="importSharedSchedulesBtn" title="Import schedules from a JSON file to the shared Cloud space">üì• Import All</button>
            <input type="file" id="sharedScheduleImportFile" accept=".json" style="display:none;">
            <button id="clearAndResetScheduleBtn" title="Clear all data and start a new schedule">üßπ Clear & New</button>
        </div>
        <div class="bar">
            <button id="selectBtn" title="Toggle cell selection mode on/off">‚ú® Select Cells</button>
            <button id="mergeBtn" title="Merge the currently selected cells">üîó Merge</button>
            <button id="deselectBtn" title="Clear current cell selection">üö´ Deselect</button>
            <button id="unmergeBtn" title="Unmerge the cell that was last clicked if it's part of a merge">üíî Unmerge</button>
        </div>
        <div class="bar">
            <button id="addTableBtn" title="Add a new, empty table/sheet">‚ûï Add Table</button>
            <button id="addIndependentTableBtn" title="Add a standalone table (excluded from summary)">‚ûï Add Standalone Table</button>
            <button id="renameTableBtn" title="Rename the currently active table/sheet">üìù Rename Table</button>
            <button id="deleteTableBtn" title="Delete the currently active table/sheet">‚ùå Delete Table</button>
            <button id="nameListBtn" title="Open a dialog to manage the shared list of names (Firestore)">üë• Names</button>
        </div>
        <div class="bar" id="rowColManipulationBar">
            <button id="addRowAboveBtn" title="Add a new row above the currently selected/clicked row">‚¨ÜÔ∏è Row Above</button>
            <button id="addRowBelowBtn" title="Add a new row below the currently selected/clicked row">‚¨áÔ∏è Row Below</button>
            <button id="addColLeftBtn" title="Add a new column to the left of the currently selected/clicked column">‚¨ÖÔ∏è Col Left</button>
            <button id="addColRightBtn" title="Add a new column to the right of the currently selected/clicked column">‚û°Ô∏è Col Right</button>
            <button id="deleteRowBtn" class="delete-btn" title="Delete the currently selected/clicked row">üóëÔ∏è Del Row</button>
            <button id="deleteColBtn" class="delete-btn" title="Delete the currently selected/clicked column">üóëÔ∏è Del Col</button>
        </div>
    </div>
    <div id="sharedScheduleListContainer" style="display:none;"></div>
    
    <div id="restoreBackupModal" class="modal">
        <div class="modal-content" id="restoreBackupModalContent">
            <div class="modal-header" id="restoreBackupModalHeader">
                <h3 id="restoreBackupModalTitle">Restore Schedule from Backup</h3>
                <button type="button" class="modal-close-btn" id="closeRestoreBackupModalBtn" title="Close restore backup">√ó</button>
            </div>
            <div id="restoreBackupListContainer"></div>
            <div id="loadingIndicatorRestoreModal" style="display:none;"><div class="spinner"></div></div>
        </div>
    </div>

    <div class="bar table-tabs" id="tableTabs"></div>
    <div id="tablesContainer">
        <table id="tbl_1" class="active" data-table-name="Kelas 3 & 5">
            <thead>
                <tr class="date-header-row">
                    <th class="date-header-cell" contenteditable="true">Thursday, 22 May 2025</th>
                    <th class="date-header-cell" contenteditable="true"></th>
                    <th class="date-header-cell" contenteditable="true"></th>
                    <th class="date-header-cell date-header-cell merged-cell-container" contenteditable="true" data-merge-id="date_rehat_tbl1_col4">
                        <div class="merged-cell-overlay" style="--merged-width: 200px; --merged-height: 40px;" contenteditable="true">DAY INFO</div>
                    </th>
                    <th class="date-header-cell subsumed-cell" contenteditable="true" data-merge-id="date_rehat_tbl1_col4"></th>
                    <th class="date-header-cell" contenteditable="true"></th>
                    <th class="date-header-cell" contenteditable="true"></th>
                </tr>
                <tr>
                    <th contenteditable="true">Class</th>
                    <th contenteditable="true">08:00</th>
                    <th contenteditable="true">09:00</th>
                    <th contenteditable="true">10:00</th>
                    <th contenteditable="true" data-merge-id="rehat_tbl1_col4" class="merged-cell-container">
                        <div class="merged-cell-overlay" style="--merged-width: 200px; --merged-height: 50px;" contenteditable="true">REHAT</div>
                    </th>
                    <th contenteditable="true" data-merge-id="rehat_tbl1_col4" class="subsumed-cell">11:00</th>
                    <th contenteditable="true">12:00</th>
                    <th contenteditable="true">13:00</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td contenteditable="true">5S1</td>
                    <td contenteditable="true"></td><td contenteditable="true">JAMES *ReportDue // Sick leave</td><td contenteditable="true"></td>
                    <td contenteditable="true" data-merge-id="rehat_tbl1_col4_row1" class="merged-cell-container">
                         <div class="merged-cell-overlay" style="--merged-width: 200px; --merged-height: 50px;" contenteditable="true"></div>
                    </td>
                    <td contenteditable="true" data-merge-id="rehat_tbl1_col4_row1" class="subsumed-cell"></td>
                    <td contenteditable="true"></td><td contenteditable="true"></td>
                </tr>
                 <tr>
                    <td contenteditable="true">5S2</td>
                    <td contenteditable="true">*SpecialAssembly</td><td contenteditable="true"></td><td contenteditable="true">LILY</td>
                     <td contenteditable="true" data-merge-id="rehat_tbl1_col4_row2" class="merged-cell-container">
                         <div class="merged-cell-overlay" style="--merged-width: 200px; --merged-height: 50px;" contenteditable="true"></div>
                    </td>
                    <td contenteditable="true" data-merge-id="rehat_tbl1_col4_row2" class="subsumed-cell"></td>
                    <td contenteditable="true"></td><td contenteditable="true"></td>
                </tr>
            </tbody>
        </table>
    </div>

    <div id="nameModal" class="modal">
        <div class="modal-content" id="nameModalContent">
            <div class="modal-header" id="nameModalHeader">
                <h3 id="nameModalTitle">Shared Name List Manager</h3>
                <button type="button" class="modal-close-btn" id="closeNameModalBtnStandard" title="Close name manager">√ó</button>
            </div>
            <div class="name-session-tabs">
                <button id="namePagiTab" data-session="pagi" class="active">Pagi (Morning)</button>
                <button id="namePetangTab" data-session="petang">Petang (Afternoon)</button>
            </div>
             <div class="input-group">
                <input id="newNameInput" placeholder="Add new name to current shared session">
                <button id="addNameBtnInModal" title="Add the name to the shared list">Add</button>
             </div>
            <button id="importNameListBtn" title="Import names from a .txt file (one name per line) to current shared session">üìÇ Import Names (.txt) to Shared Session</button>
            <input type="file" id="nameListImportFile" accept=".txt" style="display:none;">
            <input type="text" id="searchNameInput" placeholder="üîç Search names in current shared session..." title="Filter the list of names">
            <div id="nameList"></div>
            <div id="loadingIndicatorModal" style="display:none;"><div class="spinner"></div></div>
        </div>
    </div>

    <h3 style="margin-top:32px">Teacher/Subject Attendance Summary</h3>
    <div id="summaryTableContainer">
        <table id="summaryTable"></table>
    </div>
    <div id="customMessageBox" class="custom-message-box"></div>
    <div id="generalLoadingIndicator" style="display:none;"><div class="spinner"></div></div>
</div>

<div id="pdfContent"></div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, setDoc, onSnapshot, collection, addDoc, getDocs, getDoc, deleteDoc, updateDoc, query, serverTimestamp, orderBy, where, limit } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // --- User-provided Firebase Config (Fallback) ---
    const userProvidedFirebaseConfig = {
      apiKey: "AIzaSyBgvyb95-jujtCC2HPiHXLdYMJgQquIEx4",
      authDomain: "jadual-3f0aa.firebaseapp.com",
      projectId: "jadual-3f0aa",
      storageBucket: "jadual-3f0aa.firebasestorage.app",
      messagingSenderId: "496526436851",
      appId: "1:496526436851:web:78ff48b28bfc8c31f14a86"
    };

    // --- Firebase Initialization ---
    let firebaseConfig;
    if (typeof __firebase_config !== 'undefined' && __firebase_config !== null && __firebase_config.trim() !== '') {
        try {
            firebaseConfig = JSON.parse(__firebase_config);
            console.log("Using injected Firebase config (__firebase_config).");
        } catch (e) {
            console.error("Error parsing injected __firebase_config. Falling back. Error:", e);
            firebaseConfig = userProvidedFirebaseConfig;
        }
    } else {
        firebaseConfig = userProvidedFirebaseConfig;
        console.log("Using Firebase config defined in the script.");
    }
    
    if (firebaseConfig.apiKey === "AIzaSyEXAMPLE-API-KEYdQquIEx4" || firebaseConfig.apiKey === "YOUR_API_KEY" || firebaseConfig.apiKey.includes("AIzaSyBgvyb95-jujtCC2HPiHXLdYMJgQquIEx4")) {
        console.warn("Firebase Auth: Update Firebase API Key if you see this in production.");
    }
    
    const appId = typeof __app_id !== 'undefined' ? __app_id : (firebaseConfig.appId || 'default-shared-scheduler-app');
    if (typeof __app_id === 'undefined') {
        console.warn("Firebase Auth: __app_id is not defined. Using App ID from Firebase config or default.");
    }

    let fbApp, fbAuth, fbDb;
    let fbUserId = null;
    let fbIsAuthReady = false;
    let unsubscribePagiShared = null;
    let unsubscribePetangShared = null;

    try {
        fbApp = initializeApp(firebaseConfig);
        fbAuth = getAuth(fbApp);
        fbDb = getFirestore(fbApp);
        console.log("Firebase services initialized for Shared Scheduler with Project ID:", firebaseConfig.projectId);
    } catch (e) {
        console.error("CRITICAL Error initializing Firebase services:", e);
        const userIdDisplayInitError = document.getElementById('userIdDisplay');
        if (userIdDisplayInitError) userIdDisplayInitError.textContent = "User ID: Firebase Init Error!";
    }

    // --- Global Variables & Constants ---
    const SCHEDULE_TITLE_KEY = `shared_jadual_title_${appId}`;
    const LAST_ACTIVE_SCHEDULE_ID_KEY = `last_active_schedule_id_${appId}`;
    
    let activeTableId = 'tbl_1';
    let tableCount = 1;
    let selectionMode = false;
    let selectedCells = [];
    let lastClickedCell = null;
    let selectedNameFromList = null;
    let currentNameListSession = 'pagi';
    let namesPagiShared = [];
    let namesPetangShared = [];
    let isDraggingModal = false;
    let modalDragOffsetX, modalDragOffsetY;
    let autocompleteSuggestionsDiv = null;
    let activeCellForAutocomplete = null;
    let currentAutocompleteIndex = -1;
    
    let currentWorkingScheduleDocId = null;
    let autoSaveIntervalId = null;
    const AUTO_SAVE_INTERVAL = 60000;
    let isAutoSaving = false;
    let lastSavedState = null;
    let isInitialStateSet = false;

    // --- DOM Element References (initialized in DOMContentLoaded) ---
    let scheduleTitleElement, tablesContainer, tableTabs, nameModal, nameModalContent, nameModalHeader,
        nameListContainer, newNameInput, sharedScheduleListContainerElement, summaryTableElement,
        summaryTableContainerElement, customMessageBox, fileInputElement, directCopyFullHtmlButtonElement,
        closeNameModalButtonStandardElement, nameListImportFileInputElement, searchNameInputElement,
        sharedScheduleImportFileInputElement, userIdDisplayElement, namePagiTabElement, namePetangTabElement,
        loadingIndicatorModalElement, nameModalTitleElement, generalLoadingIndicatorElement,
        controlsTogglerElement, collapsibleButtonBarsElement, downloadPdfButtonElement, pdfContentElement,
        clearAndResetScheduleBtnElement, manualSaveBtnElement, clearScheduledNamesBtnElement,
        restoreBackupBtnElement, restoreBackupModalElement, restoreBackupModalContentElement,
        restoreBackupModalHeaderElement, closeRestoreBackupModalBtnElement, restoreBackupListContainerElement,
        loadingIndicatorRestoreModalElement;

    // --- ALL FUNCTION DEFINITIONS START HERE ---

    // --- Utility Functions ---
    function showMessage(message, type = 'info', duration = 3000) {
        if (!customMessageBox) {
            customMessageBox = document.getElementById('customMessageBox');
            if (!customMessageBox) { console.warn("showMessage: customMessageBox not found. Msg:", message); return; }
        }
        customMessageBox.textContent = message;
        customMessageBox.className = `custom-message-box ${type}`;
        customMessageBox.style.display = 'block';
        setTimeout(() => { if (customMessageBox) customMessageBox.style.display = 'none'; }, duration);
    }

    function customPrompt(message, defaultValue = "") { return prompt(message, defaultValue); }

    function customConfirm(message) {
        return new Promise((resolve) => {
            const confirmModalId = 'customConfirmModal';
            let existingModal = document.getElementById(confirmModalId);
            if (existingModal) existingModal.remove();
            const modal = document.createElement('div');
            modal.id = confirmModalId;
            modal.style.cssText = `display: flex; position: fixed; z-index: 2001; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5); align-items: center; justify-content: center;`;
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `background-color: #fff; padding: 25px; border-radius: 8px; text-align: center; box-shadow: 0 5px 15px rgba(0,0,0,0.3); min-width: 300px; max-width: 90%;`;
            const messageP = document.createElement('p');
            messageP.textContent = message;
            messageP.style.marginBottom = '20px'; messageP.style.fontSize = '1.1em';
            const yesButton = document.createElement('button');
            yesButton.textContent = 'Yes';
            yesButton.style.cssText = `padding: 10px 20px; margin: 0 10px; border-radius: 5px; cursor: pointer; background-color: #28a745; color: white; border: none; font-size: 1em;`;
            const noButton = document.createElement('button');
            noButton.textContent = 'No';
            noButton.style.cssText = `padding: 10px 20px; margin: 0 10px; border-radius: 5px; cursor: pointer; background-color: #dc3545; color: white; border: none; font-size: 1em;`;
            const closeModal = (value) => { modal.remove(); resolve(value); };
            yesButton.onclick = () => closeModal(true);
            noButton.onclick = () => closeModal(false);
            modalContent.appendChild(messageP); modalContent.appendChild(yesButton); modalContent.appendChild(noButton);
            modal.appendChild(modalContent); document.body.appendChild(modal);
        });
    }
    
    function showGeneralLoading(isLoading) {
        if (generalLoadingIndicatorElement) generalLoadingIndicatorElement.style.display = isLoading ? 'flex' : 'none';
    }

    function toggleButtonBarsVisibility() {
        if (!collapsibleButtonBarsElement || !controlsTogglerElement) return;
        const isOpen = collapsibleButtonBarsElement.classList.toggle('open');
        controlsTogglerElement.setAttribute('aria-expanded', isOpen.toString());
        const textSpan = controlsTogglerElement.querySelector('span');
        if (textSpan) textSpan.textContent = isOpen ? 'Hide Controls' : 'Show Controls';
    }

    function showNameModalLoading(isLoading) {
        if (loadingIndicatorModalElement) loadingIndicatorModalElement.style.display = isLoading ? 'flex' : 'none';
    }
    function showRestoreBackupModalLoading(isLoading) {
        if (loadingIndicatorRestoreModalElement) loadingIndicatorRestoreModalElement.style.display = isLoading ? 'flex' : 'none';
    }
    
    function ensureDateHeaderRowExists(tableElement) {
        if (!tableElement || !tableElement.tHead) return;
        let numCols = 0;
        const timeSlotHeaderRow = Array.from(tableElement.tHead.rows).find(row => !row.classList.contains('date-header-row'));
        if (timeSlotHeaderRow) {
            numCols = timeSlotHeaderRow.cells.length;
        } else if (tableElement.rows.length > 0 && tableElement.rows[0].cells.length > 0) {
            const firstMeaningfulRow = Array.from(tableElement.rows).find(r => !r.classList.contains('date-header-row'));
            numCols = firstMeaningfulRow ? firstMeaningfulRow.cells.length : 1;
        } else {
            numCols = 1;
        }
        let dateRow = tableElement.tHead.querySelector('tr.date-header-row');
        if (!dateRow) {
            dateRow = document.createElement('tr');
            dateRow.className = 'date-header-row';
            for (let i = 0; i < numCols; i++) {
                const th = document.createElement('th');
                th.className = 'date-header-cell';
                th.contentEditable = 'true';
                dateRow.appendChild(th);
            }
            if (tableElement.tHead.firstChild) {
                tableElement.tHead.insertBefore(dateRow, tableElement.tHead.firstChild);
            } else {
                tableElement.tHead.appendChild(dateRow);
            }
        } else {
            const currentCellCount = dateRow.cells.length;
            if (currentCellCount < numCols) {
                for (let i = currentCellCount; i < numCols; i++) {
                    const th = document.createElement('th');
                    th.className = 'date-header-cell';
                    th.contentEditable = 'true';
                    dateRow.appendChild(th);
                }
            } else if (currentCellCount > numCols && numCols > 0) {
                for (let i = currentCellCount - 1; i >= numCols; i--) {
                    if(dateRow.cells[i]) dateRow.cells[i].remove();
                }
            }
        }
    }

    function captureCurrentState() {
        if (!tablesContainer || !scheduleTitleElement) {
            console.warn("captureCurrentState: Critical elements (tablesContainer or scheduleTitleElement) not found. Returning null.");
            return null;
        }
        const state = {
            html: tablesContainer.innerHTML,
            tableMeta: {},
            activeTableId: activeTableId,
            scheduleTitle: scheduleTitleElement.textContent || ''
        };
        Array.from(tablesContainer.querySelectorAll('table')).filter(t => t.dataset.independent !== 'true').forEach(table => {
            state.tableMeta[table.id] = {
                name: table.dataset.tableName || table.id,
                rowCount: table.rows.length,
                colCount: table.rows[0]?.cells.length || 0
            };
        });
        return JSON.stringify(state);
    }

    function hasStateChanged(currentStateStringified) {
        if (!isInitialStateSet || !lastSavedState) return true;
        if (!currentStateStringified) return false;
        return currentStateStringified !== lastSavedState;
    }

    function _updateLocalStateAfterSave(docId, scheduleName, isAutoDraft, operationType) {
        const capturedStateStringified = captureCurrentState();
        if (!capturedStateStringified) {
            console.error(`_updateLocalStateAfterSave (${operationType}): Failed to capture current state. Local state NOT updated.`);
        } else {
            lastSavedState = capturedStateStringified;
        }
        currentWorkingScheduleDocId = docId;
        if (docId) sessionStorage.setItem(LAST_ACTIVE_SCHEDULE_ID_KEY, docId);
        else sessionStorage.removeItem(LAST_ACTIVE_SCHEDULE_ID_KEY);
        const timestamp = new Date().toLocaleTimeString();
        console.log(`%cStateUpdate (${operationType}): ID: ${docId || 'N/A'}, Name: "${scheduleName || 'N/A'}", Draft: ${isAutoDraft}. lastSavedState updated. Time: ${timestamp}`, "color: blue; font-weight: bold;");
        if (operationType === "explicit-save" && scheduleName) showMessage(`Shared schedule "${scheduleName}" saved! (ID: ${docId})`, 'success');
        else if (operationType === "manual-save" && scheduleName) showMessage(`Page "${scheduleName + (isAutoDraft ? " (Draft)" : "")}" saved! (ID: ${docId})`, 'success');
        else if (operationType === "load" && scheduleName) showMessage(`Schedule "${scheduleName + (isAutoDraft ? " (Draft)" : "")}" loaded!`, 'success');
        else if (operationType === "restore-from-backup" && scheduleName) showMessage(`Backup "${scheduleName}" loaded into view. Save to make changes permanent.`, 'info', 5000);
    }

    // --- Summary Table Functions ---
    function getTextForSummary(cellText) {
        if (typeof cellText !== 'string') return ''; 
        let textForSummary = cellText.split(' // ')[0]; 
        const words = textForSummary.split(/\s+/); 
        const filteredWords = words.filter(word => !word.startsWith('*'));
        return filteredWords.join(' ').trim(); 
    }

    function parseTimeToMinutes(timeStr) {

// Helper to calculate full horizontal span of a merge group across the whole table
function getMergeGroupColumnRange(tableElement, mergeId) {
    let minIdx = Infinity, maxIdx = -1;
    if (!tableElement) return [0,0];
    tableElement.querySelectorAll(`[data-merge-id="${mergeId}"]`).forEach(cell => {
        if (cell.cellIndex < minIdx) minIdx = cell.cellIndex;
        if (cell.cellIndex > maxIdx) maxIdx = cell.cellIndex;
    });
    if (minIdx === Infinity || maxIdx === -1) {
        return [0,0];
    }
    return [minIdx, maxIdx];
}

        if (typeof timeStr !== 'string') return Infinity; 
        const match = timeStr.match(/^(\d{1,2})\s*[:.]\s*(\d{2})/);
        if (match) {
            return parseInt(match[1], 10) * 60 + parseInt(match[2], 10);
        }
        const hourMatch = timeStr.match(/^(\d{1,2})$/);
        if (hourMatch) {
            return parseInt(hourMatch[1], 10) * 60;
        }
        return Infinity; 
    }
    
    function normalizeHeaderForLookup(header) {
        if (typeof header !== 'string') return '';
        return header.replace(/\s/g, "").replace(/:/g,".").toLowerCase(); 
    }

    function buildSummaryTableSkeleton(allAvailableNames) {
        if (!summaryTableElement) { console.error("buildSummaryTableSkeleton: summaryTableElement not found."); return; }
        summaryTableElement.innerHTML = ''; 

        let allScheduleTableHeaders = new Set();
        if (tablesContainer) {
            Array.from(tablesContainer.querySelectorAll('table')).filter(t => t.dataset.independent !== 'true').forEach(scheduleTable => {
                if (!scheduleTable.tHead) return;
                const timeSlotHeaderRow = Array.from(scheduleTable.tHead.rows).find(row => !row.classList.contains('date-header-row'));
                if (timeSlotHeaderRow) {
                    for (let hIdx = 1; hIdx < timeSlotHeaderRow.cells.length; hIdx++) { 
                        const headerText = String(timeSlotHeaderRow.cells[hIdx].textContent || '').trim();
                        if (headerText) allScheduleTableHeaders.add(headerText);
                    }
                }
            });
        }

        let laulisahRuleRequiresSpecialSlot = false;
        const specialNamesForRule = ["LAU", "LISAH"];
        const targetSlotForSpecialNamesRule = "10.15-10.30";
        const sourceSlotForRule = "10.30-12.00";
        const normalizedSourceSlotForRule = normalizeHeaderForLookup(sourceSlotForRule);

        if (tablesContainer) {
            for (const scheduleTable of Array.from(tablesContainer.querySelectorAll('table')).filter(t => t.dataset.independent !== 'true')) {
                if (laulisahRuleRequiresSpecialSlot) break;
                if (!scheduleTable.tHead || !scheduleTable.tBodies[0]) continue;
                
                const timeSlotHeaderRow = Array.from(scheduleTable.tHead.rows).find(row => !row.classList.contains('date-header-row'));
                if (!timeSlotHeaderRow) continue;
                const currentScheduleTableHeaders = Array.from(timeSlotHeaderRow.cells).map(th => String(th.textContent||'').trim());

                Array.from(scheduleTable.tBodies[0].rows).forEach((scheduleDataRow) => {
                    if (laulisahRuleRequiresSpecialSlot) return;
                    for (let cellIdx = 1; cellIdx < scheduleDataRow.cells.length; cellIdx++) {
                         const scheduleCell = scheduleDataRow.cells[cellIdx];
                         let entryInScheduleCellFull = String(scheduleCell.querySelector('.merged-cell-overlay')?.textContent || scheduleCell.textContent||'').trim();
                         let entryInScheduleCellForRule = getTextForSummary(entryInScheduleCellFull); 
                         if (specialNamesForRule.some(specialName => entryInScheduleCellForRule.toUpperCase().includes(specialName))) { 
                            const headerText = currentScheduleTableHeaders[cellIdx];
                            if (headerText && normalizeHeaderForLookup(headerText) === normalizedSourceSlotForRule) {
                                laulisahRuleRequiresSpecialSlot = true; 
                                return; 
                            }
                         }
                    }
                });
            }
        }
        if (laulisahRuleRequiresSpecialSlot) {
            allScheduleTableHeaders.add(targetSlotForSpecialNamesRule);
        }
        
        let sortedUniqueHeaders = Array.from(allScheduleTableHeaders).sort((a, b) => {
            const timeA = parseTimeToMinutes(a);
            const timeB = parseTimeToMinutes(b);
            if (timeA !== Infinity && timeB !== Infinity) return timeA - timeB;
            if (timeA !== Infinity) return -1; 
            if (timeB !== Infinity) return 1;
            return String(a).localeCompare(String(b)); 
        });

        const finalSummaryColumnHeaders = ['Nama/Masa', ...sortedUniqueHeaders];
        const thead = summaryTableElement.createTHead(); 
        const headerRowForSummary = thead.insertRow();
        finalSummaryColumnHeaders.forEach(headerText => { 
            const th = document.createElement('th'); 
            th.textContent = headerText; 
            headerRowForSummary.appendChild(th); 
        });
        
        const tbody = summaryTableElement.createTBody();
        if (allAvailableNames.length === 0 && sortedUniqueHeaders.length === 0) { 
            const tr = tbody.insertRow(); const td = tr.insertCell(); 
            td.textContent = "No names scheduled and no time slots defined."; 
            td.colSpan = finalSummaryColumnHeaders.length || 1; 
            td.style.textAlign = 'center'; td.style.fontStyle = 'italic'; 
        } else if (allAvailableNames.length === 0) { 
            const tr = tbody.insertRow(); const td = tr.insertCell(); 
            td.textContent = "No names found in any schedule."; 
            td.colSpan = finalSummaryColumnHeaders.length || 1; 
            td.style.textAlign = 'center'; td.style.fontStyle = 'italic'; 
        } else { 
            allAvailableNames.forEach(name => { 
                const tr = tbody.insertRow(); 
                tr.insertCell().textContent = String(name || ''); 
                for (let i = 1; i < finalSummaryColumnHeaders.length; i++) {
                    tr.insertCell().textContent = ''; 
                }
            }); 
        }
    }
    
    function processNameBlockForSummary(summaryRow, name, blockData, normalizedSummaryHeaders) {
        if (!summaryRow || !blockData || blockData.length === 0 || !normalizedSummaryHeaders) return;
    
        let firstOriginalHeader = blockData[0].header;
        let lastOriginalHeader = blockData[blockData.length - 1].header; 
        const classIdentifiersInBlock = [...new Set(blockData.map(b => b.classId))].sort().join(', ');
    
        const specialNamesForRule = ["LAU", "LISAH"];
        const targetSlotForSpecialNamesRule = "10.15-10.30";
        const sourceSlotForRule = "10.30-12.00";
    
        const isLauLisahSourceBlock = specialNamesForRule.some(sn => name.toUpperCase() === sn) &&
                                   normalizeHeaderForLookup(firstOriginalHeader) === normalizeHeaderForLookup(sourceSlotForRule) &&
                                   normalizeHeaderForLookup(lastOriginalHeader) === normalizeHeaderForLookup(sourceSlotForRule);
    
        if (isLauLisahSourceBlock) {
            firstOriginalHeader = targetSlotForSpecialNamesRule;
            lastOriginalHeader = targetSlotForSpecialNamesRule;
        }
    
        const summaryStartColIdx = normalizedSummaryHeaders.indexOf(normalizeHeaderForLookup(firstOriginalHeader));
        const summaryEndColIdx = normalizedSummaryHeaders.indexOf(normalizeHeaderForLookup(lastOriginalHeader));
    
        if (summaryStartColIdx > 0 && summaryEndColIdx >= summaryStartColIdx) { // summaryStartColIdx > 0 to skip name column
            const summaryCellToUpdate = summaryRow.cells[summaryStartColIdx];
            if (!summaryCellToUpdate) return;
    
            let tempClasses = summaryCellToUpdate.dataset.tempClasses ? summaryCellToUpdate.dataset.tempClasses.split(',') : [];
            classIdentifiersInBlock.split(',').forEach(cls => {
                const trimmedCls = cls.trim();
                if (trimmedCls && !tempClasses.includes(trimmedCls)) { 
                    tempClasses.push(trimmedCls);
                }
            });
            summaryCellToUpdate.dataset.tempClasses = tempClasses.filter(tc => tc).sort().join(','); 
            
            const colspanRequired = summaryEndColIdx - summaryStartColIdx + 1;
            if (colspanRequired > 0) {
                const currentSummaryColspan = parseInt(summaryCellToUpdate.getAttribute('colspan') || '1');
                if (colspanRequired > currentSummaryColspan) { 
                    summaryCellToUpdate.colSpan = colspanRequired;
                }
            }
        }
    }

    
function updateSummaryTableData(allAvailableNames) {
    if (!summaryTableElement?.tBodies?.[0] || !summaryTableElement.tHead?.rows?.[0]) return;
    const summaryBody = summaryTableElement.tBodies[0];
    const summaryHeaders = Array.from(summaryTableElement.tHead.rows[0].cells).map(th => String(th.textContent||'').trim());
    const normalizedSummaryHeaders = summaryHeaders.map(normalizeHeaderForLookup);

    // Clear previous summary cell content and spans
    Array.from(summaryBody.rows).forEach(row => {
        for (let i = 1; i < row.cells.length; i++) {
            row.cells[i].textContent = '';
            row.cells[i].removeAttribute('colspan');
            row.cells[i].style.display = '';
        }
    });

    allAvailableNames.forEach(name => {
        const targetSummaryRow = Array.from(summaryBody.rows).find(r => r.cells[0]?.textContent === name);
        if (!targetSummaryRow) return;

        // Find all merged blocks for this name in ALL schedule tables
        let mergeBlocks = []; // [{startCol, endCol}]
        Array.from(tablesContainer.querySelectorAll('table')).filter(t => t.dataset.independent !== 'true').forEach(scheduleTable => {
            if (!scheduleTable.tHead || !scheduleTable.tBodies[0]) return;
            const timeSlotHeaderRow = Array.from(scheduleTable.tHead.rows).find(row => !row.classList.contains('date-header-row'));
            if (!timeSlotHeaderRow) return;
            const headers = Array.from(timeSlotHeaderRow.cells).map(th => String(th.textContent||'').trim());

            scheduleTable.tBodies[0].querySelectorAll('tr').forEach(scheduleDataRow => {
                let colIdx = 1;
                while (colIdx < scheduleDataRow.cells.length) {
                    const cell = scheduleDataRow.cells[colIdx];
                    if (!cell) { colIdx++; continue; }
                    const mergeId = cell.dataset.mergeId;
                    let colspan = 1, text = cell.querySelector('.merged-cell-overlay')?.textContent || cell.textContent;
                    let startCol = colIdx, endCol = colIdx;
                    if (mergeId && cell.classList.contains('merged-cell-container')) {
                        let minIdx = colIdx, maxIdx = colIdx;
                        scheduleDataRow.querySelectorAll(`td[data-merge-id="${mergeId}"]`).forEach(mergeCell => {
                            minIdx = Math.min(minIdx, mergeCell.cellIndex);
                            maxIdx = Math.max(maxIdx, mergeCell.cellIndex);
                        });
                        colspan = maxIdx - minIdx + 1;
                        startCol = minIdx; endCol = maxIdx;
                        colIdx = maxIdx + 1;
                    } else if (cell.classList.contains('subsumed-cell')) {
                        colIdx++;
                        continue;
                    } else {
                        colIdx++;
                    }
                    if (getTextForSummary(text).toUpperCase().includes(name.toUpperCase())) {
                        const startHeader = headers[startCol] || '';
                        const endHeader = headers[endCol] || startHeader;
                        const summaryStart = normalizedSummaryHeaders.indexOf(normalizeHeaderForLookup(startHeader));
                        const summaryEnd = normalizedSummaryHeaders.indexOf(normalizeHeaderForLookup(endHeader));
                        if (summaryStart > 0 && summaryEnd >= summaryStart) {
                            mergeBlocks.push({
                                start: summaryStart,
                                end: summaryEnd
                            });
                        }
                    }
                }
            });
        });

        // Merge adjacent/overlapping blocks
        mergeBlocks.sort((a,b)=>a.start-b.start);
        let merged = [];
        for(let block of mergeBlocks){
            if(!merged.length) { merged.push(block); continue; }
            let last = merged[merged.length-1];
            if(block.start <= last.end+1){ last.end = Math.max(last.end, block.end); }
            else merged.push(block);
        }

        // Set the summary row cells to reflect merged blocks
        let col = 1;
        for (let i = 0; i < merged.length; i++) {
            const block = merged[i];
            if (block.start >= targetSummaryRow.cells.length) continue;
            let cell = targetSummaryRow.cells[block.start];
            if(!cell) continue;
            cell.textContent = '*';
            if(block.end > block.start){
                cell.colSpan = block.end-block.start+1;
                for(let hide = block.start+1; hide <= block.end; hide++){
                    if(targetSummaryRow.cells[block.start+1])
                        targetSummaryRow.cells[block.start+1].style.display='none';
                }
            }
            col = block.end + 1;
        }
    });
}



    async function promptAndRenameActiveTable() {
        if (!tableTabs) return;
        const currentTab = tableTabs.querySelector('button.active');
        if (!currentTab) { showMessage('No active table to rename.', 'error'); return; }
        let tableIdToRename = currentTab.dataset.tableId;
        if (!tableIdToRename) { const match = currentTab.getAttribute('onclick')?.match(/'(tbl_.*?)'/); if (match && match[1]) tableIdToRename = match[1]; else { showMessage('Could not identify table ID.', 'error'); return; }}
        
        const tableElement = document.getElementById(tableIdToRename);
        if (!tableElement) { showMessage(`Table element for ID '${tableIdToRename}' not found.`, 'error'); return; }
        
        const oldName = tableElement.dataset.tableName || currentTab.textContent;
        const newName = customPrompt('Enter new table name:', oldName);
        
        if (newName && newName.trim() && newName.trim() !== oldName) {
            const trimmedNewName = newName.trim(); 
            currentTab.textContent = trimmedNewName; 
            currentTab.title = `Switch to table: ${trimmedNewName}`; 
            tableElement.dataset.tableName = trimmedNewName; 
            showMessage(`Table renamed to "${trimmedNewName}".`, 'success');
            rebuildAndRenderSummary(); 
        } else if (newName && newName.trim() === oldName) {
            showMessage('Name unchanged.', 'info');
        } else if (newName === null) { 
            showMessage('Rename cancelled.', 'info');
        } else { 
            showMessage('Invalid new name (cannot be empty).', 'error');
        }
    }
    async function confirmAndDeleteActiveTable() {
        if (!tablesContainer || !tableTabs || tablesContainer.children.length <= 1) { showMessage('Cannot delete the last table.', 'error'); return; }
        const activeTab = tableTabs.querySelector('button.active');
        const tableIdToDelete = activeTab?.dataset.tableId;
        const tableElement = tableIdToDelete ? document.getElementById(tableIdToDelete) : null;
        const tableName = tableElement?.dataset.tableName || activeTab?.textContent || 'the active table';
        
        if (await customConfirm(`Delete table "${tableName}"? This action cannot be undone.`)) {
            if (tableElement) tableElement.remove();
            else if (document.getElementById(activeTableId)) document.getElementById(activeTableId).remove(); 
            
            activeTab?.remove();
            
            const firstRemainingTab = tableTabs.querySelector('button');
            if (firstRemainingTab) { 
                const nextActiveId = firstRemainingTab.dataset.tableId || firstRemainingTab.getAttribute('onclick').match(/'(tbl_.*?)'/)[1]; 
                switchTable(nextActiveId); 
            } else { 
                activeTableId = null; 
                addNewTable(true); 
            }
            showMessage(`Table "${tableName}" deleted.`, 'success');
            rebuildAndRenderSummary(); 
        }
    }

    function addRowToTable(tableBody, rowIndex, numCols) {
        const row = tableBody.insertRow(rowIndex); 
        for (let i = 0; i < numCols; i++) { const cell = row.insertCell(); cell.contentEditable = 'true'; }
        return row;
    }
    function addRowAboveToActiveTable() {
        const table = document.getElementById(activeTableId); if (!table || !table.tBodies[0] || table.rows.length === 0) return;
        const timeSlotHeaderRow = Array.from(table.tHead.rows).find(r => !r.classList.contains('date-header-row'));
        const numCols = timeSlotHeaderRow ? timeSlotHeaderRow.cells.length : (table.rows[0]?.cells.length || 1);
        let insertAtIndex = (lastClickedCell && lastClickedCell.closest('tbody') && lastClickedCell.parentElement.rowIndex >= 0) ? lastClickedCell.parentElement.rowIndex : 0;
        addRowToTable(table.tBodies[0], insertAtIndex, numCols);
        rebuildAndRenderSummary(); updateAllMergeOverlays();
    }
    function addRowBelowToActiveTable() {
        const table = document.getElementById(activeTableId); if (!table || !table.tBodies[0] || table.rows.length === 0) return;
        const timeSlotHeaderRow = Array.from(table.tHead.rows).find(r => !r.classList.contains('date-header-row'));
        const numCols = timeSlotHeaderRow ? timeSlotHeaderRow.cells.length : (table.rows[0]?.cells.length || 1);
        let insertAtIndex = (lastClickedCell && lastClickedCell.closest('tbody') && lastClickedCell.parentElement.rowIndex >= 0) ? lastClickedCell.parentElement.rowIndex + 1 : -1;
        addRowToTable(table.tBodies[0], insertAtIndex, numCols);
        rebuildAndRenderSummary(); updateAllMergeOverlays();
    }
    function addColumnToTable(table, colIndex) { 
        for (const row of table.rows) {
            const isDateHeaderRow = row.classList.contains('date-header-row');
            const isTimeSlotHeaderRow = row.parentElement.tagName === 'THEAD' && !isDateHeaderRow;
            let cell;

            if (isDateHeaderRow) {
                cell = document.createElement('th');
                cell.className = 'date-header-cell';
            } else if (isTimeSlotHeaderRow) {
                cell = document.createElement('th');
                if (colIndex === -1 || colIndex >= row.cells.length) cell.textContent = "New Slot"; 
            } else { 
                cell = document.createElement('td');
            }
            cell.contentEditable = 'true';

            if (colIndex === -1 || colIndex >= row.cells.length) { 
                row.appendChild(cell);
            } else { 
                row.insertBefore(cell, row.cells[colIndex]);
            }
        }
    }
    function addColumnLeftToActiveTable() {
        const table = document.getElementById(activeTableId); if (!table) return;
        let insertAtIndex = (lastClickedCell && lastClickedCell.cellIndex >= 0) ? lastClickedCell.cellIndex : 0;
        addColumnToTable(table, insertAtIndex);
        ensureDateHeaderRowExists(table); 
        rebuildAndRenderSummary(); updateAllMergeOverlays();
    }
    function addColumnRightToActiveTable() {
        const table = document.getElementById(activeTableId); if (!table) return;
        let insertAtIndex = (lastClickedCell && lastClickedCell.cellIndex >= 0) ? lastClickedCell.cellIndex + 1 : -1;
        addColumnToTable(table, insertAtIndex);
        ensureDateHeaderRowExists(table); 
        rebuildAndRenderSummary(); updateAllMergeOverlays();
    }
    async function deleteClickedRowFromActiveTable() {
        if (!lastClickedCell) { showMessage('Click cell in row to delete.', 'info'); return; }
        const table = document.getElementById(activeTableId); if (!table || !table.tBodies[0]) { showMessage('No active table body.', 'error'); return; }
        const rowToDelete = lastClickedCell.closest('tr');
        if (!rowToDelete || rowToDelete.parentElement.tagName !== 'TBODY') { showMessage('Cannot delete header. Click data row.', 'error'); return; }
        if (table.tBodies[0].rows.length <= 1) { showMessage('Cannot delete last data row.', 'error'); return; }
        if (await customConfirm('Delete this row?')) {
            rowToDelete.remove(); lastClickedCell = null; deselectAllTableCells();
            rebuildAndRenderSummary(); updateAllMergeOverlays(); showMessage('Row deleted.', 'success');
        }
    }
    async function deleteClickedColumnFromActiveTable() {
        if (!lastClickedCell) { showMessage('Click cell in column to delete.', 'info'); return; }
        const table = document.getElementById(activeTableId); if (!table) { showMessage('No active table.', 'error'); return; }
        const timeSlotHeaderRow = Array.from(table.tHead.rows).find(r => !r.classList.contains('date-header-row'));
        if (timeSlotHeaderRow && timeSlotHeaderRow.cells.length <= 1) {
            showMessage('Cannot delete the last column.', 'error'); return;
        } else if (!timeSlotHeaderRow && table.rows[0]?.cells.length <=1) {
             showMessage('Cannot delete the last column.', 'error'); return;
        }
        const colIndexToDelete = lastClickedCell.cellIndex;
        if (await customConfirm('Delete this column?')) {
            for (const row of table.rows) {
                if (row.cells[colIndexToDelete]) row.cells[colIndexToDelete].remove();
            }
            lastClickedCell = null; deselectAllTableCells();
            ensureDateHeaderRowExists(table); 
            rebuildAndRenderSummary(); updateAllMergeOverlays(); showMessage('Column deleted.', 'success');
        }
    }

    async function clearScheduledNamesFromActiveTable() {
        const activeTableElement = document.getElementById(activeTableId);
        if (!activeTableElement) {
            showMessage('No active table selected to clear names from.', 'error');
            return;
        }

        const activeTableName = activeTableElement.dataset.tableName || activeTableId;
        if (!await customConfirm(`Are you sure you want to clear scheduled names from table "${activeTableName}"? Merged cells will be retained. This cannot be undone for other cells.`)) {
            showMessage('Operation cancelled.', 'info');
            return;
        }

        showGeneralLoading(true);
        try {
            const allSharedNamesLowerCase = new Set([...namesPagiShared.map(n => String(n).toLowerCase()), ...namesPetangShared.map(n => String(n).toLowerCase())]);
            activeTableElement.querySelectorAll('tbody td, tbody th').forEach(cellElement => {
                if (cellElement.hasAttribute('data-merge-id')) { return; }
                let originalText = String(cellElement.textContent || '');
                const parts = originalText.split(' // ');
                let mainContent = parts[0];
                const remarkContent = parts.length > 1 ? ' // ' + parts.slice(1).join(' // ') : '';
                const wordsInMain = mainContent.split(/\s+/).filter(w => w.length > 0);
                const keptMainWords = wordsInMain.filter(word => word.startsWith('*') || !allSharedNamesLowerCase.has(word.toLowerCase()));
                const newMainContent = keptMainWords.join(' ');
                let finalText = (newMainContent.trim() + remarkContent).trim();
                if (finalText === "//" && newMainContent.trim() === "") { finalText = ""; }
                cellElement.textContent = finalText;
            });
            rebuildAndRenderSummary();
            showMessage(`Scheduled names cleared from table "${activeTableName}" (merged cells retained).`, 'success');
        } catch (error) {
            console.error(`Error clearing names from table "${activeTableName}":`, error);
            showMessage(`Error clearing names: ${error.message}`, 'error');
        } finally {
            showGeneralLoading(false);
        }
    }

    function toggleCellSelectionMode() {
        selectionMode = !selectionMode; const btn = document.getElementById('selectBtn');
        if(btn) { btn.classList.toggle('active', selectionMode); btn.textContent = selectionMode ? '‚ú® Selecting...' : '‚ú® Select Cells'; }
        if (!selectionMode) deselectAllTableCells(); hideCellAutocompleteSuggestions();
    }
    function handleTableCellClick(event) {
        const cell = event.target.closest('td, th'); if (!cell || !cell.closest(`#${activeTableId}`)) return;
        lastClickedCell = cell;
        if (autocompleteSuggestionsDiv?.style.display === 'block' && !autocompleteSuggestionsDiv.contains(event.target) && activeCellForAutocomplete !== cell) hideCellAutocompleteSuggestions();
        if (selectedNameFromList) {
            if (cell.tagName === 'TD' || (cell.tagName === 'TH' && cell.closest('tbody'))) {
                const overlay = cell.querySelector('.merged-cell-overlay'); const contentNode = overlay || cell;
                const currentCellText = contentNode.textContent; const remarkPart = currentCellText.includes(' // ') ? currentCellText.substring(currentCellText.indexOf(' // ')) : '';
                const contentBeforeRemark = currentCellText.split(' // ')[0]; const starWords = contentBeforeRemark.split(/\s+/).filter(w => w.startsWith('*')).join(' ');
                let newText = selectedNameFromList; if (starWords) newText += ' ' + starWords;
                newText = (newText.trim() + remarkPart).trim(); contentNode.textContent = newText;
                rebuildAndRenderSummary(); showMessage(`Inserted "${selectedNameFromList}".`, 'success', 2500); clearNameSelection();
            } else showMessage('Click editable data cell to insert.', 'info');
            return;
        }
        if (selectionMode) {
            if (cell.classList.contains('subsumed-cell') || (cell.classList.contains('merged-cell-container') && selectedCells.some(sc => sc !== cell && sc.dataset.mergeId !== cell.dataset.mergeId))) { showMessage('Cannot select subsumed or mix merge groups.', 'warning'); return; }
            cell.classList.toggle('selected');
            if (cell.classList.contains('selected')) selectedCells.push(cell); else selectedCells = selectedCells.filter(c => c !== cell);
        }
    }
    function deselectAllTableCells() {
        selectedCells.forEach(c => c.classList.remove('selected')); selectedCells = [];
    }
    function mergeSelectedTableCells() {
        if (selectedCells.length < 2) { showMessage('Select at least two cells.', 'error'); return; }
        if (selectedCells.some(cell => cell.dataset.mergeId)) { showMessage('Cannot merge already merged cells.', 'warning'); return; }
        let primaryCell = selectedCells[0]; let minRowGUI = primaryCell.parentElement.getBoundingClientRect().top; let minColGUI = primaryCell.getBoundingClientRect().left;
        selectedCells.forEach(cell => { const cellRowRect = cell.parentElement.getBoundingClientRect(); const cellRect = cell.getBoundingClientRect(); if (cellRowRect.top < minRowGUI || (cellRowRect.top === minRowGUI && cellRect.left < minColGUI)) { primaryCell = cell; minRowGUI = cellRowRect.top; minColGUI = cellRect.left; } });
        let minLeft = Infinity, maxRight = -Infinity, minTop = Infinity, maxBottom = -Infinity;
        selectedCells.forEach(cell => { const rect = cell.getBoundingClientRect(); minLeft = Math.min(minLeft, rect.left); maxRight = Math.max(maxRight, rect.right); minTop = Math.min(minTop, rect.top); maxBottom = Math.max(maxBottom, rect.bottom); });
        const totalWidth = maxRight - minLeft; const totalHeight = maxBottom - minTop;
        const mergeId = `merge-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const overlay = document.createElement('div'); overlay.className = 'merged-cell-overlay';
        overlay.textContent = primaryCell.textContent; overlay.contentEditable = 'true';
        overlay.style.setProperty('--merged-width', `${totalWidth}px`); overlay.style.setProperty('--merged-height', `${totalHeight}px`);
        overlay.addEventListener('blur', () => rebuildAndRenderSummary());
        overlay.addEventListener('input', (e) => {
            const text = e.target.textContent; const parentCellForOverlay = e.target.parentElement;
            if (parentCellForOverlay && (parentCellForOverlay.cellIndex > 0 || parentCellForOverlay.closest('table')?.querySelector('thead tr:not(.date-header-row) th:first-child')?.textContent?.toLowerCase() !== 'class') && !parentCellForOverlay.classList.contains('date-header-cell')) showCellAutocompleteSuggestions(parentCellForOverlay, text); else hideCellAutocompleteSuggestions();
        });
        primaryCell.innerHTML = ''; primaryCell.appendChild(overlay);
        primaryCell.classList.add('merged-cell-container'); primaryCell.setAttribute('data-merge-id', mergeId);
        selectedCells.forEach(cell => { if (cell !== primaryCell) { cell.textContent = ''; cell.classList.add('subsumed-cell'); cell.setAttribute('data-merge-id', mergeId); } });
        deselectAllTableCells(); if (selectionMode) toggleCellSelectionMode();
        showMessage('Cells visually merged.', 'success');
    }
    function unmergeActiveCellIfMerged() {
        const cell = lastClickedCell; if (!cell) { showMessage('Click merged cell to unmerge.', 'info'); return; }
        const containerCell = cell.closest('[data-merge-id]'); if (!containerCell) { showMessage('Cell not part of a merge.', 'error'); return; }
        const mergeId = containerCell.dataset.mergeId; const table = containerCell.closest('table'); if (!table) return;
        const cellsInGroup = table.querySelectorAll(`[data-merge-id="${mergeId}"]`); let originalText = '';
        const primaryCellInGroup = Array.from(cellsInGroup).find(c => c.classList.contains('merged-cell-container'));
        if (primaryCellInGroup) { const overlay = primaryCellInGroup.querySelector('.merged-cell-overlay'); if (overlay) originalText = overlay.textContent; else originalText = primaryCellInGroup.textContent; }
        cellsInGroup.forEach(c => { c.removeAttribute('data-merge-id'); c.classList.remove('merged-cell-container', 'subsumed-cell'); const overlayChild = c.querySelector('.merged-cell-overlay'); if (overlayChild) overlayChild.remove(); c.innerHTML = ''; });
        if (primaryCellInGroup) primaryCellInGroup.textContent = originalText; else if (cellsInGroup.length > 0) cellsInGroup[0].textContent = originalText;
        rebuildAndRenderSummary(); showMessage('Cells unmerged.', 'success');
    }
    function updateAllMergeOverlays() {
        const activeTable = document.getElementById(activeTableId); if (!activeTable) return;
        const mergedContainers = activeTable.querySelectorAll('.merged-cell-container');
        mergedContainers.forEach(containerCell => {
            const mergeId = containerCell.dataset.mergeId; if (!mergeId) return;
            const overlay = containerCell.querySelector('.merged-cell-overlay'); if (!overlay) return;
            const cellsInGroup = Array.from(activeTable.querySelectorAll(`[data-merge-id="${mergeId}"]`)); if (cellsInGroup.length === 0) return;
            let minLeft = Infinity, maxRight = -Infinity, minTop = Infinity, maxBottom = -Infinity;
            cellsInGroup.forEach(cellInvolved => { const rect = cellInvolved.getBoundingClientRect(); minLeft = Math.min(minLeft, rect.left); maxRight = Math.max(maxRight, rect.right); minTop = Math.min(minTop, rect.top); maxBottom = Math.max(maxBottom, rect.bottom); });
            if (minLeft === Infinity) return;
            overlay.style.setProperty('--merged-width', `${maxRight - minLeft}px`); overlay.style.setProperty('--merged-height', `${maxBottom - minTop}px`);
        });
    }

    function handleNameListSessionSwitch(session) {
        currentNameListSession = session; if(namePagiTabElement) namePagiTabElement.classList.toggle('active', session === 'pagi'); if(namePetangTabElement) namePetangTabElement.classList.toggle('active', session === 'petang'); if(nameModalTitleElement) nameModalTitleElement.textContent = `Shared Name List Manager (${session === 'pagi' ? 'Pagi' : 'Petang'})`; if(searchNameInputElement) searchNameInputElement.value = ''; renderNameListFromFirestore(); hideCellAutocompleteSuggestions();
    }
    function highlightSelectedNameInList(nameToHighlight) {
        if (!nameListContainer) return; const nameToHighlightStr = String(nameToHighlight || '');
        nameListContainer.querySelectorAll('.name-item span').forEach(span => span.classList.toggle('highlighted', String(span.dataset.name || '') === nameToHighlightStr));
    }
    function clearNameSelection() {
        selectedNameFromList = null; if (nameListContainer) nameListContainer.querySelectorAll('.name-item span.highlighted').forEach(span => span.classList.remove('highlighted'));
    }
    function closeNameModal() {
        if (nameModal) nameModal.style.display = 'none'; clearNameSelection(); if(searchNameInputElement) searchNameInputElement.value = '';
    }
    function toggleNameListModalVisibility() {
        if (!nameModal || !nameModalContent || !newNameInput) return;
        const isDisplayed = nameModal.style.display === 'flex';
        if (isDisplayed) closeNameModal();
        else {
            nameModalContent.style.position = 'relative'; nameModalContent.style.left = 'auto'; nameModalContent.style.top = 'auto'; nameModalContent.style.transform = 'none';
            nameModal.style.display = 'flex'; if(searchNameInputElement) searchNameInputElement.value = '';
            handleNameListSessionSwitch(currentNameListSession); if(newNameInput) newNameInput.focus(); clearNameSelection();
        }
        hideCellAutocompleteSuggestions();
    }
    function renderNameListFromFirestore(filterText = '') {
        if (!nameListContainer) return; if (!fbIsAuthReady) { nameListContainer.innerHTML = '<p>Loading names...</p>'; return; }
        nameListContainer.innerHTML = ''; const namesToRender = currentNameListSession === 'pagi' ? namesPagiShared : namesPetangShared;
        const normalizedFilterText = String(filterText || '').toLowerCase().trim();
        if (!Array.isArray(namesToRender)) { nameListContainer.innerHTML = '<p>Error: Name list invalid.</p>'; return; }
        const filteredNames = namesToRender.filter(name => String(name || '').toLowerCase().trim().includes(normalizedFilterText));
        if (filteredNames.length === 0) { nameListContainer.innerHTML = `<p>${normalizedFilterText ? 'No names match.' : `No names in ${currentNameListSession} session.`}</p>`; return; }
        filteredNames.forEach(name => { const itemDiv = document.createElement('div'); itemDiv.className = 'name-item'; const nameStr = String(name || ''); const safeNameAttr = nameStr.replace(/"/g, '&quot;'); itemDiv.innerHTML = `<span data-name="${safeNameAttr}" title="Select '${safeNameAttr}'">${nameStr}</span><button data-name-delete="${safeNameAttr}" title="Delete '${safeNameAttr}'">Delete</button>`; nameListContainer.appendChild(itemDiv); });
        highlightSelectedNameInList(selectedNameFromList);
    }
    function selectNameForCellInsertion(name) {
        selectedNameFromList = String(name || ''); highlightSelectedNameInList(selectedNameFromList);
        showMessage(`Selected "${selectedNameFromList}". Click cell to insert.`, 'info', 4000);
    }
    function handleNameListImportFirestore(event) {
        const file = event.target.files[0]; if (!file) { showMessage('No file selected.', 'info'); return; }
        if (file.type !== 'text/plain') { showMessage('Invalid file type (.txt only).', 'error'); event.target.value = ''; return; }
        const reader = new FileReader();
        reader.onload = async (e) => {
            try {
                const importedNames = e.target.result.split(/\r?\n/).map(n => String(n||'').trim()).filter(n => n);
                if (importedNames.length === 0) { showMessage('No names in file.', 'info'); return; }
                const currentSessionNames = (currentNameListSession === 'pagi' ? namesPagiShared : namesPetangShared).map(n => String(n||'').trim());
                const combinedNames = [...new Set([...currentSessionNames, ...importedNames])];
                await saveSharedNameListToFirestore(currentNameListSession, combinedNames);
            } catch (error) { showMessage('Error processing name list file.', 'error'); }
            finally { event.target.value = ''; }
        };
        reader.onerror = () => { showMessage('Failed to read name list file.', 'error'); event.target.value = ''; };
        reader.readAsText(file);
    }

    function handleExcelFileImport(event) {
        const file = event.target.files[0]; if (!file || !tablesContainer) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const workbook = XLSX.read(new Uint8Array(e.target.result), { type: 'array' });
                const sheetName = workbook.SheetNames[0];
                const worksheet = workbook.Sheets[sheetName];
                const htmlTableString = XLSX.utils.sheet_to_html(worksheet, { raw: false });
                tableCount++;
                const newTableId = `tbl_imported_${Date.now()}_${tableCount}`;
                const importedTableName = file.name.replace(/\.xlsx?$/i, '') || `Imported ${tableCount}`;
                const tempDiv = document.createElement('div'); tempDiv.innerHTML = htmlTableString;
                const importedTableElement = tempDiv.querySelector('table');
                if (importedTableElement) {
                    importedTableElement.id = newTableId;
                    importedTableElement.dataset.tableName = importedTableName;
                    ensureDateHeaderRowExists(importedTableElement);
                    importedTableElement.querySelectorAll('td, th, .merged-cell-overlay').forEach(cell => cell.contentEditable = 'true');
                    tablesContainer.appendChild(importedTableElement);
                    addTabButton(newTableId, importedTableName);
                    switchTable(newTableId);
                    showMessage('Excel data imported!', 'success');
                } else showMessage('Could not parse table from Excel.', 'error');
            } catch (error) { showMessage('Error processing Excel file.', 'error'); console.error("Excel import error:", error); }
            finally { event.target.value = ''; }
        };
        reader.readAsArrayBuffer(file);
    }
    function exportActiveTableToExcel() {
        const tableToExport = document.getElementById(activeTableId); if (!tableToExport) { showMessage('No active table to export.', 'error'); return; }
        const overlaysData = [];
        tableToExport.querySelectorAll('.merged-cell-overlay').forEach(overlay => { const parentCell = overlay.parentElement; overlaysData.push({ parent: parentCell, originalHTML: parentCell.innerHTML }); parentCell.textContent = overlay.textContent; });
        const tableName = tableToExport.dataset.tableName || activeTableId;
        const wb = XLSX.utils.table_to_book(tableToExport, { sheet: tableName });
        XLSX.writeFile(wb, `${tableName}_${new Date().toISOString().split('T')[0]}.xlsx`);
        overlaysData.forEach(data => {
            data.parent.innerHTML = data.originalHTML;
            const newOverlay = data.parent.querySelector('.merged-cell-overlay');
            if (newOverlay) {
                newOverlay.addEventListener('blur', () => rebuildAndRenderSummary());
                newOverlay.addEventListener('input', (e) => { const text = e.target.textContent; const parentCellForOverlay = e.target.parentElement; if (parentCellForOverlay && (parentCellForOverlay.cellIndex > 0 || parentCellForOverlay.closest('table')?.querySelector('thead tr:not(.date-header-row) th:first-child')?.textContent?.toLowerCase() !== 'class') && !parentCellForOverlay.classList.contains('date-header-cell')) showCellAutocompleteSuggestions(parentCellForOverlay, text); else hideCellAutocompleteSuggestions(); });
            }
        });
        if(overlaysData.length > 0) updateAllMergeOverlays();
        showMessage(`Table "${tableName}" exported.`, 'success');
    }

    async function generateSchedulePdf() {
        if (!pdfContentElement || !tablesContainer || !scheduleTitleElement) { showMessage('PDF elements not found.', 'error'); return; }
        showGeneralLoading(true); showMessage('Generating PDF...', 'info', 15000);
        pdfContentElement.innerHTML = '';
        const tablesToPrint = Array.from(tablesContainer.querySelectorAll('table')).filter(t => t.dataset.independent !== 'true');
        const numTables = tablesToPrint.length;
        if (numTables === 0) {
            const pageWrapper = document.createElement('div'); pageWrapper.className = 'pdf-page-wrapper';
            const mainTitleText = scheduleTitleElement.textContent || 'Weekly Schedule';
            const mainTitleH2 = document.createElement('h2'); mainTitleH2.textContent = mainTitleText; pageWrapper.appendChild(mainTitleH2);
            const noTablesMessage = document.createElement('p'); noTablesMessage.textContent = "No tables available."; noTablesMessage.style.textAlign = "center"; pageWrapper.appendChild(noTablesMessage);
            const footnoteDiv = document.createElement('div'); footnoteDiv.className = 'pdf-footnote'; const today = new Date(); const dateOptions = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }; footnoteDiv.textContent = `Generated: ${today.toLocaleDateString(undefined, dateOptions)}`; pageWrapper.appendChild(footnoteDiv);
            pdfContentElement.appendChild(pageWrapper);
        } else {
            tablesToPrint.forEach((tableElement, index) => {
                const pageWrapper = document.createElement('div'); pageWrapper.className = 'pdf-page-wrapper';
                if (index === 0) { const mainTitleText = scheduleTitleElement.textContent || 'Weekly Schedule'; const mainTitleH2 = document.createElement('h2'); mainTitleH2.textContent = mainTitleText; pageWrapper.appendChild(mainTitleH2); }
                const tableId = tableElement.id; const tableName = tableElement.dataset.tableName || tableId || `Table ${index + 1}`;
                const tableTitleH3 = document.createElement('h3'); tableTitleH3.textContent = tableName; pageWrapper.appendChild(tableTitleH3);
                const clonedTable = cloneTableForPdf(tableElement);
                if (clonedTable) pageWrapper.appendChild(clonedTable); else { const errorMsg = document.createElement('p'); errorMsg.textContent = `Error: Table "${tableName}" could not be generated.`; pageWrapper.appendChild(errorMsg); }
                const footnoteDiv = document.createElement('div'); footnoteDiv.className = 'pdf-footnote'; const today = new Date(); const dateOptions = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }; footnoteDiv.textContent = `Generated: ${today.toLocaleDateString(undefined, dateOptions)}`; pageWrapper.appendChild(footnoteDiv);
                pdfContentElement.appendChild(pageWrapper);
            });
        }
        pdfContentElement.style.display = 'block';
        const pdfOptions = { margin: [5, 5, 5, 5], filename: `${(scheduleTitleElement.textContent || 'schedule').replace(/[^a-z0-9]/gi, '_').toLowerCase()}_complete.pdf`, image: { type: 'jpeg', quality: 0.95 }, html2canvas: { scale: 2, useCORS: true, logging: false, scrollX: 0, scrollY: -window.scrollY, windowWidth: pdfContentElement.scrollWidth, windowHeight: pdfContentElement.scrollHeight, removeContainer: true }, jsPDF: { unit: 'mm', format: 'a4', orientation: 'landscape' }, pagebreak: { mode: ['css', 'legacy'], before: '.pdf-page-wrapper:not(:first-child)', avoid: ['h2', 'h3', 'table', 'tr', 'thead', 'tbody', '.pdf-footnote'] } };
        try { await html2pdf().from(pdfContentElement).set(pdfOptions).save(); showMessage('PDF downloaded!', 'success'); }
        catch (error) { console.error('Error generating PDF:', error); showMessage(`PDF generation failed. Error: ${error.message}.`, 'error', 10000); }
        finally { pdfContentElement.style.display = 'none'; showGeneralLoading(false); }
    }
    function cloneTableForPdf(originalTable) {
        if (!originalTable || typeof originalTable.cloneNode !== 'function') { console.error("cloneTableForPdf Error: Invalid originalTable:", originalTable); return null; }
        const tableIdForLog = originalTable.id || 'Unknown ID';
        const clonedTable = originalTable.cloneNode(true); clonedTable.removeAttribute('id'); clonedTable.classList.remove('active'); clonedTable.style.width = '100%'; clonedTable.style.tableLayout = 'fixed';
        clonedTable.querySelectorAll('[contenteditable="true"]').forEach(el => el.removeAttribute('contenteditable'));
        const mergeGroups = {};
        Array.from(originalTable.rows).forEach((originalRow, rowIndex) => {
            Array.from(originalRow.cells).forEach((originalCell, colIndex) => {
                const mergeId = originalCell.dataset.mergeId; if (!mergeId) return;
                if (!mergeGroups[mergeId]) { mergeGroups[mergeId] = { minRow: rowIndex, maxRow: rowIndex, minCol: colIndex, maxCol: colIndex, primaryCellOriginal: null, allOriginalCellsInGroup: [] }; }
                const group = mergeGroups[mergeId]; group.allOriginalCellsInGroup.push(originalCell);
                group.minRow = Math.min(group.minRow, rowIndex); group.maxRow = Math.max(group.maxRow, rowIndex);
                group.minCol = Math.min(group.minCol, colIndex); group.maxCol = Math.max(group.maxCol, colIndex);
                if (originalCell.classList.contains('merged-cell-container')) group.primaryCellOriginal = originalCell;
            });
        });
        for (const mergeId in mergeGroups) {
            const group = mergeGroups[mergeId]; if (!group.primaryCellOriginal) { console.warn(`cloneTableForPdf (${tableIdForLog}): No primary cell for mergeId: ${mergeId}.`); continue; }
            const rowSpan = group.maxRow - group.minRow + 1; const colSpan = group.maxCol - group.minCol + 1;
            let primaryCellOriginalRowIndex = -1, primaryCellOriginalColIndex = -1;
            Array.from(originalTable.rows).forEach((r, rIdx) => Array.from(r.cells).forEach((c, cIdx) => { if (c === group.primaryCellOriginal) { primaryCellOriginalRowIndex = rIdx; primaryCellOriginalColIndex = cIdx; }}));
            if (primaryCellOriginalRowIndex === -1 || primaryCellOriginalColIndex === -1) { console.warn(`cloneTableForPdf (${tableIdForLog}): Could not find original primary cell's indices for mergeId ${mergeId}.`); continue; }
            const clonedPrimaryCell = clonedTable.rows[primaryCellOriginalRowIndex]?.cells[primaryCellOriginalColIndex];
            if (clonedPrimaryCell) {
                const overlayOriginal = group.primaryCellOriginal.querySelector('.merged-cell-overlay');
                clonedPrimaryCell.textContent = overlayOriginal ? overlayOriginal.textContent : group.primaryCellOriginal.textContent;
                const overlayCloned = clonedPrimaryCell.querySelector('.merged-cell-overlay'); if (overlayCloned) overlayCloned.remove();
                clonedPrimaryCell.classList.remove('merged-cell-container');
                if (rowSpan > 1) clonedPrimaryCell.rowSpan = rowSpan; if (colSpan > 1) clonedPrimaryCell.colSpan = colSpan;
                const cellsToRemoveFromClonedTable = [];
                group.allOriginalCellsInGroup.forEach(originalSubsumedCell => {
                    if (originalSubsumedCell === group.primaryCellOriginal) return;
                    let subsumedOriginalRowIndex = -1, subsumedOriginalColIndex = -1;
                     Array.from(originalTable.rows).forEach((r, rIdx) => Array.from(r.cells).forEach((c, cIdx) => { if (c === originalSubsumedCell) { subsumedOriginalRowIndex = rIdx; subsumedOriginalColIndex = cIdx; }}));
                    if (subsumedOriginalRowIndex !== -1 && subsumedOriginalColIndex !== -1) { const clonedSubsumedCell = clonedTable.rows[subsumedOriginalRowIndex]?.cells[subsumedOriginalColIndex]; if (clonedSubsumedCell && clonedSubsumedCell !== clonedPrimaryCell) cellsToRemoveFromClonedTable.push(clonedSubsumedCell); }
                });
                cellsToRemoveFromClonedTable.forEach(cell => cell.remove());
            } else console.warn(`cloneTableForPdf (${tableIdForLog}): Cloned primary cell not found for mergeId: ${mergeId}.`);
        }
        return clonedTable;
    }

    function loadScheduleTitleFromLocalStorage() {
        const savedTitle = localStorage.getItem(SCHEDULE_TITLE_KEY);
        if (savedTitle && scheduleTitleElement) scheduleTitleElement.textContent = savedTitle;
        if (scheduleTitleElement) scheduleTitleElement.addEventListener('blur', () => localStorage.setItem(SCHEDULE_TITLE_KEY, scheduleTitleElement.textContent));
    }
    
    function setupInitialTableState() {
        const existingTablesInDOM = Array.from(tablesContainer.querySelectorAll('table')).filter(t => t.dataset.independent !== 'true');
        
        if (existingTablesInDOM.length === 0) {
            console.warn("setupInitialTableState: tablesContainer was empty. Creating default table.");
            if (!document.getElementById('tbl_1')) {
                 addNewTable(true); 
            } else {
                activeTableId = 'tbl_1';
            }
        } else if (!tablesContainer.querySelector('table.active')) {
            activeTableId = existingTablesInDOM[0].id;
        } else {
            activeTableId = tablesContainer.querySelector('table.active').id;
        }

        tableTabs.innerHTML = ''; 
        const currentTablesForTabs = Array.from(tablesContainer.querySelectorAll('table')).filter(t => t.dataset.independent !== 'true'); 
        currentTablesForTabs.forEach((table, index) => {
            ensureDateHeaderRowExists(table); 
            const id = table.id || `tbl_dom_${Date.now()}_${index + 1}`; 
            if (!table.id) table.id = id;
            const name = table.dataset.tableName || `Sheet ${index + 1}`;
            table.dataset.tableName = name;
            addTabButton(id, name);
            table.querySelectorAll('td, th, .merged-cell-overlay').forEach(cell => cell.contentEditable = 'true');
        });

        if (activeTableId && document.getElementById(activeTableId)) {
            switchTable(activeTableId);
        } else if (currentTablesForTabs.length > 0) {
            switchTable(currentTablesForTabs[0].id);
        } else {
            console.error("setupInitialTableState: No tables found in DOM to activate after setup. This is problematic.");
            if (tablesContainer.children.length === 0) addNewTable(true);
        }
        tableCount = Math.max(1, currentTablesForTabs.length); 
        console.log(`setupInitialTableState: Final activeTableId is ${activeTableId}. tableCount is ${tableCount}.`);
    }

    function initializeEventListeners() {
        if(controlsTogglerElement) controlsTogglerElement.addEventListener('click', toggleButtonBarsVisibility);
        if(manualSaveBtnElement) manualSaveBtnElement.addEventListener('click', manualSaveCurrentPage);
        if(downloadPdfButtonElement) downloadPdfButtonElement.addEventListener('click', generateSchedulePdf);
        if(clearScheduledNamesBtnElement) clearScheduledNamesBtnElement.addEventListener('click', clearScheduledNamesFromActiveTable);
        if(directCopyFullHtmlButtonElement) directCopyFullHtmlButtonElement.addEventListener('click', attemptDirectCopyToClipboard);
        if(closeNameModalButtonStandardElement) closeNameModalButtonStandardElement.addEventListener('click', closeNameModal);
        if(nameModalHeader) { nameModalHeader.addEventListener('mousedown', (e) => startDragModal(e, nameModalContent)); nameModalHeader.addEventListener('touchstart', (e) => startDragModal(e, nameModalContent), { passive: false }); }
        document.addEventListener('mousemove', (e) => dragModal(e, document.querySelector('.modal-content.dragging')));
        document.addEventListener('mouseup', (e) => stopDragModal(e, document.querySelector('.modal-content.dragging')));
        document.addEventListener('touchmove', (e) => dragModal(e, document.querySelector('.modal-content.dragging')), { passive: false });
        document.addEventListener('touchend', (e) => stopDragModal(e, document.querySelector('.modal-content.dragging')));
        document.getElementById('excelBtnTrigger')?.addEventListener('click', exportActiveTableToExcel);
        document.getElementById('importExcelBtn')?.addEventListener('click', () => fileInputElement?.click());
        if(fileInputElement) fileInputElement.addEventListener('change', handleExcelFileImport);
        document.getElementById('saveSharedScheduleBtn')?.addEventListener('click', saveSharedScheduleToFirestore);
        document.getElementById('loadSharedScheduleBtn')?.addEventListener('click', loadAndRenderSharedSchedulesFromFirestore);
        document.getElementById('exportSharedSchedulesBtn')?.addEventListener('click', exportAllSharedSchedulesFromFirestore);
        document.getElementById('importSharedSchedulesBtn')?.addEventListener('click', () => sharedScheduleImportFileInputElement?.click());
        if(sharedScheduleImportFileInputElement) sharedScheduleImportFileInputElement.addEventListener('change', handleSharedSchedulesImport);
        if(sharedScheduleListContainerElement) sharedScheduleListContainerElement.addEventListener('click', async (e) => {
            const targetSpan = e.target.closest('.shared-schedule-item .schedule-item-main-line span[data-schedule-id]');
            const targetButton = e.target.closest('.shared-schedule-item .schedule-item-main-line button[data-schedule-id]');
            if (targetSpan) loadSelectedSharedScheduleFromFirestore(targetSpan.dataset.scheduleId);
            else if (targetButton) { const scheduleId = targetButton.dataset.scheduleId; const scheduleNameElement = targetButton.parentElement.querySelector('span[data-schedule-id]'); const scheduleName = scheduleNameElement ? scheduleNameElement.textContent.split(' (by')[0] : 'this schedule'; await confirmAndDeleteSharedScheduleFromFirestore(scheduleId, scheduleName); }
        });
        if(clearAndResetScheduleBtnElement) clearAndResetScheduleBtnElement.addEventListener('click', async () => {
            if (await customConfirm("Clear everything and start new schedule? This will affect the current view only and does not delete saved Cloud schedules or their backups.")) {
                tablesContainer.innerHTML = ''; tableTabs.innerHTML = ''; activeTableId = null;
                if (scheduleTitleElement) scheduleTitleElement.textContent = "Jadual Anjal"; 
                localStorage.removeItem(SCHEDULE_TITLE_KEY); 
                addNewTable(true); 
                _updateLocalStateAfterSave(null, "New Schedule (Reset)", false, "reset-all"); 
                rebuildAndRenderSummary(); showMessage('Content cleared. New schedule started.', 'success');
            }
        });
        document.getElementById('selectBtn')?.addEventListener('click', toggleCellSelectionMode);
        document.getElementById('mergeBtn')?.addEventListener('click', mergeSelectedTableCells);
        document.getElementById('deselectBtn')?.addEventListener('click', deselectAllTableCells);
        document.getElementById('unmergeBtn')?.addEventListener('click', unmergeActiveCellIfMerged);
        document.getElementById('addTableBtn')?.addEventListener('click', () => addNewTable());
        document.getElementById('addIndependentTableBtn')?.addEventListener('click', () => addNewIndependentTable());
        document.getElementById('renameTableBtn')?.addEventListener('click', promptAndRenameActiveTable);
        document.getElementById('deleteTableBtn')?.addEventListener('click', confirmAndDeleteActiveTable);
        document.getElementById('addRowAboveBtn')?.addEventListener('click', addRowAboveToActiveTable);
        document.getElementById('addRowBelowBtn')?.addEventListener('click', addRowBelowToActiveTable);
        document.getElementById('addColLeftBtn')?.addEventListener('click', addColumnLeftToActiveTable);
        document.getElementById('addColRightBtn')?.addEventListener('click', addColumnRightToActiveTable);
        document.getElementById('deleteRowBtn')?.addEventListener('click', deleteClickedRowFromActiveTable);
        document.getElementById('deleteColBtn')?.addEventListener('click', deleteClickedColumnFromActiveTable);
        document.getElementById('nameListBtn')?.addEventListener('click', toggleNameListModalVisibility);
        document.getElementById('addNameBtnInModal')?.addEventListener('click', () => { if(newNameInput) addNameToSharedSessionInFirestore(newNameInput.value); });
        document.getElementById('importNameListBtn')?.addEventListener('click', () => nameListImportFileInputElement?.click());
        if(nameListImportFileInputElement) nameListImportFileInputElement.addEventListener('change', handleNameListImportFirestore);
        if(searchNameInputElement) searchNameInputElement.addEventListener('input', (e) => renderNameListFromFirestore(e.target.value));
        if(namePagiTabElement) namePagiTabElement.addEventListener('click', () => handleNameListSessionSwitch('pagi'));
        if(namePetangTabElement) namePetangTabElement.addEventListener('click', () => handleNameListSessionSwitch('petang'));
        if(nameListContainer) nameListContainer.addEventListener('click', async (e) => {
            const nameItemSpan = e.target.closest('.name-item span[data-name]');
            const deleteButton = e.target.closest('.name-item button[data-name-delete]');
            if (nameItemSpan) selectNameForCellInsertion(nameItemSpan.dataset.name);
            else if (deleteButton) await deleteNameFromSharedSessionInFirestore(deleteButton.dataset.nameDelete);
        });
        if(tablesContainer) {
            tablesContainer.addEventListener('click', handleTableCellClick);
            tablesContainer.addEventListener('input', (e) => { 
                const cell = e.target; 
                const targetElement = cell.classList.contains('merged-cell-overlay') ? cell : (cell.closest('td, th'));
                
                if (targetElement && (targetElement.tagName === 'TD' || (targetElement.tagName === 'TH' && targetElement.closest('tbody')) || targetElement.classList.contains('date-header-cell') || cell.classList.contains('merged-cell-overlay')) && targetElement.isContentEditable !== false) {
                    const text = cell.textContent; 
                    const isTimeSlotHeaderCell = targetElement.tagName === 'TH' && targetElement.closest('thead tr:not(.date-header-row)');
                    const isFirstColumnClassHeader = targetElement.closest('table')?.querySelector('thead tr:not(.date-header-row) th:first-child')?.textContent?.toLowerCase() === 'class' && targetElement.cellIndex === 0 && !targetElement.classList.contains('date-header-cell');
                    
                    if (!isTimeSlotHeaderCell && !isFirstColumnClassHeader && !targetElement.classList.contains('date-header-cell')) {
                        showCellAutocompleteSuggestions(targetElement, text);
                    } else {
                        hideCellAutocompleteSuggestions();
                    }
                }
            });
            tablesContainer.addEventListener('blur', (e) => { 
                const cell = e.target; 
                const targetElement = cell.classList.contains('merged-cell-overlay') ? cell.parentElement : cell;
                if (targetElement && (targetElement.tagName === 'TD' || targetElement.tagName === 'TH' || cell.classList.contains('merged-cell-overlay')) && targetElement.isContentEditable !== false) {
                    setTimeout(rebuildAndRenderSummary, 0); 
                    setTimeout(() => { 
                        if (autocompleteSuggestionsDiv?.style.display === 'block' && 
                            !autocompleteSuggestionsDiv.contains(document.activeElement) && 
                            activeCellForAutocomplete !== document.activeElement && 
                            (!activeCellForAutocomplete || activeCellForAutocomplete.querySelector('.merged-cell-overlay') !== document.activeElement)) {
                            hideCellAutocompleteSuggestions(); 
                        }
                    }, 150);
                }
            }, true); 
        }
        window.addEventListener('resize', () => { updateAllMergeOverlays(); hideCellAutocompleteSuggestions(); });
        document.addEventListener('keydown', (e) => { 
            if (autocompleteSuggestionsDiv?.style.display === 'block' && activeCellForAutocomplete) {
                const items = autocompleteSuggestionsDiv.querySelectorAll('.suggestion-item'); 
                if (items.length === 0 && e.key !== 'Escape') return;

                if (e.key === 'ArrowDown') { e.preventDefault(); currentAutocompleteIndex = (currentAutocompleteIndex + 1) % items.length; updateCellSuggestionHighlight(); }
                else if (e.key === 'ArrowUp') { e.preventDefault(); currentAutocompleteIndex = (currentAutocompleteIndex - 1 + items.length) % items.length; updateCellSuggestionHighlight(); }
                else if (e.key === 'Enter') { 
                    e.preventDefault(); 
                    if (currentAutocompleteIndex >= 0 && currentAutocompleteIndex < items.length) {
                        selectCellAutocompleteSuggestion(items[currentAutocompleteIndex].textContent);
                    } else { 
                        hideCellAutocompleteSuggestions(); 
                        if(activeCellForAutocomplete) activeCellForAutocomplete.blur(); 
                    }
                }
                else if (e.key === 'Escape') { e.preventDefault(); hideCellAutocompleteSuggestions(); }
                else if (e.key === 'Tab') { hideCellAutocompleteSuggestions(); } 
            }
        });
        document.addEventListener('click', (event) => { 
            if (autocompleteSuggestionsDiv?.style.display === 'block') {
                const isClickInsideCell = activeCellForAutocomplete?.contains(event.target);
                const isClickInsideOverlay = activeCellForAutocomplete?.querySelector('.merged-cell-overlay')?.contains(event.target);
                const isClickInsideSuggestions = autocompleteSuggestionsDiv.contains(event.target);
                if (!isClickInsideCell && !isClickInsideSuggestions && !isClickInsideOverlay) {
                    hideCellAutocompleteSuggestions();
                }
            }
        });

        if(restoreBackupBtnElement) restoreBackupBtnElement.addEventListener('click', toggleRestoreBackupModalVisibility);
        if(closeRestoreBackupModalBtnElement) closeRestoreBackupModalBtnElement.addEventListener('click', toggleRestoreBackupModalVisibility);
        if(restoreBackupListContainerElement) restoreBackupListContainerElement.addEventListener('click', async (e) => {
            const targetSpan = e.target.closest('.backup-schedule-item .schedule-item-main-line span[data-backup-id]');
            if (targetSpan) {
                const backupId = targetSpan.dataset.backupId;
                await loadSelectedBackupIntoView(backupId);
            }
        });
        if (restoreBackupModalHeaderElement) {
            restoreBackupModalHeaderElement.addEventListener('mousedown', (e) => startDragModal(e, restoreBackupModalContentElement));
            restoreBackupModalHeaderElement.addEventListener('touchstart', (e) => startDragModal(e, restoreBackupModalContentElement), { passive: false });
        }
    }
    // --- ALL FUNCTION DEFINITIONS END HERE ---


    // --- DOMContentLoaded: Main Initialization ---
    document.addEventListener('DOMContentLoaded', () => {
        // Assign DOM elements to variables
        scheduleTitleElement = document.getElementById('scheduleTitle'); 
        tablesContainer = document.getElementById('tablesContainer'); 
        tableTabs = document.getElementById('tableTabs'); 
        nameModal = document.getElementById('nameModal'); 
        nameModalContent = document.getElementById('nameModalContent'); 
        nameModalHeader = document.getElementById('nameModalHeader'); 
        nameListContainer = document.getElementById('nameList'); 
        newNameInput = document.getElementById('newNameInput'); 
        sharedScheduleListContainerElement = document.getElementById('sharedScheduleListContainer'); 
        summaryTableElement = document.getElementById('summaryTable'); 
        summaryTableContainerElement = document.getElementById('summaryTableContainer'); 
        customMessageBox = document.getElementById('customMessageBox'); 
        fileInputElement = document.getElementById('fileInput'); 
        directCopyFullHtmlButtonElement = document.getElementById('directCopyFullHtmlBtn'); 
        closeNameModalButtonStandardElement = document.getElementById('closeNameModalBtnStandard'); 
        nameListImportFileInputElement = document.getElementById('nameListImportFile'); 
        searchNameInputElement = document.getElementById('searchNameInput'); 
        sharedScheduleImportFileInputElement = document.getElementById('sharedScheduleImportFile'); 
        userIdDisplayElement = document.getElementById('userIdDisplay'); 
        namePagiTabElement = document.getElementById('namePagiTab'); 
        namePetangTabElement = document.getElementById('namePetangTab'); 
        loadingIndicatorModalElement = document.getElementById('loadingIndicatorModal'); 
        nameModalTitleElement = document.getElementById('nameModalTitle'); 
        generalLoadingIndicatorElement = document.getElementById('generalLoadingIndicator'); 
        controlsTogglerElement = document.getElementById('controlsToggler'); 
        collapsibleButtonBarsElement = document.getElementById('collapsibleButtonBars'); 
        downloadPdfButtonElement = document.getElementById('downloadPdfBtn'); 
        pdfContentElement = document.getElementById('pdfContent'); 
        clearAndResetScheduleBtnElement = document.getElementById('clearAndResetScheduleBtn'); 
        manualSaveBtnElement = document.getElementById('manualSaveBtn');
        clearScheduledNamesBtnElement = document.getElementById('clearScheduledNamesBtn');
        restoreBackupBtnElement = document.getElementById('restoreBackupBtn');
        restoreBackupModalElement = document.getElementById('restoreBackupModal');
        restoreBackupModalContentElement = document.getElementById('restoreBackupModalContent');
        restoreBackupModalHeaderElement = document.getElementById('restoreBackupModalHeader');
        closeRestoreBackupModalBtnElement = document.getElementById('closeRestoreBackupModalBtn');
        restoreBackupListContainerElement = document.getElementById('restoreBackupListContainer');
        loadingIndicatorRestoreModalElement = document.getElementById('loadingIndicatorRestoreModal');

        autocompleteSuggestionsDiv = document.createElement('div'); 
        autocompleteSuggestionsDiv.id = 'autocompleteSuggestions'; 
        document.body.appendChild(autocompleteSuggestionsDiv);
        
        // Initialize UI elements that might need it
        if (controlsTogglerElement && collapsibleButtonBarsElement) { 
            collapsibleButtonBarsElement.classList.remove('open'); 
            controlsTogglerElement.setAttribute('aria-expanded', 'false'); 
            const textSpan = controlsTogglerElement.querySelector('span'); 
            if (textSpan) textSpan.textContent = 'Show Controls'; 
        }

        // Check if all critical DOM elements are found
        if (!tablesContainer || !tableTabs || !nameModal || !summaryTableElement || !scheduleTitleElement || !sharedScheduleListContainerElement || !generalLoadingIndicatorElement || !summaryTableContainerElement || !controlsTogglerElement || !collapsibleButtonBarsElement || !downloadPdfButtonElement || !pdfContentElement || !clearAndResetScheduleBtnElement || !manualSaveBtnElement || !clearScheduledNamesBtnElement || !restoreBackupBtnElement || !restoreBackupModalElement || !closeRestoreBackupModalBtnElement || !restoreBackupListContainerElement || !loadingIndicatorRestoreModalElement ) {
            console.error("CRITICAL DOM elements missing. Some functionality may be impaired.");
        }
        
        // Firebase Authentication State Change Listener
        if (fbAuth) {
            onAuthStateChanged(fbAuth, async (user) => {
                if (user) {
                    fbUserId = user.uid; 
                    fbIsAuthReady = true; 
                    if(userIdDisplayElement) userIdDisplayElement.textContent = `User ID: ${fbUserId}`;
                    
                    // Unsubscribe from previous listeners if they exist
                    if (unsubscribePagiShared) unsubscribePagiShared(); 
                    if (unsubscribePetangShared) unsubscribePetangShared();
                    
                    // Start listening to shared name lists
                    unsubscribePagiShared = listenToSharedNameList('pagi'); 
                    unsubscribePetangShared = listenToSharedNameList('petang');
                    
                    // Refresh name list if modal is open
                    if (nameModal?.style.display === 'flex' && searchNameInputElement) {
                        renderNameListFromFirestore(searchNameInputElement.value); 
                    }
                    
                    // Load the latest or default schedule
                    await loadLatestSharedScheduleAsDefault(); 
                    
                    // Start auto-save interval
                    if (autoSaveIntervalId) clearInterval(autoSaveIntervalId);
                    autoSaveIntervalId = setInterval(autoSaveCurrentSchedule, AUTO_SAVE_INTERVAL);
                } else { 
                    // User is signed out or auth token expired
                    fbIsAuthReady = false; 
                    fbUserId = null; 
                    if(userIdDisplayElement) userIdDisplayElement.textContent = "User ID: Authenticating...";
                    try {
                        // Attempt to sign in with custom token or anonymously
                        if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token && __initial_auth_token.trim() !== '') {
                            await signInWithCustomToken(fbAuth, __initial_auth_token);
                        } else {
                            await signInAnonymously(fbAuth);
                        }
                    } catch (error) {
                        console.error("Firebase Auth: Error during sign-in:", error); 
                        showMessage(`Firebase Auth failed. Error: ${error.message}`, "error", 7000);
                        if(userIdDisplayElement) userIdDisplayElement.textContent = `User ID: Auth Error`;
                        
                        // Fallback to setting up initial state if auth fails
                        console.log("Auth Error: Setting up initial table state as fallback.");
                        setupInitialTableState();
                        lastSavedState = captureCurrentState();
                        isInitialStateSet = true;
                        if (lastSavedState === null) console.error("CRITICAL: Initial state capture failed after auth failure.");
                        rebuildAndRenderSummary();
                    }
                }
            });
        } else { 
             // Firebase Auth service itself failed to initialize
             if(userIdDisplayElement) userIdDisplayElement.textContent = "User ID: Firebase Auth Not Initialized";
             console.error("Firebase Auth: fbAuth object not available."); 
             showMessage("Critical Error: Firebase Auth service not initialized.", "error", 10000);
             
             // Fallback to setting up initial state
             console.log("Firebase Init Error: Setting up initial table state as fallback.");
             setupInitialTableState();
             lastSavedState = captureCurrentState();
             isInitialStateSet = true;
             if (lastSavedState === null) console.error("CRITICAL: Initial state capture failed due to Firebase init error.");
             rebuildAndRenderSummary();
        }
        
        // Initialize other parts of the application
        loadScheduleTitleFromLocalStorage(); 
        initializeEventListeners(); // This should now work as functions are defined
        handleNameListSessionSwitch('pagi'); // Set default session for name list
    });
</script>
</body>
</html>