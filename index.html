<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=0.1, maximum-scale=5.0">
    <title>Shared Weekly Schedule with Firestore</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', 'Roboto', Arial, sans-serif;
            margin: 0;
            background-color: #f0f2f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px; /* Reduced body padding for smaller screens */
            box-sizing: border-box;
            min-height: 100vh;
        }
        .main-container {
            width: 100%;
            max-width: 1400px;
            background-color: #ffffff;
            padding: 20px; /* Adjusted padding */
            border-radius: 12px;
            box-shadow: 0 6px 20px rgba(0,0,0,0.08);
            box-sizing: border-box;
        }
        h2, h3 {
            color: #1c1e21;
            text-align: center;
            margin-bottom: 20px;
        }
        #scheduleTitle { 
            font-size: 2em; /* Slightly adjusted */
            color: #0056b3;
            border-bottom: 2px solid #0056b3;
            padding-bottom: 10px;
        }
        #userIdDisplay {
            text-align: center;
            font-size: 0.9em;
            color: #555;
            margin-bottom: 15px; 
            min-height: 1.2em;
            word-break: break-all; /* Ensure UserID wraps if too long */
        }

        /* --- Top Action Buttons Bar --- */
        #topActionButtonsBar {
            display: flex;
            flex-wrap: wrap; /* Allow buttons to wrap */
            gap: 8px; 
            align-items: stretch; /* Make buttons same height */
            justify-content: center; 
            margin-bottom: 20px; 
            width: 100%;
        }

        .top-action-btn {
            padding: 10px 15px; /* Consistent padding */
            font-size: 0.9em; 
            font-weight: 500;
            border-radius: 8px; /* More rounded */
            cursor: pointer;
            border: 1px solid transparent; /* Transparent border initially */
            color: #ffffff; /* White text for better contrast on gradient */
            transition: all 0.25s ease-out;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05), 0 1px 2px rgba(0,0,0,0.03);
            display: inline-flex;
            align-items: center;
            justify-content: center; /* Center content within button */
            gap: 8px; 
            white-space: nowrap; 
            flex-grow: 1; /* Allow buttons to grow */
            flex-basis: 150px; /* Minimum base width before wrapping */
            text-align: center;
        }

        #controlsToggler.top-action-btn {
            background-image: linear-gradient(to right, #007bff 0%, #0056b3 100%);
        }
        #controlsToggler.top-action-btn:hover {
            background-image: linear-gradient(to right, #0069d9 0%, #004085 100%);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1), 0 2px 4px rgba(0,0,0,0.06);
            transform: translateY(-1px);
        }

        #manualSaveBtn.top-action-btn {
            background-image: linear-gradient(to right, #17a2b8 0%, #117a8b 100%);
        }
        #manualSaveBtn.top-action-btn:hover {
            background-image: linear-gradient(to right, #138496 0%, #0c6270 100%);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1), 0 2px 4px rgba(0,0,0,0.06);
            transform: translateY(-1px);
        }

        #downloadPdfBtn.top-action-btn {
             background-image: linear-gradient(to right, #28a745 0%, #1e7e34 100%);
        }
        #downloadPdfBtn.top-action-btn:hover {
             background-image: linear-gradient(to right, #218838 0%, #155724 100%);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1), 0 2px 4px rgba(0,0,0,0.06);
            transform: translateY(-1px);
        }
        
        .top-action-btn:active {
            transform: translateY(0px);
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }

        #controlsToggler .toggler-icon {
            transition: transform 0.3s ease-out;
            width: 18px; 
            height: 18px;
        }
        #controlsToggler[aria-expanded="false"] .toggler-icon {
            transform: rotate(180deg);
        }
         #controlsToggler[aria-expanded="true"] .toggler-icon {
            transform: rotate(0deg);
        }

        /* --- Collapsible Button Bars --- */
        #collapsibleButtonBars {
            max-height: 1000px; /* Sufficiently large for content */
            overflow: hidden;
            transition: max-height 0.4s ease-in-out, margin-top 0.4s ease-in-out, padding-top 0.4s ease-in-out, padding-bottom 0.4s ease-in-out;
            padding-top: 5px;
            padding-bottom: 5px;
            width: 100%; 
        }
        #collapsibleButtonBars:not(.open) {
            max-height: 0;
            padding-top: 0;
            padding-bottom: 0;
            margin-top: 0;
        }

        .bar {
            display: flex;
            flex-wrap: wrap; /* Ensure buttons wrap */
            gap: 8px; /* Consistent gap */
            margin-bottom: 15px; /* Spacing between bars */
            align-items: stretch; /* Make buttons in a row same height */
            justify-content: center;
        }
        /* General style for buttons within .bar */
        .bar button {
            padding: 10px 15px; /* Consistent padding */
            font-size: 0.9em;
            font-weight: 500;
            border-radius: 8px;
            cursor: pointer;
            border: 1px solid #ced4da;
            background-color: #f8f9fa; /* Light base color */
            color: #212529; /* Dark text for readability */
            transition: all 0.2s ease-in-out;
            box-shadow: 0 1px 2px rgba(0,0,0,0.04);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            flex-grow: 1; /* Allow buttons to grow and fill space */
            flex-basis: 120px; /* Minimum base width, adjust as needed */
            text-align: center;
            min-width: 100px; /* Ensure buttons have a minimum tap target size */
        }
        .bar button:hover {
            border-color: #adb5bd;
            background-color: #e9ecef;
            box-shadow: 0 2px 5px rgba(0,0,0,0.08);
            transform: translateY(-1px);
        }
        .bar button:active {
            transform: translateY(0px);
            background-color: #dee2e6;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.06);
        }

        /* Specific button theme colors (can be gradients too) */
        #directCopyFullHtmlBtn { background-color: #545b62; color: white; border-color: #4e555b;}
        #excelBtnTrigger, #importExcelBtn, #importNameListBtn, .input-group button { background-color: #28a745; color: white; border-color: #23923d;}
        #saveSharedScheduleBtn { background-color: #007bff; color: white; border-color: #0069d9;}
        #loadSharedScheduleBtn { background-color: #ffc107; color: #212529; border-color: #e0a800;}
        #clearAndResetScheduleBtn, #nameListBtn { background-color: #fd7e14; color: white; border-color: #e66a04;}
        #selectBtn { background-color: #17a2b8; color: white; border-color: #117a8b;}
        #selectBtn.active { background-color: #e66a04; border-color: #d05f03;} /* Match clear button color */
        #mergeBtn { background-color: #6f42c1; color: white; border-color: #5d37a2;}
        #unmergeBtn { background-color: #e83e8c; color: white; border-color: #d9307b;}
        #addTableBtn { background-color: #20c997; color: white; border-color: #1aa87f;}
        #renameTableBtn, #deselectBtn { background-color: #6c757d; color: white; border-color: #5a6268;}
        #deleteTableBtn, #rowColManipulationBar button.delete-btn { background-color: #dc3545; color: white; border-color: #c82333;}
        #exportSharedSchedulesBtn { background-color: #4e54c8; color: white; border-color: #3b40a0;}
        #importSharedSchedulesBtn { background-color: #8f94fb; color: white; border-color: #7076f9;}
        
        /* Hover for themed buttons */
        #directCopyFullHtmlBtn:hover { background-color: #434a50; }
        #excelBtnTrigger:hover, #importExcelBtn:hover, #importNameListBtn:hover, .input-group button:hover { background-color: #1e7e34; }
        #saveSharedScheduleBtn:hover { background-color: #0056b3; }
        #loadSharedScheduleBtn:hover { background-color: #d39e00; }
        #clearAndResetScheduleBtn:hover, #nameListBtn:hover { background-color: #d05f03; }
        #selectBtn:hover { background-color: #0f6674; }
        #selectBtn.active:hover { background-color: #c25202;}
        #mergeBtn:hover { background-color: #563299; }
        #unmergeBtn:hover { background-color: #d9307b; }
        #addTableBtn:hover { background-color: #178d6f; }
        #renameTableBtn:hover, #deselectBtn:hover { background-color: #545b62; }
        #deleteTableBtn:hover, #rowColManipulationBar button.delete-btn:hover { background-color: #b21f2d; }
        #exportSharedSchedulesBtn:hover { background-color: #3b40a0; }
        #importSharedSchedulesBtn:hover { background-color: #7076f9; }


        #rowColManipulationBar button { padding: 8px 12px; font-size: 0.85em; } /* Slightly smaller for this specific bar */

        table {
            border-collapse: collapse;
            width: 100%;
            margin-top: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            background-color: #fff;
            table-layout: auto; 
        }
        #tablesContainer, #summaryTableContainer {
            overflow-x: auto;
            position: relative;
            width: 100%;
        }
        #tablesContainer > table {
            display: none;
        }
        #tablesContainer > table.active {
            display: table;
        }
        #summaryTable {
            margin-top: 25px;
        }
        th, td {
            border: 1px solid #dee2e6;
            padding: 10px 12px; /* Adjusted padding */
            text-align: center;
            min-width: 90px; /* Adjusted min-width */
            box-sizing: border-box;
            position: relative;
            font-size: 0.9em; /* Slightly smaller table font */
        }
        table th {
            background-color: #f8f9fa;
            color: #343a40;
            font-weight: 600;
            white-space: nowrap;
        }
        #tablesContainer > table > thead > tr > th {
            font-weight: bold;
            background-color: #e9ecef; /* Lighter grey */
            color: #343a40;
        }
        #tablesContainer > table > thead > tr > th:first-child,
        #tablesContainer > table > tbody > tr > td:first-child,
        #tablesContainer > table > tbody > tr > th:first-child {
            font-weight: bold;
            background-color: #e6f7ff; /* Lighter aliceblue */
            color: #1c1e21;
        }
        #summaryTable > thead > tr > th {
            font-weight: bold;
            background-color: #e9ecef;
            color: #212529;
        }
        #summaryTable > thead > tr > th:first-child,
        #summaryTable > tbody > tr > td:first-child {
            font-weight: bold;
            background-color: #e6f7ff;
            color: #1c1e21;
        }
        td.selected, th.selected {
            outline: 3px solid #007bff;
            background-color: #d1e7fd; /* Lighter selection */
        }
        
        .table-tabs {
            margin-bottom: 15px;
            border-bottom: 2px solid #007bff;
            padding-bottom: 0;
            display: flex;
            flex-wrap: wrap; /* Allow tabs to wrap */
            gap: 5px;
        }
        .table-tabs button {
            background-color: transparent;
            border: none;
            border-bottom: 3px solid transparent; /* Thicker indicator */
            border-radius: 6px 6px 0 0;
            color: #0056b3;
            font-weight: 500;
            padding: 10px 15px;
            transition: all 0.2s ease;
        }
        .table-tabs button.active {
            background-color: #007bff; /* More distinct active tab */
            color: white;
            border-color: #0056b3; /* Darker border for active tab */
        }
        .table-tabs button:hover:not(.active) {
            background-color: #e9f5ff;
            color: #004494;
        }

        .name-session-tabs {
            margin-bottom: 20px;
            border-bottom: 2px solid #dee2e6;
            padding-bottom: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }
        .name-session-tabs button {
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
            border-bottom: none;
            margin-bottom: -2px; /* Overlap border */
            padding: 10px 15px;
            font-size: 1em;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-bottom: 1px solid #dee2e6; /* Ensure bottom border is there initially */
        }
        .name-session-tabs button.active {
            background-color: #ffffff; /* White background for active tab */
            color: #007bff;
            border-color: #dee2e6 #dee2e6 #ffffff; /* Top and side borders, bottom transparent */
            border-bottom: 1px solid #ffffff; /* Make bottom border white to blend */
            font-weight: bold;
            position: relative;
            z-index: 1; /* Bring active tab forward */
        }
        #summaryTable td {
            background-color: #fff9e6;
        }
        #summaryTable > tbody > tr > td:first-child {
             background-color: #e6f7ff !important;
        }
        .highlight-conflict {
            background-color: #f8d7da !important;
            font-weight: bold;
            color: #721c24 !important;
        }
        #summaryTable > tbody > tr > td.highlight-conflict:first-child {
            background-color: #e6f7ff !important; /* Keep first col color */
            color: #721c24 !important;
        }
        .modal {
            display: none;
            position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%;
            overflow: hidden;
            background-color: rgba(0,0,0,0.5);
            align-items: center; justify-content: center;
            pointer-events: none;
        }
        .modal-content {
            background-color: #fff;
            padding: 25px; border: 1px solid #ccc; width: 90%; max-width: 650px;
            border-radius: 10px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.3); position: relative;
            pointer-events: auto;
            max-height: 90vh;
            overflow-y: auto;
            box-sizing: border-box;
        }
        .modal-content.dragging { transform: none; }
        .modal-header {
            padding-bottom: 15px;
            border-bottom: 1px solid #e9ecef; margin-bottom: 20px;
            font-size: 1.3em; color: #333; display: flex; justify-content: space-between; align-items: center;
            cursor: move; user-select: none;
        }
        .modal-close-btn {
            font-size: 1.8rem;
            font-weight: bold; line-height: 1; color: #555;
            text-shadow: none; opacity: .7; background: transparent; border: 0; cursor: pointer;
            padding: 0 5px;
            transition: color 0.2s;
        }
        .modal-close-btn:hover { opacity: 1; color: #dc3545; }
        .name-item {
            display: flex;
            justify-content: space-between; align-items: center;
            padding: 10px 8px; border-bottom: 1px solid #f1f3f5;
            transition: background-color 0.2s;
        }
        .name-item:hover { background-color: #f8f9fa; }
        .name-item:last-child { border-bottom: none; }
        .name-item span { flex-grow: 1; cursor: pointer; color: #007bff; font-weight: 500; }
        .name-item span:hover { text-decoration: none; color: #0056b3; }
        .name-item button { background-color: #dc3545; color: white; border: none; border-radius: 5px;
            padding: 6px 12px; font-size: 0.9em; transition: background-color 0.2s; }
        .name-item button:hover { background-color: #c82333; }
        .highlighted { background-color: #cfe2ff !important; font-weight: bold; }
        #sharedScheduleListContainer {
            border: 1px solid #ddd; padding: 15px; margin-bottom: 20px; border-radius: 8px;
            background-color: #f8f9fa;
            max-height: 300px;
            overflow-y: auto;
        }
        .shared-schedule-item { display: flex; justify-content: space-between; align-items: center;
            padding: 10px 8px; border-bottom: 1px solid #e9ecef; }
        .shared-schedule-item:last-child { border-bottom: none; }
        .shared-schedule-item span { cursor: pointer; color: #007bff; flex-grow: 1; margin-right: 10px; }
        .shared-schedule-item span:hover { text-decoration: underline; }
        .shared-schedule-item .schedule-date { font-size: 0.8em; color: #6c757d; margin-right: 10px; white-space: nowrap;}
        .shared-schedule-item button { background-color: #dc3545; color: white; border: none; border-radius: 5px;
            padding: 6px 12px; font-size: 0.9em; flex-shrink: 0; }
        #newNameInput, #searchNameInput {
            padding: 10px;
            margin-right: 8px; border: 1px solid #ccc; border-radius: 5px; flex-grow: 1;
            width: calc(100% - 120px); /* Adjust if button size changes */
            box-sizing: border-box;
        }
         #searchNameInput {
            margin-bottom: 15px;
            width: 100%;
            box-sizing: border-box;
            margin-right: 0;
         }
        .input-group {
            display: flex;
            margin-bottom: 15px;
            width: 100%;
        }
        .input-group button {
            /* Style inherited from .bar button, specific overrides if needed */
            padding: 10px 15px; /* Ensure consistent padding */
        }
        #importNameListBtn {
            margin-top: 10px;
            width: 100%;
            /* Style inherited from .bar button */
        }
        #nameList {
            margin-top:15px;
            max-height:250px;
            overflow-y:auto;
        }
        @media (min-width: 480px) { /* For wider name list display */
            #nameList {
                column-count: 2;
                column-gap: 20px;
            }
        }
        .custom-message-box {
            display: none;
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            background-color: #333; color: white; padding: 15px 25px; border-radius: 8px;
            z-index: 2000;
            box-shadow: 0 4px 15px rgba(0,0,0,0.25); font-size: 1.05em;
            text-align: center;
            width: 90%;
            max-width: 400px;
        }
        .custom-message-box.success { background-color: #28a745; }
        .custom-message-box.error { background-color: #dc3545; }
        .custom-message-box.info { background-color: #007bff; }
        .merged-cell-container { position: relative; z-index: 2; vertical-align: top; }
        .merged-cell-overlay {
            position: absolute;
            top: 0; left: 0; width: var(--merged-width); height: var(--merged-height);
            background-color: rgba(240, 248, 255, 0.95); font-style: italic; border: 1px solid #add8e6;
            display: flex; align-items: center;
            justify-content: center; overflow: hidden;
            box-sizing: border-box; z-index: 5;
        }
        .subsumed-cell { visibility: hidden; }
        #loadingIndicatorModal, #generalLoadingIndicator {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(255, 255, 255, 0.85);
            display: flex; align-items: center; justify-content: center;
            z-index: 10; /* Ensure it's above modal content for name list */
            border-radius: 10px;
        }
        #generalLoadingIndicator {
            position: fixed; /* Full screen loading */
            z-index: 3000;
            border-radius: 0;
        }
        .spinner {
            border: 5px solid rgba(0, 0, 0, 0.1);
            width: 40px; height: 40px;
            border-radius: 50%;
            border-left-color: #007bff;
            animation: spin 1s ease infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        input[type="file"][style*="display:none"],
        input[type="file"][style*="display: none"] {
            position: absolute;
            left: -9999px;
            width: 1px;
            height: 1px;
            opacity: 0;
        }
        #autocompleteSuggestions {
            display: none;
            position: absolute;
            border: 1px solid #ccc;
            background-color: white;
            z-index: 1001;
            max-height: 150px;
            overflow-y: auto;
            min-width: 120px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.15);
            border-radius: 4px;
        }
        .suggestion-item {
            padding: 8px 10px;
            cursor: pointer;
            font-size: 0.9em;
            white-space: nowrap;
        }
        .suggestion-item:hover, .suggestion-item.active-suggestion {
            background-color: #e9ecef;
            color: #0056b3;
        }

        /* PDF Specific Styles */
        #pdfContent {
            padding: 5mm; 
            background-color: #fff;
            color: #333;
            font-family: 'Arial', sans-serif; 
            box-sizing: border-box;
            width: 100%; 
            display: none; 
        }
        #pdfContent .pdf-page-wrapper {
            page-break-inside: avoid !important; 
            padding-bottom: 10mm; 
            box-sizing: border-box;
            margin-bottom: 5mm; 
        }
         #pdfContent .pdf-page-wrapper:not(:first-child) {
             page-break-before: always !important; 
        }
        #pdfContent .pdf-page-wrapper:last-child {
             page-break-after: auto !important;
        }
        #pdfContent h2 {
            text-align: center;
            color: #000; 
            margin-bottom: 5mm; 
            font-size: 14pt; 
            page-break-after: avoid !important;
            page-break-inside: avoid !important;
        }
        #pdfContent h3 {
            text-align: center;
            color: #000;
            margin-top: 2mm;
            margin-bottom: 3mm; 
            font-size: 11pt; 
            page-break-after: avoid !important;
            page-break-inside: avoid !important;
        }
        #pdfContent table {
            width: 100% !important; 
            border-collapse: collapse !important;
            margin-bottom: 5mm;
            box-shadow: none;
            background-color: #fff;
            table-layout: fixed !important; 
            font-size: 7pt; 
            page-break-inside: avoid !important; 
        }
        #pdfContent th, #pdfContent td {
            border: 0.5pt solid #333 !important; 
            padding: 1mm 1.5mm; 
            text-align: center;
            word-wrap: break-word; 
            overflow-wrap: break-word;
            background-color: #fff !important; 
            page-break-inside: avoid !important; 
        }
        #pdfContent th {
            background-color: #f0f0f0 !important; 
            color: #000;
            font-weight: bold; 
        }
        #pdfContent table tbody tr td:first-child,
        #pdfContent table thead tr th:first-child {
            background-color: #e6f7ff !important; 
            font-weight: bold;
            white-space: normal; 
        }
         #pdfContent table tr { 
            page-break-inside: avoid !important;
        }
        #pdfContent .pdf-footnote {
            text-align: right;
            font-size: 6pt; 
            color: #333;
            margin-top: 3mm;
            padding-top: 2mm;
            border-top: 0.5pt solid #ccc;
            width: 100%;
            box-sizing: border-box;
        }

        /* Responsive adjustments for smaller screens */
        @media (max-width: 768px) {
            .main-container {
                padding: 15px;
            }
            #scheduleTitle {
                font-size: 1.8em;
            }
            h3 {
                font-size: 1.1em;
            }
            .top-action-btn {
                font-size: 0.85em;
                padding: 8px 12px;
                flex-basis: 120px; /* Allow more wrapping on smaller screens */
            }
            .bar button {
                font-size: 0.85em;
                padding: 8px 12px;
                flex-basis: 100px; /* Allow more wrapping */
            }
            th, td {
                padding: 8px 10px;
                min-width: 70px;
                font-size: 0.85em;
            }
            .table-tabs button, .name-session-tabs button {
                padding: 8px 10px;
                font-size: 0.9em;
            }
        }
        @media (max-width: 480px) {
            body { padding: 5px; }
            .main-container { padding: 10px; }
            #scheduleTitle { font-size: 1.5em; }
            .top-action-btn { 
                font-size: 0.8em; 
                padding: 6px 10px; 
                gap: 4px;
                flex-basis: calc(50% - 4px); /* Aim for two buttons per row if possible */
            }
            #controlsToggler .toggler-icon { width: 16px; height: 16px; }
             .bar button {
                font-size: 0.8em;
                padding: 6px 10px;
                gap: 4px;
                flex-basis: calc(50% - 4px);
            }
            th, td {
                padding: 6px 8px;
                min-width: 60px;
                font-size: 0.8em;
            }
             #nameList { /* Single column for name list on very small screens */
                column-count: 1;
            }
        }

    </style>
</head>
<body>
<div class="main-container">
    <h2 contenteditable="true" id="scheduleTitle">Jadual Anjal</h2>
    <div id="userIdDisplay">User ID: Loading...</div>

    <div id="topActionButtonsBar">
        <button id="controlsToggler" class="top-action-btn" aria-expanded="false" aria-controls="collapsibleButtonBars" title="Toggle button controls visibility">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="toggler-icon"><polyline points="18 15 12 9 6 15"></polyline></svg>
            <span>Show Controls</span>
        </button>
        <button id="manualSaveBtn" class="top-action-btn" title="Manually save current page state to Cloud">üíæ Save Page</button> <button id="downloadPdfBtn" class="top-action-btn" title="Download schedule tables as PDF">üìÑ PDF</button> </div>

    <div id="collapsibleButtonBars">
        <div class="bar">
            <button id="directCopyFullHtmlBtn" title="Copy the entire page's HTML to clipboard">üìã Copy HTML</button>
        </div>
        <div class="bar">
            <button id="excelBtnTrigger" title="Export the currently active table to an Excel file">üíæ Export Excel</button>
            <button id="importExcelBtn" title="Import data from an Excel file into a new table">üìÇ Import Excel</button>
            <input type="file" id="fileInput" accept=".xlsx, .xls" style="display:none">
        </div>
        <div class="bar">
            <button id="saveSharedScheduleBtn" title="Save current schedule to the shared Cloud space">üí† Save Shared</button>
            <button id="loadSharedScheduleBtn" title="Show list of shared schedules from Cloud to load">‚òÅÔ∏è Load Shared</button>
            <button id="exportSharedSchedulesBtn" title="Export all shared schedules from Cloud to a JSON file">üì§ Export All</button>
            <button id="importSharedSchedulesBtn" title="Import schedules from a JSON file to the shared Cloud space">üì• Import All</button>
            <input type="file" id="sharedScheduleImportFile" accept=".json" style="display:none;">
            <button id="clearAndResetScheduleBtn" title="Clear all data and start a new schedule">üßπ Clear & New</button>
        </div>
        <div class="bar">
            <button id="selectBtn" title="Toggle cell selection mode on/off">‚ú® Select Cells</button>
            <button id="mergeBtn" title="Merge the currently selected cells">üîó Merge</button>
            <button id="deselectBtn" title="Clear current cell selection">üö´ Deselect</button>
            <button id="unmergeBtn" title="Unmerge the cell that was last clicked if it's part of a merge">üíî Unmerge</button>
        </div>
        <div class="bar">
            <button id="addTableBtn" title="Add a new, empty table/sheet">‚ûï Add Table</button>
            <button id="renameTableBtn" title="Rename the currently active table/sheet">üìù Rename Table</button>
            <button id="deleteTableBtn" title="Delete the currently active table/sheet">‚ùå Delete Table</button>
            <button id="nameListBtn" title="Open a dialog to manage the shared list of names (Firestore)">üë• Names</button>
        </div>
        <div class="bar" id="rowColManipulationBar">
            <button id="addRowAboveBtn" title="Add a new row above the currently selected/clicked row">‚¨ÜÔ∏è Row Above</button>
            <button id="addRowBelowBtn" title="Add a new row below the currently selected/clicked row">‚¨áÔ∏è Row Below</button>
            <button id="addColLeftBtn" title="Add a new column to the left of the currently selected/clicked column">‚¨ÖÔ∏è Col Left</button>
            <button id="addColRightBtn" title="Add a new column to the right of the currently selected/clicked column">‚û°Ô∏è Col Right</button>
            <button id="deleteRowBtn" class="delete-btn" title="Delete the currently selected/clicked row">üóëÔ∏è Del Row</button>
            <button id="deleteColBtn" class="delete-btn" title="Delete the currently selected/clicked column">üóëÔ∏è Del Col</button>
        </div>
    </div>
    <div id="sharedScheduleListContainer" style="display:none;"></div>
    <div class="bar table-tabs" id="tableTabs"></div>
    <div id="tablesContainer">
        <table id="tbl_1" class="active" data-table-name="Kelas 3 & 5">
            <thead>
                <tr>
                    <th contenteditable="true">Class</th>
                    <th contenteditable="true">08:00</th>
                    <th contenteditable="true">09:00</th>
                    <th contenteditable="true">10:00</th>
                    <th contenteditable="true" data-merge-id="rehat_tbl1_col4" class="merged-cell-container">
                        <div class="merged-cell-overlay" style="--merged-width: 200px; --merged-height: 50px;" contenteditable="true">REHAT</div>
                    </th>
                    <th contenteditable="true" data-merge-id="rehat_tbl1_col4" class="subsumed-cell">11:00</th>
                    <th contenteditable="true">12:00</th>
                    <th contenteditable="true">13:00</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td contenteditable="true">5S1</td>
                    <td contenteditable="true"></td><td contenteditable="true">JAMES *ReportDue // Sick leave</td><td contenteditable="true"></td>
                    <td contenteditable="true" data-merge-id="rehat_tbl1_col4_row1" class="merged-cell-container">
                         <div class="merged-cell-overlay" style="--merged-width: 200px; --merged-height: 50px;" contenteditable="true"></div>
                    </td>
                    <td contenteditable="true" data-merge-id="rehat_tbl1_col4_row1" class="subsumed-cell"></td>
                    <td contenteditable="true"></td><td contenteditable="true"></td>
                </tr>
                 <tr>
                    <td contenteditable="true">5S2</td>
                    <td contenteditable="true">*SpecialAssembly</td><td contenteditable="true"></td><td contenteditable="true">LILY</td>
                     <td contenteditable="true" data-merge-id="rehat_tbl1_col4_row2" class="merged-cell-container">
                         <div class="merged-cell-overlay" style="--merged-width: 200px; --merged-height: 50px;" contenteditable="true"></div>
                    </td>
                    <td contenteditable="true" data-merge-id="rehat_tbl1_col4_row2" class="subsumed-cell"></td>
                    <td contenteditable="true"></td><td contenteditable="true"></td>
                </tr>
            </tbody>
        </table>
        <table id="tbl_2" data-table-name="Kelas 1, 2 & 4">
            <thead>
                <tr>
                    <th contenteditable="true">Class</th>
                    <th contenteditable="true">08:00</th>
                    <th contenteditable="true">09:00</th>
                    <th contenteditable="true">10:00</th>
                    <th contenteditable="true" data-merge-id="rehat_tbl2_col4" class="merged-cell-container">
                        <div class="merged-cell-overlay" style="--merged-width: 200px; --merged-height: 50px;" contenteditable="true">REHAT</div>
                    </th>
                    <th contenteditable="true" data-merge-id="rehat_tbl2_col4" class="subsumed-cell">11:00</th>
                    <th contenteditable="true">12:00</th>
                    <th contenteditable="true">13:00</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td contenteditable="true">1A</td>
                    <td contenteditable="true">MATH</td><td contenteditable="true"></td><td contenteditable="true">SCIENCE</td>
                    <td contenteditable="true" data-merge-id="rehat_tbl2_col4_row1" class="merged-cell-container">
                         <div class="merged-cell-overlay" style="--merged-width: 200px; --merged-height: 50px;" contenteditable="true"></div>
                    </td>
                    <td contenteditable="true" data-merge-id="rehat_tbl2_col4_row1" class="subsumed-cell"></td>
                    <td contenteditable="true"></td><td contenteditable="true"></td>
                </tr>
                 <tr>
                    <td contenteditable="true">2B</td>
                    <td contenteditable="true"></td><td contenteditable="true">HISTORY</td><td contenteditable="true"></td>
                    <td contenteditable="true" data-merge-id="rehat_tbl2_col4_row2" class="merged-cell-container">
                         <div class="merged-cell-overlay" style="--merged-width: 200px; --merged-height: 50px;" contenteditable="true"></div>
                    </td>
                    <td contenteditable="true" data-merge-id="rehat_tbl2_col4_row2" class="subsumed-cell"></td>
                    <td contenteditable="true">ART</td><td contenteditable="true"></td>
                </tr>
                <tr>
                    <td contenteditable="true">4C</td>
                    <td contenteditable="true">PHYSICS</td><td contenteditable="true"></td><td contenteditable="true">CHEMISTRY</td>
                    <td contenteditable="true" data-merge-id="rehat_tbl2_col4_row3" class="merged-cell-container">
                         <div class="merged-cell-overlay" style="--merged-width: 200px; --merged-height: 50px;" contenteditable="true"></div>
                    </td>
                    <td contenteditable="true" data-merge-id="rehat_tbl2_col4_row3" class="subsumed-cell"></td>
                    <td contenteditable="true"></td><td contenteditable="true"></td>
                </tr>
            </tbody>
        </table>
    </div>

    <div id="nameModal" class="modal">
        <div class="modal-content" id="nameModalContent">
            <div class="modal-header" id="nameModalHeader">
                <h3 id="nameModalTitle">Shared Name List Manager</h3>
                <button type="button" class="modal-close-btn" id="closeNameModalBtnStandard" title="Close name manager">√ó</button>
            </div>
            <div class="name-session-tabs">
                <button id="namePagiTab" data-session="pagi" class="active">Pagi (Morning)</button>
                <button id="namePetangTab" data-session="petang">Petang (Afternoon)</button>
            </div>
             <div class="input-group">
                <input id="newNameInput" placeholder="Add new name to current shared session">
                <button id="addNameBtnInModal" title="Add the name to the shared list">Add</button>
             </div>
            <button id="importNameListBtn" title="Import names from a .txt file (one name per line) to current shared session">üìÇ Import Names (.txt) to Shared Session</button>
            <input type="file" id="nameListImportFile" accept=".txt" style="display:none;">
            <input type="text" id="searchNameInput" placeholder="üîç Search names in current shared session..." title="Filter the list of names">
            <div id="nameList"></div>
            <div id="loadingIndicatorModal" style="display:none;"><div class="spinner"></div></div>
        </div>
    </div>

    <h3 style="margin-top:32px">Teacher/Subject Attendance Summary</h3>
    <div id="summaryTableContainer">
        <table id="summaryTable"></table>
    </div>
    <div id="customMessageBox" class="custom-message-box"></div>
    <div id="generalLoadingIndicator" style="display:none;"><div class="spinner"></div></div>
</div>

<div id="pdfContent"></div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, setDoc, onSnapshot, collection, addDoc, getDocs, getDoc, deleteDoc, updateDoc, query, serverTimestamp, orderBy, where, limit } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // --- User-provided Firebase Config (Fallback) ---
    const userProvidedFirebaseConfig = {
      apiKey: "AIzaSyBgvyb95-jujtCC2HPiHXLdYMJgQquIEx4", // IMPORTANT: Replace with your actual Firebase API Key
      authDomain: "jadual-3f0aa.firebaseapp.com",
      projectId: "jadual-3f0aa",
      storageBucket: "jadual-3f0aa.firebasestorage.app",
      messagingSenderId: "496526436851",
      appId: "1:496526436851:web:78ff48b28bfc8c31f14a86"
    };

    // --- Firebase Initialization ---
    let firebaseConfig;
    // Check for injected Firebase config (e.g., from a platform like Canvas)
    if (typeof __firebase_config !== 'undefined' && __firebase_config !== null && __firebase_config.trim() !== '') {
        try {
            firebaseConfig = JSON.parse(__firebase_config);
            console.log("Using injected Firebase config (__firebase_config).");
        } catch (e) {
            console.error("Error parsing injected __firebase_config. Falling back to userProvidedFirebaseConfig. Error:", e);
            firebaseConfig = userProvidedFirebaseConfig;
        }
    } else {
        firebaseConfig = userProvidedFirebaseConfig;
        console.log("Using Firebase config defined in the script (userProvidedFirebaseConfig).");
    }

    // Basic API Key validation (prevents app from breaking if placeholder is used)
    if (firebaseConfig.apiKey === "AIzaSyEXAMPLE-API-KEYdQquIEx4" || firebaseConfig.apiKey === "YOUR_API_KEY" || firebaseConfig.apiKey.includes("AIzaSyBgvyb95-jujtCC2HPiHXLdYMJgQquIEx4") /* Check against the original placeholder too */) {
        console.error("Firebase Auth: CRITICAL - The Firebase API Key is still a placeholder or the example one. Please update it in the script.");
        const userIdDisplayError = document.getElementById('userIdDisplay');
        if (userIdDisplayError) userIdDisplayError.textContent = "User ID: Firebase API Key Error!";
        // showMessage is not defined yet, so can't call it here. Error will be logged.
    }
    
    // Determine App ID (prefer injected, then from config, then default)
    const appId = typeof __app_id !== 'undefined' ? __app_id : (firebaseConfig.appId || 'default-shared-scheduler-app');
    if (typeof __app_id === 'undefined') {
        console.warn("Firebase Auth: __app_id is not defined. Using App ID from Firebase config or a default value for Firestore paths.");
    }

    let fbApp, fbAuth, fbDb;
    let fbUserId = null;
    let fbIsAuthReady = false;
    let unsubscribePagiShared = null;
    let unsubscribePetangShared = null;

    try {
        fbApp = initializeApp(firebaseConfig);
        fbAuth = getAuth(fbApp);
        fbDb = getFirestore(fbApp);
        console.log("Firebase services initialized for Shared Scheduler with Project ID:", firebaseConfig.projectId);
    } catch (e) {
        console.error("CRITICAL Error initializing Firebase services:", e);
        // showMessage not available yet.
        const userIdDisplayInitError = document.getElementById('userIdDisplay');
        if (userIdDisplayInitError) userIdDisplayInitError.textContent = "User ID: Firebase Init Error!";
    }

    // --- Global Variables & Constants ---
    const SCHEDULE_TITLE_KEY = `shared_jadual_title_${appId}`; // For localStorage of page title
    const LAST_ACTIVE_SCHEDULE_ID_KEY = `last_active_schedule_id_${appId}`; // For session storage of last loaded/saved Firestore doc ID
    
    let activeTableId = 'tbl_1'; 
    let tableCount = 1; // Used for generating unique IDs for new tables
    let selectionMode = false;
    let selectedCells = [];
    let lastClickedCell = null; 
    let selectedNameFromList = null; 
    let currentNameListSession = 'pagi'; 
    let namesPagiShared = []; 
    let namesPetangShared = []; 
    let isDraggingModal = false;
    let modalDragOffsetX, modalDragOffsetY;
    let autocompleteSuggestionsDiv = null;
    let activeCellForAutocomplete = null;
    let currentAutocompleteIndex = -1;
    
    // Autosave and State Management Variables
    let currentWorkingScheduleDocId = null; // Firestore Document ID of the currently loaded/saved schedule
    let autoSaveIntervalId = null;
    const AUTO_SAVE_INTERVAL = 60000; // 60 seconds (1 minute)
    let isAutoSaving = false; // Flag to prevent concurrent save operations
    
    let lastSavedState = null; // Stores the last successfully saved state (object from captureCurrentState)
    let isInitialStateSet = false; // Flag to ensure initial state is captured before autosave starts

    // DOM Element References (initialized in DOMContentLoaded)
    let scheduleTitleElement, tablesContainer, tableTabs, nameModal, nameModalContent, nameModalHeader, 
        nameListContainer, newNameInput, sharedScheduleListContainerElement, summaryTableElement, 
        summaryTableContainerElement, customMessageBox, fileInputElement, directCopyFullHtmlButtonElement, 
        closeNameModalButtonStandardElement, nameListImportFileInputElement, searchNameInputElement, 
        sharedScheduleImportFileInputElement, userIdDisplayElement, namePagiTabElement, namePetangTabElement, 
        loadingIndicatorModalElement, nameModalTitleElement, generalLoadingIndicatorElement, 
        controlsTogglerElement, collapsibleButtonBarsElement, downloadPdfButtonElement, pdfContentElement, 
        clearAndResetScheduleBtnElement, manualSaveBtnElement; 

    // --- Utility Functions ---
    function showMessage(message, type = 'info', duration = 3000) {
        if (!customMessageBox) {
            customMessageBox = document.getElementById('customMessageBox');
            if (!customMessageBox) { 
                console.warn("showMessage called but customMessageBox element not found. Message:", message);
                return;
            }
        }
        customMessageBox.textContent = message;
        customMessageBox.className = `custom-message-box ${type}`; 
        customMessageBox.style.display = 'block';
        setTimeout(() => { if (customMessageBox) customMessageBox.style.display = 'none'; }, duration);
    }

    function customPrompt(message, defaultValue = "") {
        return prompt(message, defaultValue); // Using standard prompt
    }

    function customConfirm(message) {
        // Using a promise-based custom confirm dialog for better UX
        return new Promise((resolve) => {
            const confirmModalId = 'customConfirmModal';
            let existingModal = document.getElementById(confirmModalId);
            if (existingModal) existingModal.remove(); 

            const modal = document.createElement('div');
            modal.id = confirmModalId;
            modal.style.cssText = `display: flex; position: fixed; z-index: 2001; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5); align-items: center; justify-content: center;`;

            const modalContent = document.createElement('div');
            modalContent.style.cssText = `background-color: #fff; padding: 25px; border-radius: 8px; text-align: center; box-shadow: 0 5px 15px rgba(0,0,0,0.3); min-width: 300px; max-width: 90%;`;

            const messageP = document.createElement('p');
            messageP.textContent = message;
            messageP.style.marginBottom = '20px'; messageP.style.fontSize = '1.1em';

            const yesButton = document.createElement('button');
            yesButton.textContent = 'Yes';
            yesButton.style.cssText = `padding: 10px 20px; margin: 0 10px; border-radius: 5px; cursor: pointer; background-color: #28a745; color: white; border: none; font-size: 1em;`;

            const noButton = document.createElement('button');
            noButton.textContent = 'No';
            noButton.style.cssText = `padding: 10px 20px; margin: 0 10px; border-radius: 5px; cursor: pointer; background-color: #dc3545; color: white; border: none; font-size: 1em;`;

            const closeModal = (value) => { modal.remove(); resolve(value); };
            yesButton.onclick = () => closeModal(true);
            noButton.onclick = () => closeModal(false);

            modalContent.appendChild(messageP);
            modalContent.appendChild(yesButton);
            modalContent.appendChild(noButton);
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
        });
    }
    
    function showGeneralLoading(isLoading) {
        if (generalLoadingIndicatorElement) {
            generalLoadingIndicatorElement.style.display = isLoading ? 'flex' : 'none';
        }
    }

    function toggleButtonBarsVisibility() {
        if (!collapsibleButtonBarsElement || !controlsTogglerElement) return;
        const isOpen = collapsibleButtonBarsElement.classList.toggle('open');
        controlsTogglerElement.setAttribute('aria-expanded', isOpen.toString());
        const textSpan = controlsTogglerElement.querySelector('span');
        if (textSpan) {
            textSpan.textContent = isOpen ? 'Hide Controls' : 'Show Controls';
        }
    }

    function showNameModalLoading(isLoading) {
        if (loadingIndicatorModalElement) {
            loadingIndicatorModalElement.style.display = isLoading ? 'flex' : 'none';
        }
    }
    
    // --- State Management and Autosave Logic (NEW/UPDATED) ---
    function captureCurrentState() {
        if (!tablesContainer || !scheduleTitleElement) {
            console.warn("captureCurrentState: Critical elements (tablesContainer or scheduleTitleElement) not found.");
            return null; // Return null if essential elements are missing
        }
        
        const state = {
            html: tablesContainer.innerHTML,
            tableMeta: {},
            activeTableId: activeTableId,
            scheduleTitle: scheduleTitleElement.textContent || '' // Ensure scheduleTitle is captured
        };

        tablesContainer.querySelectorAll('table').forEach(table => {
            state.tableMeta[table.id] = {
                name: table.dataset.tableName || table.id,
                // Add more meta if needed, e.g., row/col counts for more granular change detection
                rowCount: table.rows.length,
                colCount: table.rows[0]?.cells.length || 0
            };
        });
        return state;
    }

    function hasStateChanged(currentState) {
        if (!isInitialStateSet || !lastSavedState) { // If no previous state, it has changed
             // console.log("hasStateChanged: No lastSavedState or initial state not set, assuming changes.");
            return true;
        }
        if (!currentState) { // If current state can't be captured, assume no change to prevent erroneous saves
            console.warn("hasStateChanged: currentState is null, assuming no changes to be safe.");
            return false;
        }
        
        // Compare HTML content of tablesContainer
        if (currentState.html !== lastSavedState.html) {
            // console.log("hasStateChanged: HTML content differs.");
            return true;
        }
        
        // Compare schedule title
        if (currentState.scheduleTitle !== lastSavedState.scheduleTitle) {
            // console.log("hasStateChanged: Schedule title differs.");
            return true;
        }
        
        // Compare active table ID
        if (currentState.activeTableId !== lastSavedState.activeTableId) {
            // console.log("hasStateChanged: Active table ID differs.");
            return true;
        }
        
        // Compare table metadata (structure, names)
        const currentTablesKeys = Object.keys(currentState.tableMeta);
        const savedTablesKeys = Object.keys(lastSavedState.tableMeta);
        
        if (currentTablesKeys.length !== savedTablesKeys.length) {
            // console.log("hasStateChanged: Number of tables differs.");
            return true;
        }
        
        for (const tableId of currentTablesKeys) {
            const currentMeta = currentState.tableMeta[tableId];
            const savedMeta = lastSavedState.tableMeta[tableId];
            
            if (!savedMeta) { // New table added
                // console.log(`hasStateChanged: Table ${tableId} is new.`);
                return true;
            }
            if (currentMeta.name !== savedMeta.name) {
                // console.log(`hasStateChanged: Table ${tableId} name differs.`);
                return true;
            }
            if (currentMeta.rowCount !== savedMeta.rowCount) {
                //  console.log(`hasStateChanged: Table ${tableId} row count differs.`);
                return true;
            }
            if (currentMeta.colCount !== savedMeta.colCount) {
                // console.log(`hasStateChanged: Table ${tableId} column count differs.`);
                return true;
            }
            // Add more detailed checks if necessary (e.g., specific cell content for critical cells)
        }
        
        // console.log("hasStateChanged: No significant differences detected.");
        return false; // No changes detected
    }

    // Centralized function to update local state tracking after any save/load operation
    function _updateLocalStateAfterSave(docId, scheduleName, isAutoDraft, operationType) {
        const capturedState = captureCurrentState(); // Capture the state that was just saved or loaded

        if (!capturedState) {
            console.error(`_updateLocalStateAfterSave (${operationType}): Failed to capture current state. Local state (lastSavedState) NOT updated.`);
            // This is a potential issue, as lastSavedState might become out of sync.
            // However, setting it to null might cause immediate re-saves if captureCurrentState fails temporarily.
        } else {
            lastSavedState = capturedState; // Update with the state that corresponds to what's in Firestore
        }
        
        currentWorkingScheduleDocId = docId; // Update the active Firestore document ID

        if (docId) {
            sessionStorage.setItem(LAST_ACTIVE_SCHEDULE_ID_KEY, docId);
        } else {
            // If docId is null (e.g., after reset, or failed load of a non-existent doc), clear it
            sessionStorage.removeItem(LAST_ACTIVE_SCHEDULE_ID_KEY);
        }

        const timestamp = new Date().toLocaleTimeString();
        console.log(`%cStateUpdate (${operationType}): ID: ${docId || 'N/A'}, Name: "${scheduleName || 'N/A'}", Draft: ${isAutoDraft}. lastSavedState updated. Time: ${timestamp}`, "color: blue; font-weight: bold;");

        // Show UI messages for explicit saves, manual saves, or critical load messages
        if (operationType === "explicit-save" && scheduleName) {
            showMessage(`Shared schedule "${scheduleName}" saved to Cloud! (ID: ${docId})`, 'success');
        } else if (operationType === "manual-save" && scheduleName) {
             const displayName = scheduleName + (isAutoDraft ? " (Draft)" : "");
            showMessage(`Current page "${displayName}" saved to Cloud! (ID: ${docId})`, 'success');
        } else if (operationType === "load" && scheduleName) {
            const displayName = scheduleName + (isAutoDraft ? " (Draft)" : "");
            showMessage(`Shared schedule "${displayName}" loaded from Cloud!`, 'success');
        }
        // Auto-draft creation and auto-save updates are generally silent in the UI.
    }

    // --- Firestore Interaction Functions ---
    async function saveSharedNameListToFirestore(session, namesArray) {
        if (!fbDb || !fbIsAuthReady) {
            showMessage("Firebase not ready. Cannot save shared name list.", "error");
            return;
        }
        showNameModalLoading(true);
        const uniqueSortedNames = [...new Set(namesArray.map(n => String(n||'').trim()).filter(n => n))]
                                .sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));

        if (!appId || appId === 'default-shared-scheduler-app') { 
            showMessage("Configuration error: App ID is missing or default. Cannot save shared name list.", "error");
            showNameModalLoading(false);
            return;
        }
        const docRef = doc(fbDb, "artifacts", appId, "public/data/sharedNameLists", session);
        try {
            await setDoc(docRef, { names: uniqueSortedNames, lastUpdatedBy: fbUserId || "anonymous", updatedAt: serverTimestamp() });
            showMessage(`Shared name list for ${session} session updated.`, "success");
        } catch (error) {
            console.error(`Error saving shared list to ${session}:`, error);
            showMessage(`Failed to save shared list to ${session}. Error: ${error.message}`, "error");
        } finally {
            showNameModalLoading(false);
        }
    }

    async function addNameToSharedSessionInFirestore(name) {
        if (!fbDb || !fbIsAuthReady) {
            showMessage("Firebase not ready. Cannot add name to shared list.", "error");
            return;
        }
        const trimmedName = String(name || '').trim();
        if (!trimmedName) {
            showMessage("Name cannot be empty.", "info");
            return;
        }
        showNameModalLoading(true);
        const sessionNames = currentNameListSession === 'pagi' ? namesPagiShared : namesPetangShared;
        if (sessionNames.map(n => String(n || '').toLowerCase()).includes(trimmedName.toLowerCase())) {
            showMessage(`Name "${trimmedName}" already exists in shared ${currentNameListSession} session.`, "info");
            showNameModalLoading(false);
            return;
        }
        if (!appId || appId === 'default-shared-scheduler-app') { 
            showMessage("Configuration error: App ID is missing or default. Cannot add name.", "error");
            showNameModalLoading(false);
            return;
        }
        const updatedNames = [...sessionNames, trimmedName].sort((a, b) => String(a).localeCompare(String(b), undefined, { sensitivity: 'base' }));
        const docRef = doc(fbDb, "artifacts", appId, "public/data/sharedNameLists", currentNameListSession);
        try {
            await setDoc(docRef, { names: updatedNames, lastUpdatedBy: fbUserId || "anonymous", updatedAt: serverTimestamp() });
            if(newNameInput) {
                newNameInput.value = '';
                newNameInput.focus();
            }
        } catch (error) {
            console.error(`Error adding name to shared ${currentNameListSession}:`, error);
            showMessage(`Failed to add name to shared list. Error: ${error.message}`, "error");
        } finally {
            showNameModalLoading(false);
        }
    }

    async function deleteNameFromSharedSessionInFirestore(nameToDelete) {
        if (!fbDb || !fbIsAuthReady) {
            showMessage("Firebase not ready. Cannot delete name from shared list.", "error");
            return;
        }
        const nameToDeleteStr = String(nameToDelete || '');
        if (await customConfirm(`Delete "${nameToDeleteStr}" from shared ${currentNameListSession} session? This also removes it from all schedule tables for everyone.`)) {
            showNameModalLoading(true);
            if (!appId || appId === 'default-shared-scheduler-app') { 
                showMessage("Configuration error: App ID is missing or default. Cannot delete name.", "error");
                showNameModalLoading(false);
                return;
            }
            const currentNames = currentNameListSession === 'pagi' ? namesPagiShared : namesPetangShared;
            const updatedNames = currentNames.filter(name => String(name || '') !== nameToDeleteStr);
            const docRef = doc(fbDb, "artifacts", appId, "public/data/sharedNameLists", currentNameListSession);
            try {
                await setDoc(docRef, { names: updatedNames, lastUpdatedBy: fbUserId || "anonymous", updatedAt: serverTimestamp() });
                tablesContainer.querySelectorAll('table').forEach(table => {
                    table.querySelectorAll('tbody td, tbody th, .merged-cell-overlay').forEach(cell => {
                        const cellText = cell.textContent.trim();
                        const parts = cellText.split(' // '); 
                        let mainContent = parts[0];
                        const remarkContent = parts.length > 1 ? ` // ${parts.slice(1).join(' // ')}` : '';

                        const wordsInMain = mainContent.split(/\s+/);
                        const newWordsInMain = wordsInMain.filter(word => {
                            if (word.startsWith('*') && mainContent.includes(nameToDeleteStr)) {
                                return !mainContent.includes(word.substring(1)); 
                            }
                            return word !== nameToDeleteStr;
                        });
                        const newMainContent = newWordsInMain.join(' ').trim();

                        if (newMainContent || remarkContent) { 
                            cell.textContent = (newMainContent + remarkContent).trim();
                        } else {
                            cell.textContent = ''; 
                        }
                    });
                });
                rebuildAndRenderSummary(); 
                if (selectedNameFromList === nameToDeleteStr) clearNameSelection(); 
            } catch (error) {
                console.error(`Error deleting name from shared ${currentNameListSession}:`, error);
                showMessage(`Failed to delete name from shared list. Error: ${error.message}`, "error");
            } finally {
                showNameModalLoading(false);
            }
        }
    }

    function listenToSharedNameList(sessionToListen) {
        if (!fbDb || !fbIsAuthReady) {
            console.warn(`listenToSharedNameList (${sessionToListen}): Firestore not ready.`);
            return () => {}; 
        }
        if (!appId || appId === 'default-shared-scheduler-app') { 
            console.error(`listenToSharedNameList (${sessionToListen}): Invalid appId. Cannot listen to shared names.`);
            return () => {};
        }

        const docRef = doc(fbDb, "artifacts", appId, "public/data/sharedNameLists", sessionToListen);
        return onSnapshot(docRef, (docSnap) => {
            showNameModalLoading(true);
            if (docSnap.exists()) {
                const data = docSnap.data();
                const namesFromDb = data.names || [];
                const sanitizedNames = namesFromDb.map(name => String(name || '').trim()).filter(name => name.length > 0);
                if (sessionToListen === 'pagi') namesPagiShared = sanitizedNames;
                else namesPetangShared = sanitizedNames;
            } else {
                if (sessionToListen === 'pagi') namesPagiShared = [];
                else namesPetangShared = [];
                 console.log(`No shared name list found for ${sessionToListen} under appId ${appId}. A new one will be created on save.`);
            }
            if (sessionToListen === currentNameListSession && nameModal && nameModal.style.display === 'flex' && searchNameInputElement) {
                renderNameListFromFirestore(searchNameInputElement.value);
            }
            rebuildAndRenderSummary(); 
            showNameModalLoading(false);
        }, (error) => {
            console.error(`Error listening to shared ${sessionToListen} names:`, error);
            showMessage(`Error fetching shared ${sessionToListen} names.`, "error");
            showNameModalLoading(false);
        });
    }

    // Explicit Save ("Save Shared Schedule" button)
    async function saveSharedScheduleToFirestore() {
        if (!fbDb || !fbIsAuthReady) {
            showMessage("Firebase not ready. Cannot save shared schedule.", "error"); return;
        }
        if (!tablesContainer || tablesContainer.children.length === 0) {
            showMessage('No schedule data to save.', 'info'); return;
        }
        const scheduleName = customPrompt('Enter a name for this shared schedule:', `Shared Schedule ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`);
        if (!scheduleName || scheduleName.trim() === "") {
            showMessage('Save cancelled or name is empty.', 'info'); return;
        }
        
        isAutoSaving = true; // Prevent auto-save during explicit save
        showGeneralLoading(true);
        
        const currentFullState = captureCurrentState(); // Capture full state including title
        if (!currentFullState) {
            showMessage('Error capturing page state. Cannot save.', 'error');
            isAutoSaving = false;
            showGeneralLoading(false);
            return;
        }

        const scheduleData = {
            name: scheduleName.trim(),
            html: currentFullState.html,
            meta: currentFullState.tableMeta,
            activeTableId: currentFullState.activeTableId,
            scheduleTitle: currentFullState.scheduleTitle, // Save the current page title
            createdAt: serverTimestamp(),
            lastUpdatedAt: serverTimestamp(),
            lastUpdatedBy: fbUserId || "anonymous",
            isAutoDraft: false // Explicit save is not a draft
        };

        try {
            const sharedSchedulesCollectionRef = collection(fbDb, "artifacts", appId, "public/data/sharedSchedules");
            console.log(`Explicit Save: Attempting to save schedule "${scheduleData.name}"...`);
            const newDocRef = await addDoc(sharedSchedulesCollectionRef, scheduleData);
            _updateLocalStateAfterSave(newDocRef.id, scheduleData.name, false, "explicit-save");
            
            if (sharedScheduleListContainerElement && sharedScheduleListContainerElement.style.display === 'block') {
                await loadAndRenderSharedSchedulesFromFirestore(); // Refresh list if open
            }
        } catch (error) {
            console.error("Error saving shared schedule to Firestore:", error);
            showMessage(`Failed to save shared schedule. Error: ${error.message}`, "error");
        } finally {
            isAutoSaving = false; 
            showGeneralLoading(false);
        }
    }
    
    // Autosave function (UPDATED with new state management)
    async function autoSaveCurrentSchedule() {
        if (!fbDb || !fbIsAuthReady) { 
            // console.log("AutoSave: Firebase not ready"); // Keep console logs minimal for autosave
            return; 
        }
        if (isAutoSaving) { 
            // console.log("AutoSave: Save operation already in progress");
            return;
        }
        if (!tablesContainer || tablesContainer.children.length === 0) { 
            // console.log("AutoSave: No tables to save");
            return; 
        }
        if (!isInitialStateSet) { // Check from fixes
            // console.log("AutoSave: Initial state not set yet, skipping cycle.");
            return;
        }

        const currentState = captureCurrentState(); // From fixes
        if (!currentState) {
            console.warn("AutoSave: Failed to capture current state. Skipping auto-save cycle.");
            return;
        }
        
        if (!hasStateChanged(currentState)) { // From fixes
            // console.log(`AutoSave: No changes detected. Current doc ID: ${currentWorkingScheduleDocId || 'None'}`);
            return;
        }

        isAutoSaving = true; // Set lock
        console.log(`AutoSave: Changes detected. Proceeding with save. DocID: ${currentWorkingScheduleDocId || 'NEW DRAFT'}`);

        try {
            const scheduleContentToSave = {
                html: currentState.html,
                meta: currentState.tableMeta, 
                activeTableId: currentState.activeTableId,
                scheduleTitle: currentState.scheduleTitle // Include page title
            };

            if (!currentWorkingScheduleDocId) { 
                console.log("AutoSave: No currentWorkingScheduleDocId. Creating new auto-draft.");
                const scheduleName = `Autosaved Draft (${fbUserId ? fbUserId.substring(0, 5) : 'anon'}...) - ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString([], {hour12: false, hour: '2-digit', minute: '2-digit'})}`;
                const scheduleData = {
                    name: scheduleName,
                    ...scheduleContentToSave, 
                    createdAt: serverTimestamp(),
                    lastUpdatedAt: serverTimestamp(),
                    lastUpdatedBy: fbUserId || "anonymous",
                    isAutoDraft: true
                };
                const newDocRef = await addDoc(
                    collection(fbDb, "artifacts", appId, "public/data/sharedSchedules"),
                    scheduleData
                );
                _updateLocalStateAfterSave(newDocRef.id, scheduleName, true, "auto-draft-created");
                console.log(`AutoSave (New Draft): Successfully saved to new doc ID: ${newDocRef.id}.`);
            
            } else { 
                console.log(`AutoSave (Update): Attempting to update doc ID: ${currentWorkingScheduleDocId}.`);
                const docRef = doc(fbDb, "artifacts", appId, "public/data/sharedSchedules", currentWorkingScheduleDocId);
                const docSnap = await getDoc(docRef); 
                
                if (!docSnap.exists()) {
                    console.warn(`AutoSave (Update): Document ${currentWorkingScheduleDocId} not found. Current state will be saved as a new draft next cycle.`);
                    _updateLocalStateAfterSave(null, "Previous Draft Lost", true, "doc-not-found-during-autosave"); 
                    return; 
                }

                const scheduleDataForUpdate = {
                    ...scheduleContentToSave, 
                    lastUpdatedAt: serverTimestamp(),
                    lastUpdatedBy: fbUserId || "anonymous",
                    name: docSnap.data().name, 
                    createdAt: docSnap.data().createdAt, 
                    isAutoDraft: typeof docSnap.data().isAutoDraft === 'boolean' ? docSnap.data().isAutoDraft : true // Default to true if missing
                };
                
                await setDoc(docRef, scheduleDataForUpdate, { merge: true });
                _updateLocalStateAfterSave(currentWorkingScheduleDocId, scheduleDataForUpdate.name, scheduleDataForUpdate.isAutoDraft, "auto-save-update");
                console.log(`AutoSave (Update): Successfully updated doc ID: ${currentWorkingScheduleDocId}.`);
            }
        } catch (error) {
            console.error("Auto-save error:", error);
            if (error.code === 'resource-exhausted' || error.message.toLowerCase().includes('quota')) {
                console.warn("Firestore quota exceeded or similar issue, skipping auto-save for this cycle.");
            }
            // No UI message for auto-save failures to keep it silent, errors are logged.
        } finally {
            isAutoSaving = false; // Release lock
        }
    }

    // Manual Save ("Save Current Page" button - NEW)
    async function manualSaveCurrentPage() {
        if (!fbDb || !fbIsAuthReady) {
            showMessage("Firebase not ready. Cannot save.", "error"); return;
        }
        if (!tablesContainer || tablesContainer.children.length === 0) {
            showMessage('No schedule data to save.', 'info'); return;
        }
        if (isAutoSaving) { 
            showMessage('An operation is already in progress. Please wait a moment.', 'info'); return;
        }

        isAutoSaving = true; // Use the same flag to prevent concurrent saves
        showGeneralLoading(true);

        const currentState = captureCurrentState();
        if (!currentState) {
            showMessage('Error capturing current page state. Cannot save.', 'error');
            isAutoSaving = false;
            showGeneralLoading(false);
            return;
        }

        if (!hasStateChanged(currentState)) {
            showMessage('No changes detected since last save.', 'info');
            isAutoSaving = false;
            showGeneralLoading(false);
            return;
        }

        const scheduleContentToSave = {
            html: currentState.html,
            meta: currentState.tableMeta,
            activeTableId: currentState.activeTableId,
            scheduleTitle: currentState.scheduleTitle
        };

        try {
            if (currentWorkingScheduleDocId) {
                console.log(`Manual Save (Update): Attempting to update doc ID: ${currentWorkingScheduleDocId}.`);
                const docRef = doc(fbDb, "artifacts", appId, "public/data/sharedSchedules", currentWorkingScheduleDocId);
                const docSnap = await getDoc(docRef);

                if (!docSnap.exists()) {
                    showMessage(`Error: The previously active document (ID: ${currentWorkingScheduleDocId}) no longer exists. Please use "Save Shared Schedule" to create a new named entry, or this manual save will create a new one.`, "warning", 7000);
                    currentWorkingScheduleDocId = null; // Reset, as it's invalid. This will force new doc creation below.
                     _updateLocalStateAfterSave(null, "Previous Document Lost", false, "manual-save-doc-not-found");
                     // Fall through to create new document logic
                } else {
                    let scheduleName = docSnap.data().name;
                    let isNowAutoDraft = typeof docSnap.data().isAutoDraft === 'boolean' ? docSnap.data().isAutoDraft : false;

                    if (isNowAutoDraft) {
                        const newNamePrompt = customPrompt(`This is an autosaved draft ("${scheduleName}"). Enter a new name to save it permanently, or cancel to just update the draft content.`, scheduleName.replace(/Autosaved Draft /i, "").replace(/\([\w\s.-]+\)\s*-\s*\d{1,2}\/\d{1,2}\/\d{4}.*/i, "").trim());
                        if (newNamePrompt && newNamePrompt.trim() !== "") {
                            scheduleName = newNamePrompt.trim();
                            isNowAutoDraft = false; // No longer an auto-draft
                        } else if (newNamePrompt === null) { // User cancelled prompt
                            // Keep it as a draft, just update content
                        } else { // Empty name, treat as cancel
                            // Keep as draft
                        }
                    }

                    const scheduleDataForUpdate = {
                        ...scheduleContentToSave,
                        name: scheduleName,
                        lastUpdatedAt: serverTimestamp(),
                        lastUpdatedBy: fbUserId || "anonymous",
                        createdAt: docSnap.data().createdAt, 
                        isAutoDraft: isNowAutoDraft 
                    };
                    await setDoc(docRef, scheduleDataForUpdate, { merge: true });
                    _updateLocalStateAfterSave(currentWorkingScheduleDocId, scheduleDataForUpdate.name, scheduleDataForUpdate.isAutoDraft, "manual-save");
                    if (sharedScheduleListContainerElement && sharedScheduleListContainerElement.style.display === 'block') {
                        await loadAndRenderSharedSchedulesFromFirestore(); 
                    }
                    isAutoSaving = false; // Release lock earlier if successful
                    showGeneralLoading(false);
                    return; // Exit after successful update
                }
            }
            
            // Create new document if no currentWorkingScheduleDocId or if it was found to be invalid
            const defaultNewName = `My Schedule - ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
            const scheduleNameInput = customPrompt('Enter a name for this new schedule:', defaultNewName);
            if (!scheduleNameInput || scheduleNameInput.trim() === "") {
                showMessage('Save cancelled or name is empty.', 'info'); 
                isAutoSaving = false; showGeneralLoading(false); return;
            }
            const scheduleData = {
                name: scheduleNameInput.trim(),
                ...scheduleContentToSave,
                createdAt: serverTimestamp(),
                lastUpdatedAt: serverTimestamp(),
                lastUpdatedBy: fbUserId || "anonymous",
                isAutoDraft: false // Manual save is not a draft
            };
            const newDocRef = await addDoc(collection(fbDb, "artifacts", appId, "public/data/sharedSchedules"), scheduleData);
            _updateLocalStateAfterSave(newDocRef.id, scheduleData.name, false, "manual-save");
            if (sharedScheduleListContainerElement && sharedScheduleListContainerElement.style.display === 'block') {
                await loadAndRenderSharedSchedulesFromFirestore(); 
            }
        } catch (error) {
            console.error("Error during manual save:", error);
            showMessage(`Failed to save current page. Error: ${error.message}`, "error");
        } finally {
            isAutoSaving = false;
            showGeneralLoading(false);
        }
    }


    async function loadAndRenderSharedSchedulesFromFirestore() {
        if (!fbDb || !fbIsAuthReady) {
            showMessage("Firebase not ready. Cannot load shared schedules.", "error");
            if (sharedScheduleListContainerElement) sharedScheduleListContainerElement.innerHTML = '<p>Connect to Firebase to see shared schedules.</p>';
            return;
        }
        if (!sharedScheduleListContainerElement) return;

        showGeneralLoading(true);
        sharedScheduleListContainerElement.innerHTML = '<p>Loading shared schedules from Cloud...</p>';
        let querySnapshot;
        try {
            const sharedSchedulesCollectionRef = collection(fbDb, "artifacts", appId, "public/data/sharedSchedules");
            // Try ordering by lastUpdatedAt first, then by createdAt as a fallback
            let q = query(sharedSchedulesCollectionRef, orderBy("lastUpdatedAt", "desc"));
            querySnapshot = await getDocs(q);
        } catch (error) {
            console.error("Error loading shared schedules with primary sort (lastUpdatedAt):", error);
            // If primary sort fails (e.g. index missing), try fallback.
             if (error.message.toLowerCase().includes("index")) {
                showMessage("Loading schedules (fallback sort by creation date)...", "info", 4000);
            } else {
                 showMessage("Error loading schedules. Trying fallback sort...", "info", 4000);
            }
            try {
                const sharedSchedulesCollectionRef = collection(fbDb, "artifacts", appId, "public/data/sharedSchedules");
                let qFallback = query(sharedSchedulesCollectionRef, orderBy("createdAt", "desc"));
                querySnapshot = await getDocs(qFallback);
            } catch (fallbackError) {
                console.error("Error loading shared schedules with fallback sort (createdAt):", fallbackError);
                showMessage(`Failed to load shared schedules. Error: ${fallbackError.message}`, "error");
                sharedScheduleListContainerElement.innerHTML = `<p>Error loading shared schedules. Please check console.</p>`;
                showGeneralLoading(false);
                return;
            }
        }

        const schedules = [];
        querySnapshot.forEach((docSnap) => {
            schedules.push({ id: docSnap.id, ...docSnap.data() });
        });
        renderSharedScheduleList(schedules); 
        sharedScheduleListContainerElement.style.display = 'block';
        showGeneralLoading(false);
    }

    function renderSharedScheduleList(schedulesArray) {
        if (!sharedScheduleListContainerElement) return;
        sharedScheduleListContainerElement.innerHTML = '';

        // Ensure schedules are sorted by lastUpdatedAt (desc) if available, then createdAt (desc)
        const sortedSchedules = schedulesArray.sort((a, b) => {
            const dateA = a.lastUpdatedAt?.toDate ? a.lastUpdatedAt.toDate() : (a.createdAt?.toDate ? a.createdAt.toDate() : new Date(0));
            const dateB = b.lastUpdatedAt?.toDate ? b.lastUpdatedAt.toDate() : (b.createdAt?.toDate ? b.createdAt.toDate() : new Date(0));
            return dateB - dateA; 
        });

        if (!sortedSchedules || sortedSchedules.length === 0) {
            sharedScheduleListContainerElement.innerHTML = '<p>No shared schedules saved to Cloud yet.</p>'; return;
        }

        sortedSchedules.forEach(schedule => {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'shared-schedule-item';
            let dateToShow = 'N/A';
            if (schedule.lastUpdatedAt && schedule.lastUpdatedAt.toDate) {
                dateToShow = `Updated: ${schedule.lastUpdatedAt.toDate().toLocaleString()}`;
            } else if (schedule.createdAt && schedule.createdAt.toDate) {
                dateToShow = `Created: ${schedule.createdAt.toDate().toLocaleString()}`;
            }
            const updatedByText = schedule.lastUpdatedBy ? ` (by ${schedule.lastUpdatedBy.substring(0,8)}...)` : '';
            const draftSuffix = schedule.isAutoDraft ? " (Draft)" : "";
            const displayName = `${schedule.name}${draftSuffix}`;
            itemDiv.innerHTML = `
                <span data-schedule-id="${schedule.id}" title="Load shared schedule: ${displayName}">${displayName}${updatedByText}</span>
                <span class="schedule-date">${dateToShow}</span>
                <button data-schedule-id="${schedule.id}" title="Delete shared schedule '${displayName}' from Cloud">Delete</button>
            `;
            sharedScheduleListContainerElement.appendChild(itemDiv);
        });
    }

    async function loadSelectedSharedScheduleFromFirestore(scheduleDocId, isDefaultLoad = false) {
        if (!fbDb || !fbIsAuthReady) {
            if (!isDefaultLoad) showMessage("Firebase not ready. Cannot load shared schedule.", "error");
            else console.warn("loadSelectedSharedScheduleFromFirestore: Firebase not ready for default load.");
            return false;
        }
        if (!tablesContainer || !tableTabs || !scheduleTitleElement) {
            console.error("loadSelectedSharedScheduleFromFirestore: Critical DOM elements missing.");
            return false;
        }

        showGeneralLoading(true);
        try {
            console.log(`loadSelected: Attempting to load doc ID: ${scheduleDocId}`);
            const docRef = doc(fbDb, "artifacts", appId, "public/data/sharedSchedules", scheduleDocId);
            const docSnap = await getDoc(docRef);

            if (docSnap.exists()) {
                const scheduleData = docSnap.data();
                console.log(`loadSelected: Doc ${scheduleDocId} found. Name: "${scheduleData.name}". HTML content length: ${scheduleData.html ? scheduleData.html.length : 0}`);
                
                // Set page title from loaded data
                if (typeof scheduleData.scheduleTitle === 'string') {
                    scheduleTitleElement.textContent = scheduleData.scheduleTitle;
                    localStorage.setItem(SCHEDULE_TITLE_KEY, scheduleData.scheduleTitle); // Sync with localStorage
                } else {
                    // If scheduleTitle is not in Firestore, use the schedule's name as a fallback for the title
                    // or leave it as is if already set by localStorage.
                    // For consistency, if scheduleTitle is missing, we don't automatically set it from scheduleData.name
                    // to avoid confusion between the schedule entry name and the editable page title.
                    // The user can edit the title if needed.
                }

                tablesContainer.innerHTML = scheduleData.html; 
                const tableMeta = scheduleData.meta || {}; 

                tableTabs.innerHTML = ''; 
                tablesContainer.querySelectorAll('table').forEach(table => {
                    const id = table.id;
                    const metaInfo = tableMeta[id] || {};
                    const name = metaInfo.name || `Table ${tableTabs.children.length + 1}`;
                    table.dataset.tableName = name; 
                    addTabButton(id, name); 
                    table.querySelectorAll('td, th, .merged-cell-overlay').forEach(cell => cell.contentEditable = 'true');
                });

                activeTableId = scheduleData.activeTableId || tablesContainer.querySelector('table')?.id || 'tbl_1';
                if (document.getElementById(activeTableId)) {
                    switchTable(activeTableId); 
                } else if (tablesContainer.querySelector('table')) {
                    switchTable(tablesContainer.querySelector('table').id);
                } else {
                    console.warn("Loaded schedule has no tables or activeTableId is invalid. Adding new table.");
                    addNewTable(true); 
                }
                
                // Update local state tracking AFTER DOM is updated
                _updateLocalStateAfterSave(scheduleDocId, scheduleData.name, scheduleData.isAutoDraft, "load");
                
                if (isDefaultLoad) {
                     console.log(`Default/Session schedule "${scheduleData.name}" (ID: ${scheduleDocId}) loaded successfully.`);
                }

                if (sharedScheduleListContainerElement) sharedScheduleListContainerElement.style.display = 'none'; 
                rebuildAndRenderSummary(); 
                updateAllMergeOverlays(); 
                return true;
            } else {
                console.warn(`loadSelected: Doc ID "${scheduleDocId}" not found in Cloud.`);
                if (!isDefaultLoad) showMessage(`Shared schedule with ID "${scheduleDocId}" not found in Cloud.`, "error");
                _updateLocalStateAfterSave(null, null, false, "doc-not-found-on-load"); 
                if (scheduleDocId === sessionStorage.getItem(LAST_ACTIVE_SCHEDULE_ID_KEY)) {
                    sessionStorage.removeItem(LAST_ACTIVE_SCHEDULE_ID_KEY); // Clear invalid session ID
                }
                return false;
            }
        } catch (error) {
            console.error(`loadSelected: Error loading schedule ID ${scheduleDocId} from Firestore:`, error);
            if (!isDefaultLoad) showMessage(`Failed to load shared schedule. Error: ${error.message}`, "error");
            _updateLocalStateAfterSave(null, null, false, "load-error"); 
            return false;
        } finally {
            showGeneralLoading(false);
        }
    }

    async function loadLatestSharedScheduleAsDefault() {
        if (!fbDb || !fbIsAuthReady) {
            console.log("loadLatestSharedScheduleAsDefault: Firebase not ready.");
            return false;
        }
        showGeneralLoading(true);
        
        const lastActiveId = sessionStorage.getItem(LAST_ACTIVE_SCHEDULE_ID_KEY);
        if (lastActiveId) {
            console.log(`loadLatestDefault: Found last active ID in session: ${lastActiveId}. Attempting to load.`);
            const loadedFromSession = await loadSelectedSharedScheduleFromFirestore(lastActiveId, true);
            if (loadedFromSession) {
                console.log("loadLatestDefault: Successfully loaded schedule from session storage.");
                showGeneralLoading(false);
                return true;
            } else {
                console.warn(`loadLatestDefault: Failed to load schedule ID ${lastActiveId} from session. Clearing it.`);
                sessionStorage.removeItem(LAST_ACTIVE_SCHEDULE_ID_KEY); 
            }
        } else {
            console.log("loadLatestDefault: No last active ID in session. Will try latest from DB.");
        }
        
        console.log("loadLatestDefault: Attempting to load the latest updated shared schedule from Firestore...");
        let querySnapshot;
        let loadedSuccessfully = false;

        try {
            const schedulesRef = collection(fbDb, "artifacts", appId, "public/data/sharedSchedules");
            const qPrimary = query(schedulesRef, orderBy("lastUpdatedAt", "desc"), limit(1));
            querySnapshot = await getDocs(qPrimary);

            if (!querySnapshot.empty) {
                const latestScheduleDoc = querySnapshot.docs[0];
                console.log(`loadLatestDefault: Latest schedule by lastUpdatedAt found: ID = ${latestScheduleDoc.id}, Name = ${latestScheduleDoc.data().name}`);
                loadedSuccessfully = await loadSelectedSharedScheduleFromFirestore(latestScheduleDoc.id, true);
            } else {
                console.log("loadLatestDefault: No shared schedules found by lastUpdatedAt.");
            }
        } catch (error) {
            console.error("loadLatestDefault: Error loading latest by lastUpdatedAt:", error);
            if (error.message.toLowerCase().includes("index")) {
                console.warn("loadLatestDefault: Query by lastUpdatedAt failed (index?). Trying createdAt.");
            }
            try {
                const schedulesRef = collection(fbDb, "artifacts", appId, "public/data/sharedSchedules");
                const qFallback = query(schedulesRef, orderBy("createdAt", "desc"), limit(1));
                querySnapshot = await getDocs(qFallback);
                if (!querySnapshot.empty) {
                    const latestScheduleDoc = querySnapshot.docs[0];
                    console.log(`loadLatestDefault: Latest schedule by createdAt found: ID = ${latestScheduleDoc.id}, Name = ${latestScheduleDoc.data().name}`);
                    loadedSuccessfully = await loadSelectedSharedScheduleFromFirestore(latestScheduleDoc.id, true);
                } else {
                    console.log("loadLatestDefault: No shared schedules found by createdAt either.");
                }
            } catch (fallbackError) {
                console.error("loadLatestDefault: Error loading latest by createdAt:", fallbackError);
            }
        } finally {
            showGeneralLoading(false);
        }

        if (!loadedSuccessfully) {
            console.log("loadLatestDefault: No schedule loaded from Firestore. Initial state will be set by setupInitialTableState.");
        }
        return loadedSuccessfully;
    }

    async function confirmAndDeleteSharedScheduleFromFirestore(scheduleDocId, scheduleName) {
        if (!fbDb || !fbIsAuthReady) {
            showMessage("Firebase not ready. Cannot delete shared schedule.", "error"); return;
        }
        const displayName = scheduleName.includes("(Draft)") ? scheduleName : `${scheduleName}`;
        if (await customConfirm(`Are you sure you want to delete shared schedule "${displayName}" from Cloud? This cannot be undone and affects all users.`)) {
            showGeneralLoading(true);
            try {
                const docRef = doc(fbDb, "artifacts", appId, "public/data/sharedSchedules", scheduleDocId);
                await deleteDoc(docRef);
                if (currentWorkingScheduleDocId === scheduleDocId) {
                    _updateLocalStateAfterSave(null, null, false, "deleted-current"); // Reset local state if current was deleted
                    console.log("Deleted schedule was the current working one. Cleared associated local state.");
                }
                showMessage(`Shared schedule "${scheduleName}" deleted from Cloud.`, 'success');
                await loadAndRenderSharedSchedulesFromFirestore(); 
            } catch (error) {
                console.error("Error deleting shared schedule from Firestore:", error);
                showMessage(`Failed to delete shared schedule. Error: ${error.message}`, "error");
            } finally {
                showGeneralLoading(false);
            }
        }
    }

    async function exportAllSharedSchedulesFromFirestore() {
        if (!fbDb || !fbIsAuthReady) {
            showMessage("Firebase not ready. Cannot export shared schedules.", "error"); return;
        }
        showGeneralLoading(true);
        try {
            const schedulesCollectionRef = collection(fbDb, "artifacts", appId, "public/data/sharedSchedules");
            const q = query(schedulesCollectionRef, orderBy("createdAt", "desc")); 
            const querySnapshot = await getDocs(q);
            const schedulesToExport = [];
            querySnapshot.forEach((docSnap) => {
                const data = docSnap.data();
                schedulesToExport.push({
                    name: data.name,
                    html: data.html,
                    meta: data.meta,
                    activeTableId: data.activeTableId,
                    scheduleTitle: data.scheduleTitle || null, // Include scheduleTitle
                    createdAt: data.createdAt && data.createdAt.toDate ? data.createdAt.toDate().toISOString() : null,
                    lastUpdatedAt: data.lastUpdatedAt && data.lastUpdatedAt.toDate ? data.lastUpdatedAt.toDate().toISOString() : null,
                    lastUpdatedBy: data.lastUpdatedBy || null,
                    isAutoDraft: typeof data.isAutoDraft === 'boolean' ? data.isAutoDraft : undefined 
                });
            });

            if (schedulesToExport.length === 0) {
                showMessage('No shared schedules in Cloud to export.', 'info');
                showGeneralLoading(false);
                return;
            }

            const blob = new Blob([JSON.stringify(schedulesToExport, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = `shared_schedules_${appId}_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a); a.click(); document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showMessage('All shared schedules exported successfully!', 'success');
        } catch (error) {
            console.error("Error exporting shared schedules from Firestore:", error);
            showMessage(`Failed to export shared schedules. Error: ${error.message}`, "error");
        } finally {
            showGeneralLoading(false);
        }
    }

    async function handleSharedSchedulesImport(event) {
        if (!fbDb || !fbIsAuthReady) {
            showMessage("Firebase not ready. Cannot import shared schedules.", "error"); return;
        }
        const file = event.target.files[0];
        if (!file) { showMessage('No file selected for import.', 'info'); return; }
        if (file.type !== 'application/json') {
            showMessage('Invalid file type. Please select a .json file exported from this app.', 'error');
            event.target.value = ''; 
            return;
        }

        showGeneralLoading(true);
        const reader = new FileReader();
        reader.onload = async (e) => {
            try {
                const importedSchedulesData = JSON.parse(e.target.result);
                if (!Array.isArray(importedSchedulesData)) {
                    showMessage('Invalid schedule file format. Expected an array of schedules.', 'error'); return;
                }

                let importedCount = 0, skippedCount = 0;
                const schedulesCollectionRef = collection(fbDb, "artifacts", appId, "public/data/sharedSchedules");

                for (const schedule of importedSchedulesData) {
                    if (schedule && typeof schedule.name === 'string' && typeof schedule.html === 'string' && 
                        typeof schedule.meta === 'object' && (typeof schedule.activeTableId === 'string' || schedule.activeTableId === null)) {
                        
                        const q = query(schedulesCollectionRef, where("name", "==", schedule.name));
                        const existingSnapshot = await getDocs(q);
                        
                        if (!existingSnapshot.empty) {
                             if (await customConfirm(`A shared schedule named "${schedule.name}" already exists. Overwrite?`)) {
                                for(const docToDel of existingSnapshot.docs) { 
                                    await deleteDoc(docToDel.ref);
                                }
                            } else {
                                skippedCount++;
                                continue; 
                            }
                        }
                        await addDoc(schedulesCollectionRef, {
                            name: schedule.name,
                            html: schedule.html,
                            meta: schedule.meta,
                            activeTableId: schedule.activeTableId,
                            scheduleTitle: schedule.scheduleTitle || schedule.name, // Add scheduleTitle, fallback to name
                            createdAt: schedule.createdAt ? new Date(schedule.createdAt) : serverTimestamp(), 
                            lastUpdatedAt: schedule.lastUpdatedAt ? new Date(schedule.lastUpdatedAt) : serverTimestamp(),
                            lastUpdatedBy: schedule.lastUpdatedBy || fbUserId || "anonymous",
                            isAutoDraft: typeof schedule.isAutoDraft === 'boolean' ? schedule.isAutoDraft : false 
                        });
                        importedCount++;
                    } else {
                        console.warn("Skipping invalid schedule object during import:", schedule);
                        skippedCount++;
                    }
                }
                showMessage(`Shared schedules import to Cloud: ${importedCount} imported/overwritten, ${skippedCount} skipped.`, 'success', 5000);
                if (sharedScheduleListContainerElement && (sharedScheduleListContainerElement.style.display === 'block' || importedCount > 0)) {
                    await loadAndRenderSharedSchedulesFromFirestore();
                }
            } catch (error) {
                console.error("Error processing shared schedule file for Firestore import:", error);
                showMessage('Error processing schedule file. Ensure it is a valid JSON export from this app.', 'error', 5000);
            }
            finally {
                event.target.value = ''; 
                showGeneralLoading(false);
            }
        };
        reader.onerror = () => {
            showMessage('Failed to read the schedule file.', 'error');
            event.target.value = ''; 
            showGeneralLoading(false);
        };
        reader.readAsText(file);
    }
    
    // --- Autocomplete Functions ---
    function showCellAutocompleteSuggestions(cell, inputText) {
        if (!autocompleteSuggestionsDiv) return;
        const namesForAutocomplete = currentNameListSession === 'pagi' ? namesPagiShared : namesPetangShared;
        
        let textForMatchingInput = String(inputText || '').split(' // ')[0];
        const wordsForMatching = textForMatchingInput.split(/\s+/).filter(word => !word.startsWith('*')); 
        const textForMatching = wordsForMatching.join(' ').toLowerCase().trim(); 

        if (!textForMatching) { 
            hideCellAutocompleteSuggestions();
            return;
        }

        const filteredSuggestions = namesForAutocomplete.filter(name => {
            const nameStr = String(name || '').toLowerCase().trim();
            return nameStr.startsWith(textForMatching) && nameStr !== textForMatching; 
        });

        if (filteredSuggestions.length > 0) {
            activeCellForAutocomplete = cell; 
            autocompleteSuggestionsDiv.innerHTML = ''; 
            filteredSuggestions.slice(0, 10).forEach(suggestion => { 
                const item = document.createElement('div');
                item.className = 'suggestion-item';
                item.textContent = suggestion;
                item.addEventListener('mousedown', (e) => { 
                    e.preventDefault(); 
                    selectCellAutocompleteSuggestion(suggestion);
                });
                autocompleteSuggestionsDiv.appendChild(item);
            });

            const cellRect = cell.getBoundingClientRect();
            autocompleteSuggestionsDiv.style.left = `${cellRect.left + window.scrollX}px`;
            autocompleteSuggestionsDiv.style.top = `${cellRect.bottom + window.scrollY}px`;
            autocompleteSuggestionsDiv.style.minWidth = `${cellRect.width}px`;
            autocompleteSuggestionsDiv.style.display = 'block';
            currentAutocompleteIndex = -1; 
        } else {
            hideCellAutocompleteSuggestions();
        }
    }

    function hideCellAutocompleteSuggestions() {
        if (autocompleteSuggestionsDiv) {
            autocompleteSuggestionsDiv.style.display = 'none';
        }
        activeCellForAutocomplete = null;
        currentAutocompleteIndex = -1;
    }

    function selectCellAutocompleteSuggestion(suggestionText) {
        if (activeCellForAutocomplete) {
            const targetCell = activeCellForAutocomplete; 
            const overlay = targetCell.querySelector('.merged-cell-overlay'); 
            const contentNode = overlay || targetCell; 

            const currentFullText = contentNode.textContent;
            const remarkPart = currentFullText.includes(' // ') ? currentFullText.substring(currentFullText.indexOf(' // ')) : '';
            const contentBeforeRemark = currentFullText.split(' // ')[0];
            
            const starWordsBeforeRemark = contentBeforeRemark.split(/\s+/).filter(word => word.startsWith('*')).join(' ');

            let newText = suggestionText;
            if (starWordsBeforeRemark) { 
                newText += ' ' + starWordsBeforeRemark;
            }
            newText = (newText.trim() + remarkPart).trim(); 

            contentNode.textContent = newText;
            
            hideCellAutocompleteSuggestions();
            rebuildAndRenderSummary(); 

            contentNode.focus();
            const range = document.createRange();
            const sel = window.getSelection();
            if (contentNode.childNodes.length > 0) {
                range.selectNodeContents(contentNode);
                range.collapse(false); 
            } else { 
                range.setStart(contentNode, 0);
                range.collapse(true);
            }
            sel.removeAllRanges();
            sel.addRange(range);
        }
    }
    
    function updateCellSuggestionHighlight() {
        if (!autocompleteSuggestionsDiv || autocompleteSuggestionsDiv.style.display === 'none') return;
        const items = autocompleteSuggestionsDiv.querySelectorAll('.suggestion-item');
        items.forEach((item, index) => {
            item.classList.toggle('active-suggestion', index === currentAutocompleteIndex);
        });
    }

    // --- DOMContentLoaded: Main Initialization ---
    document.addEventListener('DOMContentLoaded', () => {
        // Initialize DOM element references
        scheduleTitleElement = document.getElementById('scheduleTitle');
        tablesContainer = document.getElementById('tablesContainer');
        tableTabs = document.getElementById('tableTabs');
        nameModal = document.getElementById('nameModal');
        nameModalContent = document.getElementById('nameModalContent');
        nameModalHeader = document.getElementById('nameModalHeader');
        nameListContainer = document.getElementById('nameList');
        newNameInput = document.getElementById('newNameInput');
        sharedScheduleListContainerElement = document.getElementById('sharedScheduleListContainer');
        summaryTableElement = document.getElementById('summaryTable');
        summaryTableContainerElement = document.getElementById('summaryTableContainer');
        customMessageBox = document.getElementById('customMessageBox');
        fileInputElement = document.getElementById('fileInput');
        directCopyFullHtmlButtonElement = document.getElementById('directCopyFullHtmlBtn');
        closeNameModalButtonStandardElement = document.getElementById('closeNameModalBtnStandard');
        nameListImportFileInputElement = document.getElementById('nameListImportFile');
        searchNameInputElement = document.getElementById('searchNameInput');
        sharedScheduleImportFileInputElement = document.getElementById('sharedScheduleImportFile');
        userIdDisplayElement = document.getElementById('userIdDisplay');
        namePagiTabElement = document.getElementById('namePagiTab');
        namePetangTabElement = document.getElementById('namePetangTab');
        loadingIndicatorModalElement = document.getElementById('loadingIndicatorModal');
        nameModalTitleElement = document.getElementById('nameModalTitle');
        generalLoadingIndicatorElement = document.getElementById('generalLoadingIndicator');
        controlsTogglerElement = document.getElementById('controlsToggler');
        collapsibleButtonBarsElement = document.getElementById('collapsibleButtonBars');
        downloadPdfButtonElement = document.getElementById('downloadPdfBtn');
        pdfContentElement = document.getElementById('pdfContent');
        clearAndResetScheduleBtnElement = document.getElementById('clearAndResetScheduleBtn'); 
        manualSaveBtnElement = document.getElementById('manualSaveBtn'); 

        autocompleteSuggestionsDiv = document.createElement('div');
        autocompleteSuggestionsDiv.id = 'autocompleteSuggestions';
        document.body.appendChild(autocompleteSuggestionsDiv);
        
        // Initial state of controls toggler (now in top bar)
        if (controlsTogglerElement && collapsibleButtonBarsElement) {
            collapsibleButtonBarsElement.classList.remove('open'); 
            controlsTogglerElement.setAttribute('aria-expanded', 'false');
            const textSpan = controlsTogglerElement.querySelector('span');
            if (textSpan) textSpan.textContent = 'Show Controls'; 
        }

        // Critical DOM check
        if (!tablesContainer || !tableTabs || !nameModal || !summaryTableElement || !scheduleTitleElement || 
            !sharedScheduleListContainerElement || !generalLoadingIndicatorElement || !summaryTableContainerElement || 
            !controlsTogglerElement || !collapsibleButtonBarsElement || !downloadPdfButtonElement || 
            !pdfContentElement || !clearAndResetScheduleBtnElement || !manualSaveBtnElement) {
            console.error("CRITICAL DOM elements missing. App cannot initialize correctly. Please check HTML structure and element IDs.");
            document.body.innerHTML = "<p style='color:red; text-align:center; font-size:1.2em;'>Error: Application failed to initialize due to missing critical page elements. Please check the console for details.</p>";
            return;
        }
        
        // Firebase Auth State Change Listener
        if (fbAuth) {
            onAuthStateChanged(fbAuth, async (user) => {
                if (user) {
                    fbUserId = user.uid;
                    fbIsAuthReady = true;
                    if(userIdDisplayElement) userIdDisplayElement.textContent = `User ID: ${fbUserId}`;
                    console.log("Firebase Auth: User is signed in.", fbUserId);

                    // Initialize Firestore listeners for shared names
                    if (unsubscribePagiShared) unsubscribePagiShared();
                    if (unsubscribePetangShared) unsubscribePetangShared();
                    unsubscribePagiShared = listenToSharedNameList('pagi');
                    unsubscribePetangShared = listenToSharedNameList('petang');

                    // If name modal is open, refresh its content
                    if (nameModal && nameModal.style.display === 'flex' && searchNameInputElement) {
                        renderNameListFromFirestore(searchNameInputElement.value);
                    }
                    
                    // Load latest or default schedule
                    const loadedDefault = await loadLatestSharedScheduleAsDefault();
                    if (!loadedDefault) { 
                        // If nothing was loaded from Firestore (no session, no latest), setup default tables
                        setupInitialTableState(); 
                    }
                    // At this point, the DOM (tablesContainer & scheduleTitle) is populated.

                    // Initialize state tracking AFTER content is loaded/set up
                    lastSavedState = captureCurrentState();
                    isInitialStateSet = true; // Mark initial state as set
                    if (lastSavedState === null) { // Check if capture failed
                        console.error("CRITICAL: Initial state capture failed after auth and content setup. Autosave and change detection might not work correctly.");
                        showMessage("Error: Could not capture initial page state. Autosave may be unreliable.", "error", 7000);
                    } else {
                         console.log("Initial state captured successfully after auth and content setup.");
                    }
                    
                    rebuildAndRenderSummary(); 

                    // Start auto-save interval
                    if (autoSaveIntervalId) clearInterval(autoSaveIntervalId); 
                    autoSaveIntervalId = setInterval(autoSaveCurrentSchedule, AUTO_SAVE_INTERVAL);
                    console.log("Auto-save interval started after auth and initial content setup.");

                } else { // User is signed out
                    fbIsAuthReady = false; fbUserId = null;
                    if(userIdDisplayElement) userIdDisplayElement.textContent = "User ID: Authenticating...";
                    console.log("Firebase Auth: User is signed out. Attempting to sign in...");
                    try {
                        if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token && __initial_auth_token.trim() !== '') {
                            console.log("Firebase Auth: Attempting signInWithCustomToken.");
                            await signInWithCustomToken(fbAuth, __initial_auth_token);
                        } else {
                            console.log("Firebase Auth: Attempting signInAnonymously.");
                            await signInAnonymously(fbAuth);
                        }
                    } catch (error) {
                        console.error("Firebase Auth: Error during sign-in:", error);
                        showMessage(`Firebase Auth failed. Cloud features may not work. Error: ${error.message}`, "error", 7000);
                        if(userIdDisplayElement) userIdDisplayElement.textContent = `User ID: Auth Error`;
                        
                        // Setup default table state if auth fails, so app is usable locally
                        setupInitialTableState();
                        lastSavedState = captureCurrentState(); // Capture this default state
                        isInitialStateSet = true;
                        if (lastSavedState === null) console.error("CRITICAL: Initial state capture failed after auth failure. Local changes might not be tracked.");
                        else console.log("Initial state captured for local mode after auth failure.");
                        rebuildAndRenderSummary();
                    }
                }
            });
        } else { // fbAuth object itself is not available
             if(userIdDisplayElement) userIdDisplayElement.textContent = "User ID: Firebase Auth Not Initialized";
             console.error("Firebase Auth: fbAuth object is not available. Firebase did not initialize correctly.");
             showMessage("Critical Error: Firebase Auth service could not be initialized. Cloud features are disabled.", "error", 10000);
             
             // Setup default table state for local use
             setupInitialTableState(); 
             lastSavedState = captureCurrentState(); 
             isInitialStateSet = true;
             if (lastSavedState === null) console.error("CRITICAL: Initial state capture failed due to Firebase init error.");
             else console.log("Initial state captured for local mode due to Firebase init error.");
             rebuildAndRenderSummary();
        }

        loadScheduleTitleFromLocalStorage(); // Load page title from localStorage (might be overwritten by Firestore load)
        initializeEventListeners(); 
        handleNameListSessionSwitch('pagi'); // Set initial name list session
    });

    function setupInitialTableState() {
        console.log("Running setupInitialTableState (called when no specific schedule is loaded from session/DB).");
        const existingTables = tablesContainer.querySelectorAll('table');
        
        tableTabs.innerHTML = ''; 
        activeTableId = null; 
        // currentWorkingScheduleDocId, lastSavedState are managed by the calling context or _updateLocalStateAfterSave

        if (existingTables.length > 0) {
            console.log("setupInitialTableState: Found existing tables in HTML. Setting them up.");
            existingTables.forEach((table, index) => {
                const id = table.id || `tbl_html_${index + 1}`; 
                if (!table.id) table.id = id;
                const name = table.dataset.tableName || `Sheet ${index + 1}`;
                table.dataset.tableName = name; 
                addTabButton(id, name);
                if (index === 0) { 
                    activeTableId = id;
                }
                table.querySelectorAll('td, th, .merged-cell-overlay').forEach(cell => cell.contentEditable = 'true');
            });
            if (activeTableId) {
                switchTable(activeTableId);
            } else if (existingTables[0]) { 
                switchTable(existingTables[0].id);
            }
        } else {
            console.warn("setupInitialTableState: No tables found in HTML, adding a new default table.");
            addNewTable(true); // This will call switchTable and set activeTableId
        }
        
        console.log("setupInitialTableState: DOM updated with initial/default tables.");
        // The calling function (DOMContentLoaded or reset handler) is responsible for updating
        // lastSavedState via _updateLocalStateAfterSave after this function completes.
    }

    function loadScheduleTitleFromLocalStorage() {
        const savedTitle = localStorage.getItem(SCHEDULE_TITLE_KEY);
        if (savedTitle && scheduleTitleElement) {
            scheduleTitleElement.textContent = savedTitle;
        }
        if (scheduleTitleElement) {
            scheduleTitleElement.addEventListener('blur', () => {
                localStorage.setItem(SCHEDULE_TITLE_KEY, scheduleTitleElement.textContent);
                // No UI message for local title save to reduce noise.
                // Change in title will be picked up by hasStateChanged for cloud save.
            });
        }
    }

    function initializeEventListeners() {
        // Top action buttons (already referenced)
        if(controlsTogglerElement) controlsTogglerElement.addEventListener('click', toggleButtonBarsVisibility);
        if(manualSaveBtnElement) manualSaveBtnElement.addEventListener('click', manualSaveCurrentPage);
        if(downloadPdfButtonElement) downloadPdfButtonElement.addEventListener('click', generateSchedulePdf);
        
        // Other buttons in collapsible bar
        if(directCopyFullHtmlButtonElement) directCopyFullHtmlButtonElement.addEventListener('click', attemptDirectCopyToClipboard);
        
        if(closeNameModalButtonStandardElement) closeNameModalButtonStandardElement.addEventListener('click', closeNameModal);
        if(nameModalHeader) { 
            nameModalHeader.addEventListener('mousedown', startDragModal);
            nameModalHeader.addEventListener('touchstart', startDragModal, { passive: false }); 
        }
        document.addEventListener('mousemove', dragModal);
        document.addEventListener('mouseup', stopDragModal);
        document.addEventListener('touchmove', dragModal, { passive: false });
        document.addEventListener('touchend', stopDragModal);

        document.getElementById('excelBtnTrigger')?.addEventListener('click', exportActiveTableToExcel);
        document.getElementById('importExcelBtn')?.addEventListener('click', () => fileInputElement?.click());
        if(fileInputElement) fileInputElement.addEventListener('change', handleExcelFileImport);

        document.getElementById('saveSharedScheduleBtn')?.addEventListener('click', saveSharedScheduleToFirestore);
        document.getElementById('loadSharedScheduleBtn')?.addEventListener('click', loadAndRenderSharedSchedulesFromFirestore);
        document.getElementById('exportSharedSchedulesBtn')?.addEventListener('click', exportAllSharedSchedulesFromFirestore);
        document.getElementById('importSharedSchedulesBtn')?.addEventListener('click', () => sharedScheduleImportFileInputElement?.click());
        if(sharedScheduleImportFileInputElement) sharedScheduleImportFileInputElement.addEventListener('change', handleSharedSchedulesImport);
        
        if(sharedScheduleListContainerElement) sharedScheduleListContainerElement.addEventListener('click', async (e) => {
            const targetSpan = e.target.closest('.shared-schedule-item span[data-schedule-id]');
            const targetButton = e.target.closest('.shared-schedule-item button[data-schedule-id]');
            if (targetSpan) { 
                loadSelectedSharedScheduleFromFirestore(targetSpan.dataset.scheduleId);
            } else if (targetButton) { 
                const scheduleId = targetButton.dataset.scheduleId;
                const scheduleNameElement = targetButton.parentElement.querySelector('span[data-schedule-id]');
                const scheduleName = scheduleNameElement ? scheduleNameElement.textContent.split(' (by')[0] : 'this schedule'; 
                await confirmAndDeleteSharedScheduleFromFirestore(scheduleId, scheduleName);
            }
        });

        if(clearAndResetScheduleBtnElement) clearAndResetScheduleBtnElement.addEventListener('click', async () => {
            if (await customConfirm("Are you sure you want to clear everything and start a new schedule? This will clear the current view and any unsaved auto-draft associations.")) {
                tablesContainer.innerHTML = ''; 
                tableTabs.innerHTML = ''; 
                activeTableId = null;
                if (scheduleTitleElement) scheduleTitleElement.textContent = "Jadual Anjal"; // Reset title
                localStorage.removeItem(SCHEDULE_TITLE_KEY); // Clear stored title
                
                addNewTable(true); // Add a new blank table. This calls switchTable.
                
                // Update local state tracking for the new blank state
                _updateLocalStateAfterSave(null, "New Schedule (Reset)", false, "reset-all"); 
                
                console.log("Clear & New: State reset. lastSavedState updated to new blank table state.");
                
                rebuildAndRenderSummary(); 
                showMessage('All content cleared. New schedule started.', 'success');
            }
        });
        document.getElementById('selectBtn')?.addEventListener('click', toggleCellSelectionMode);
        document.getElementById('mergeBtn')?.addEventListener('click', mergeSelectedTableCells);
        document.getElementById('deselectBtn')?.addEventListener('click', deselectAllTableCells);
        document.getElementById('unmergeBtn')?.addEventListener('click', unmergeActiveCellIfMerged);
        document.getElementById('addTableBtn')?.addEventListener('click', () => addNewTable());
        document.getElementById('renameTableBtn')?.addEventListener('click', promptAndRenameActiveTable);
        document.getElementById('deleteTableBtn')?.addEventListener('click', confirmAndDeleteActiveTable);

        document.getElementById('addRowAboveBtn')?.addEventListener('click', addRowAboveToActiveTable);
        document.getElementById('addRowBelowBtn')?.addEventListener('click', addRowBelowToActiveTable);
        document.getElementById('addColLeftBtn')?.addEventListener('click', addColumnLeftToActiveTable);
        document.getElementById('addColRightBtn')?.addEventListener('click', addColumnRightToActiveTable);
        document.getElementById('deleteRowBtn')?.addEventListener('click', deleteClickedRowFromActiveTable);
        document.getElementById('deleteColBtn')?.addEventListener('click', deleteClickedColumnFromActiveTable);

        document.getElementById('nameListBtn')?.addEventListener('click', toggleNameListModalVisibility);
        document.getElementById('addNameBtnInModal')?.addEventListener('click', () => {
            if(newNameInput) addNameToSharedSessionInFirestore(newNameInput.value);
        });
        document.getElementById('importNameListBtn')?.addEventListener('click', () => nameListImportFileInputElement?.click());
        if(nameListImportFileInputElement) nameListImportFileInputElement.addEventListener('change', handleNameListImportFirestore);
        if(searchNameInputElement) searchNameInputElement.addEventListener('input', (e) => renderNameListFromFirestore(e.target.value));
        if(namePagiTabElement) namePagiTabElement.addEventListener('click', () => handleNameListSessionSwitch('pagi'));
        if(namePetangTabElement) namePetangTabElement.addEventListener('click', () => handleNameListSessionSwitch('petang'));
        
        if(nameListContainer) nameListContainer.addEventListener('click', async (e) => {
            const nameItemSpan = e.target.closest('.name-item span[data-name]');
            const deleteButton = e.target.closest('.name-item button[data-name-delete]');
            if (nameItemSpan) { 
                selectNameForCellInsertion(nameItemSpan.dataset.name);
            } else if (deleteButton) { 
                await deleteNameFromSharedSessionInFirestore(deleteButton.dataset.nameDelete);
            }
        });

        if(tablesContainer) {
            tablesContainer.addEventListener('click', handleTableCellClick);
            tablesContainer.addEventListener('input', (e) => {
                const cell = e.target; 
                const targetElement = cell.classList.contains('merged-cell-overlay') ? cell.parentElement : cell;

                if (targetElement && (targetElement.tagName === 'TD' || (targetElement.tagName === 'TH' && targetElement.closest('tbody'))) && targetElement.isContentEditable !== false) {
                    const text = cell.textContent; 
                    const isHeaderCellInTHead = targetElement.tagName === 'TH' && targetElement.closest('thead');
                    const isFirstColumnClassHeader = targetElement.closest('table')?.querySelector('thead th:first-child')?.textContent?.toLowerCase() === 'class' && targetElement.cellIndex === 0;

                    if (!isHeaderCellInTHead && !isFirstColumnClassHeader) {
                         showCellAutocompleteSuggestions(targetElement, text); 
                    } else {
                        hideCellAutocompleteSuggestions();
                    }
                    // No immediate rebuildAndRenderSummary on every input to avoid lag.
                    // Autosave will pick up changes. Blur event also triggers summary.
                }
            });

            tablesContainer.addEventListener('blur', (e) => {
                const cell = e.target;
                const targetElement = cell.classList.contains('merged-cell-overlay') ? cell.parentElement : cell;

                if (targetElement && (targetElement.tagName === 'TD' || targetElement.tagName === 'TH' || cell.classList.contains('merged-cell-overlay')) && targetElement.isContentEditable !== false) {
                    setTimeout(rebuildAndRenderSummary, 0); // Rebuild summary after cell loses focus
                    // Delay hiding autocomplete to allow click on suggestion
                    setTimeout(() => {
                        if (autocompleteSuggestionsDiv && autocompleteSuggestionsDiv.style.display === 'block' &&
                            !autocompleteSuggestionsDiv.contains(document.activeElement) && 
                            activeCellForAutocomplete !== document.activeElement && 
                            (!activeCellForAutocomplete || activeCellForAutocomplete.querySelector('.merged-cell-overlay') !== document.activeElement) 
                           ) {
                           hideCellAutocompleteSuggestions();
                        }
                    }, 150); 
                }
            }, true); // Use capture phase for blur
        }
        
        window.addEventListener('resize', () => { 
            updateAllMergeOverlays();
            hideCellAutocompleteSuggestions();
        });

        // Keyboard navigation for autocomplete suggestions
        document.addEventListener('keydown', (e) => {
            if (autocompleteSuggestionsDiv && autocompleteSuggestionsDiv.style.display === 'block' && activeCellForAutocomplete) {
                const items = autocompleteSuggestionsDiv.querySelectorAll('.suggestion-item');
                if (items.length === 0 && e.key !== 'Escape') return; 

                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    currentAutocompleteIndex = (currentAutocompleteIndex + 1) % items.length;
                    updateCellSuggestionHighlight();
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    currentAutocompleteIndex = (currentAutocompleteIndex - 1 + items.length) % items.length;
                    updateCellSuggestionHighlight();
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    if (currentAutocompleteIndex >= 0 && currentAutocompleteIndex < items.length) {
                        selectCellAutocompleteSuggestion(items[currentAutocompleteIndex].textContent);
                    } else { 
                        hideCellAutocompleteSuggestions();
                        if(activeCellForAutocomplete) activeCellForAutocomplete.blur(); // Move focus out
                    }
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    hideCellAutocompleteSuggestions();
                } else if (e.key === 'Tab') { 
                    // Allow tab to naturally move focus, which should hide suggestions via blur or click outside
                    hideCellAutocompleteSuggestions();
                }
            }
        });

        // Click outside autocomplete to hide
        document.addEventListener('click', (event) => {
            if (autocompleteSuggestionsDiv && autocompleteSuggestionsDiv.style.display === 'block') {
                const isClickInsideCell = activeCellForAutocomplete && activeCellForAutocomplete.contains(event.target);
                const isClickInsideOverlay = activeCellForAutocomplete && activeCellForAutocomplete.querySelector('.merged-cell-overlay')?.contains(event.target);
                const isClickInsideSuggestions = autocompleteSuggestionsDiv.contains(event.target);

                if (!isClickInsideCell && !isClickInsideSuggestions && !isClickInsideOverlay) {
                    hideCellAutocompleteSuggestions();
                }
            }
        });
    }

    // --- Modal Dragging Functions ---
    function startDragModal(e) {
        if (e.target.closest('.modal-close-btn')) { isDraggingModal = false; return; }
        isDraggingModal = true;
        if(nameModalContent) nameModalContent.classList.add('dragging'); 
        const clientX = e.clientX || (e.touches && e.touches[0].clientX);
        const clientY = e.clientY || (e.touches && e.touches[0].clientY);
        const rect = nameModalContent.getBoundingClientRect();
        // Temporarily set position to fixed to allow dragging outside of initial centering
        nameModalContent.style.position = 'fixed'; 
        nameModalContent.style.left = `${rect.left}px`; // Set current position
        nameModalContent.style.top = `${rect.top}px`;
        nameModalContent.style.transform = 'none'; // Remove centering transform
        modalDragOffsetX = clientX - nameModalContent.offsetLeft;
        modalDragOffsetY = clientY - nameModalContent.offsetTop;
        if (e.type === 'touchstart') e.preventDefault(); 
    }

    function dragModal(e) {
        if (!isDraggingModal || !nameModalContent) return;
        const clientX = e.clientX || (e.touches && e.touches[0].clientX);
        const clientY = e.clientY || (e.touches && e.touches[0].clientY);
        let newLeft = clientX - modalDragOffsetX;
        let newTop = clientY - modalDragOffsetY;
        
        // Boundary checks
        const modalRect = nameModalContent.getBoundingClientRect(); // Get current dimensions
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        if (newLeft < 0) newLeft = 0;
        if (newTop < 0) newTop = 0;
        if (newLeft + modalRect.width > viewportWidth) newLeft = viewportWidth - modalRect.width;
        if (newTop + modalRect.height > viewportHeight) newTop = viewportHeight - modalRect.height;

        nameModalContent.style.left = `${newLeft}px`;
        nameModalContent.style.top = `${newTop}px`;
        if (e.type === 'touchmove') e.preventDefault(); 
    }

    function stopDragModal() {
        if (isDraggingModal && nameModalContent) {
            isDraggingModal = false;
            nameModalContent.classList.remove('dragging');
            // Optionally, could revert to original centering styles if desired,
            // but leaving it positioned where dragged is often fine.
        }
    }

    // --- Clipboard & Export/Import Functions ---
    async function attemptDirectCopyToClipboard() {
        const fullHtml = document.documentElement.outerHTML;
        try {
            await navigator.clipboard.writeText(fullHtml);
            showMessage('Full HTML copied to clipboard!', 'success');
        } catch (err) {
            console.warn('Direct copy to clipboard failed, trying fallback (document.execCommand):', err);
            const textarea = document.createElement('textarea');
            textarea.value = fullHtml;
            textarea.style.position = 'fixed'; textarea.style.left = '-9999px'; 
            document.body.appendChild(textarea);
            textarea.select();
            try {
                const success = document.execCommand('copy');
                if (success) {
                    showMessage('Full HTML copied! (fallback method)', 'success');
                } else {
                    showMessage('Direct copy using execCommand failed. Could not copy.', 'error', 5000);
                }
            } catch (execErr) {
                console.error('execCommand copy failed:', execErr);
                showMessage('Direct copy failed completely. Could not copy.', 'error', 5000);
            }
            document.body.removeChild(textarea);
        }
    }
    
    // --- Table Management Functions (Tabs, Add, Rename, Delete) ---
    function addTabButton(id, label) {
        if (!tableTabs) return null;
        const button = document.createElement('button');
        button.textContent = label; button.dataset.tableId = id;
        button.title = `Switch to table: ${label}`;
        button.onclick = () => switchTable(id);
        tableTabs.appendChild(button);
        return button;
    }

    function switchTable(id) {
        const targetTable = document.getElementById(id);
        if (!targetTable && tablesContainer) {
            // Fallback if target table ID doesn't exist (e.g., after a bad load or manual DOM manipulation)
            const firstTableInDOM = tablesContainer.querySelector('table');
            if (firstTableInDOM) {
                id = firstTableInDOM.id; 
                console.warn(`SwitchTable: Target table for original ID not found, falling back to first table in DOM: ${id}.`);
            } else {
                // If no tables exist at all
                if (tablesContainer && tablesContainer.children.length === 0) {
                    console.log("SwitchTable: No tables exist, adding a new one.");
                    addNewTable(true); // Add a new table and it will become active
                    return; // Exit as addNewTable will handle switching
                }
                console.error(`SwitchTable: Target table for original ID not found and no fallback available.`);
                return;
            }
        } else if (!targetTable) {
             console.error(`SwitchTable: Target table for ID ${id} not found and tablesContainer is also missing.`);
             return;
        }

        activeTableId = id;
        if(tablesContainer) tablesContainer.querySelectorAll('table').forEach(t => t.classList.toggle('active', t.id === id));
        if(tableTabs) tableTabs.querySelectorAll('button').forEach(b => { b.classList.toggle('active', b.dataset.tableId === id); });
        
        deselectAllTableCells(); 
        rebuildAndRenderSummary(); 
        updateAllMergeOverlays(); 
        hideCellAutocompleteSuggestions(); 
        // Note: Switching tables is a change that should be picked up by hasStateChanged for autosave
    }

    function addNewTable(isInitial = false) {
        if (!tablesContainer || !tableTabs) {
            console.error("addNewTable: Critical DOM elements missing (tablesContainer or tableTabs).");
            return;
        }
        tableCount++; 
        const defaultTableName = `Schedule ${tableTabs.children.length + 1}`;
        const label = isInitial ? defaultTableName : customPrompt('Enter new table name:', defaultTableName);

        if (!label && !isInitial) { 
            showMessage('Table creation cancelled.', 'info');
            return;
        }

        const newTable = document.createElement('table');
        newTable.id = `tbl_${Date.now()}_${tableCount}`; 
        newTable.dataset.tableName = label || defaultTableName; 

        const thead = newTable.createTHead();
        const headerRow = thead.insertRow();
        const defaultHeaders = ['Class/Time', '08:00-09:00', '09:00-10:00', '10:00-11:00', '11:00-12:00', '12:00-13:00'];
        defaultHeaders.forEach(headerText => {
            const th = document.createElement('th');
            th.contentEditable = 'true'; th.textContent = headerText;
            headerRow.appendChild(th);
        });

        const tbody = newTable.createTBody();
        for (let r = 0; r < 2; r++) { 
            const dataRow = tbody.insertRow();
            for (let c = 0; c < headerRow.cells.length; c++) {
                const td = dataRow.insertCell(); td.contentEditable = 'true';
                if (c === 0) td.textContent = `Sample Class ${String.fromCharCode(65 + r)}`; 
            }
        }

        tablesContainer.appendChild(newTable);
        addTabButton(newTable.id, label || defaultTableName);
        switchTable(newTable.id); // Make the new table active

        if (!isInitial) {
            showMessage(`Table "${label || defaultTableName}" added.`, 'success');
            // Change will be picked up by autosave via hasStateChanged
        } else {
            console.log(`Initial table "${label || defaultTableName}" created with ID ${newTable.id}.`);
        }
    }

    async function promptAndRenameActiveTable() {
        if (!tableTabs) return;
        const currentTab = tableTabs.querySelector('button.active');
        if (!currentTab) { showMessage('No active table to rename.', 'error'); return; }

        let tableIdToRename = currentTab.dataset.tableId;
        // Fallback if dataset.tableId is somehow missing (shouldn't happen with addTabButton)
        if (!tableIdToRename) {
            const match = currentTab.getAttribute('onclick')?.match(/'(tbl_.*?)'/);
            if (match && match[1]) tableIdToRename = match[1];
            else { showMessage('Could not identify table ID for renaming.', 'error'); return; }
        }
        
        const tableElement = document.getElementById(tableIdToRename);
        if (!tableElement) { showMessage(`Table element for ID ${tableIdToRename} not found.`, 'error'); return; }

        const oldName = tableElement.dataset.tableName || currentTab.textContent;
        const newName = customPrompt('Enter new table name:', oldName);

        if (newName && newName.trim() && newName.trim() !== oldName) {
            const trimmedNewName = newName.trim();
            currentTab.textContent = trimmedNewName; currentTab.title = `Switch to table: ${trimmedNewName}`;
            tableElement.dataset.tableName = trimmedNewName; 
            showMessage(`Table renamed to "${trimmedNewName}".`, 'success');
            // Change will be picked up by autosave
        } else if (newName && newName.trim() === oldName) {
            showMessage('Name unchanged.', 'info');
        } else if (newName === null) { 
            showMessage('Rename cancelled.', 'info');
        } else { 
            showMessage('Invalid new name.', 'error');
        }
    }

    async function confirmAndDeleteActiveTable() {
        if (!tablesContainer || !tableTabs || tablesContainer.children.length <= 1) {
            showMessage('Cannot delete the last table.', 'error'); return;
        }
        const activeTab = tableTabs.querySelector('button.active');
        const tableIdToDelete = activeTab?.dataset.tableId;
        const tableElement = tableIdToDelete ? document.getElementById(tableIdToDelete) : null;
        const tableName = tableElement?.dataset.tableName || activeTab?.textContent || 'the active table';

        if (await customConfirm(`Delete table "${tableName}"? This cannot be undone.`)) {
            if (tableElement) tableElement.remove(); 
            else if (document.getElementById(activeTableId)) document.getElementById(activeTableId).remove(); 
            activeTab?.remove(); 

            const firstRemainingTab = tableTabs.querySelector('button');
            if (firstRemainingTab) {
                const nextActiveId = firstRemainingTab.dataset.tableId || firstRemainingTab.getAttribute('onclick').match(/'(tbl_.*?)'/)[1];
                switchTable(nextActiveId);
            } else {
                // This case should ideally not be reached if tablesContainer.children.length > 1 check is correct
                activeTableId = null;
                console.log("Last table deleted (unexpected). Adding a new default table.");
                addNewTable(true); 
            }
            showMessage(`Table "${tableName}" deleted.`, 'success');
            // Change will be picked up by autosave
        }
    }

    // --- Row/Column Manipulation Functions ---
    function addRowToTable(tableBody, rowIndex, numCols) {
        const row = tableBody.insertRow(rowIndex); 
        for (let i = 0; i < numCols; i++) {
            const cell = row.insertCell(); cell.contentEditable = 'true';
        }
    }
    function addRowAboveToActiveTable() {
        const table = document.getElementById(activeTableId);
        if (!table || !table.tBodies[0] || table.rows.length === 0) return;
        const numCols = table.rows[0].cells.length; 
        let insertAtIndex = (lastClickedCell && lastClickedCell.closest('tbody') && lastClickedCell.parentElement.rowIndex >= 0) 
                            ? lastClickedCell.parentElement.rowIndex 
                            : 0; // Default to top if no cell clicked or header clicked
        addRowToTable(table.tBodies[0], insertAtIndex, numCols);
        rebuildAndRenderSummary(); updateAllMergeOverlays(); // Autosave will pick up change
    }
    function addRowBelowToActiveTable() {
        const table = document.getElementById(activeTableId);
        if (!table || !table.tBodies[0] || table.rows.length === 0) return;
        const numCols = table.rows[0].cells.length;
        let insertAtIndex = (lastClickedCell && lastClickedCell.closest('tbody') && lastClickedCell.parentElement.rowIndex >= 0) 
                            ? lastClickedCell.parentElement.rowIndex + 1 
                            : -1; // Default to end if no cell clicked or header clicked
        addRowToTable(table.tBodies[0], insertAtIndex, numCols);
        rebuildAndRenderSummary(); updateAllMergeOverlays(); // Autosave
    }

    function addColumnToTable(table, colIndex) { 
        for (const row of table.rows) {
            const isHeaderRow = row.parentElement.tagName === 'THEAD';
            const cell = isHeaderRow ? document.createElement('th') : row.insertCell(colIndex === -1 ? row.cells.length : colIndex);
            cell.contentEditable = 'true';
            if (isHeaderRow) {
                cell.textContent = "New Header";
                // For header, if not appending, insertBefore is needed
                if (colIndex !== -1 && row.cells[colIndex] && isHeaderRow) {
                     row.insertBefore(cell, row.cells[colIndex]);
                } else if (isHeaderRow && colIndex === -1) { // Appending to header
                    row.appendChild(cell);
                }
            }
        }
    }
    function addColumnLeftToActiveTable() {
        const table = document.getElementById(activeTableId);
        if (!table) return;
        let insertAtIndex = (lastClickedCell && lastClickedCell.cellIndex >= 0) 
                            ? lastClickedCell.cellIndex 
                            : 0; // Default to far left
        addColumnToTable(table, insertAtIndex);
        rebuildAndRenderSummary(); updateAllMergeOverlays(); // Autosave
    }
    function addColumnRightToActiveTable() {
        const table = document.getElementById(activeTableId);
        if (!table) return;
        let insertAtIndex = (lastClickedCell && lastClickedCell.cellIndex >= 0) 
                            ? lastClickedCell.cellIndex + 1 
                            : -1; // Default to far right (append)
        addColumnToTable(table, insertAtIndex);
        rebuildAndRenderSummary(); updateAllMergeOverlays(); // Autosave
    }

    async function deleteClickedRowFromActiveTable() {
        if (!lastClickedCell) { showMessage('Click a cell in the row to delete.', 'info'); return; }
        const table = document.getElementById(activeTableId);
        if (!table || !table.tBodies[0]) { showMessage('No active table body.', 'error'); return; }
        
        const rowToDelete = lastClickedCell.closest('tr');
        if (!rowToDelete || rowToDelete.parentElement.tagName !== 'TBODY') { 
            showMessage('Cannot delete header. Click a data row cell.', 'error'); return;
        }
        if (table.tBodies[0].rows.length <= 1) { 
            showMessage('Cannot delete the last data row.', 'error'); return;
        }
        if (await customConfirm('Delete this row?')) {
            rowToDelete.remove(); lastClickedCell = null; 
            deselectAllTableCells(); 
            rebuildAndRenderSummary(); updateAllMergeOverlays(); // Autosave
            showMessage('Row deleted.', 'success');
        }
    }
    async function deleteClickedColumnFromActiveTable() {
        if (!lastClickedCell) { showMessage('Click a cell in the column to delete.', 'info'); return; }
        const table = document.getElementById(activeTableId);
        if (!table) { showMessage('No active table.', 'error'); return; }
        if (table.rows[0] && table.rows[0].cells.length <= 1) { 
            showMessage('Cannot delete the last column.', 'error'); return;
        }
        
        const colIndexToDelete = lastClickedCell.cellIndex;
        if (await customConfirm('Delete this column?')) {
            for (const row of table.rows) {
                if (row.cells[colIndexToDelete]) row.cells[colIndexToDelete].remove();
            }
            lastClickedCell = null; deselectAllTableCells(); 
            rebuildAndRenderSummary(); updateAllMergeOverlays(); // Autosave
            showMessage('Column deleted.', 'success');
        }
    }

    // --- Cell Selection & Merging Functions ---
    function toggleCellSelectionMode() {
        selectionMode = !selectionMode;
        const btn = document.getElementById('selectBtn');
        if(btn) {
            btn.classList.toggle('active', selectionMode);
            btn.textContent = selectionMode ? '‚ú® Selecting...' : '‚ú® Select Cells';
        }
        if (!selectionMode) deselectAllTableCells(); 
        hideCellAutocompleteSuggestions(); 
    }

    function handleTableCellClick(event) {
        const cell = event.target.closest('td, th'); 
        if (!cell || !cell.closest(`#${activeTableId}`)) return; 

        lastClickedCell = cell; 

        // Hide autocomplete if clicking a different cell while suggestions are open
        if (autocompleteSuggestionsDiv && autocompleteSuggestionsDiv.style.display === 'block' &&
            !autocompleteSuggestionsDiv.contains(event.target) && activeCellForAutocomplete !== cell) {
            hideCellAutocompleteSuggestions();
        }

        if (selectedNameFromList) { // If a name is selected from the list for insertion
            if (cell.tagName === 'TD' || (cell.tagName === 'TH' && cell.closest('tbody'))) { // Ensure it's a data cell
                const overlay = cell.querySelector('.merged-cell-overlay');
                const contentNode = overlay || cell; 
                
                const currentCellText = contentNode.textContent;
                const remarkPart = currentCellText.includes(' // ') ? currentCellText.substring(currentCellText.indexOf(' // ')) : '';
                const contentBeforeRemark = currentCellText.split(' // ')[0];
                const starWords = contentBeforeRemark.split(/\s+/).filter(w => w.startsWith('*')).join(' ');

                let newText = selectedNameFromList;
                if (starWords) { 
                    newText += ' ' + starWords; // Preserve existing starred items
                }
                newText = (newText.trim() + remarkPart).trim(); // Add back remark

                contentNode.textContent = newText;
                
                rebuildAndRenderSummary(); // Update summary
                showMessage(`Inserted "${selectedNameFromList}".`, 'success', 2500);
                clearNameSelection(); // Clear selection after insertion
                // Change will be picked up by autosave
            } else {
                showMessage('Click an editable data cell to insert name.', 'info');
            }
            return; // Exit after handling name insertion
        }

        if (selectionMode) {
            // Prevent selecting cells that are part of a different merge or subsumed
            if (cell.classList.contains('subsumed-cell') ||
                (cell.classList.contains('merged-cell-container') && selectedCells.some(sc => sc !== cell && sc.dataset.mergeId !== cell.dataset.mergeId))) {
                showMessage('Cannot select subsumed cells or mix merge groups.', 'warning'); return;
            }
            cell.classList.toggle('selected'); 
            if (cell.classList.contains('selected')) selectedCells.push(cell);
            else selectedCells = selectedCells.filter(c => c !== cell); 
        }
    }

    function deselectAllTableCells() {
        selectedCells.forEach(c => c.classList.remove('selected'));
        selectedCells = [];
    }

    function mergeSelectedTableCells() {
        if (selectedCells.length < 2) { showMessage('Select at least two cells to merge.', 'error'); return; }
        if (selectedCells.some(cell => cell.dataset.mergeId)) {
            showMessage('Cannot merge already merged cells. Unmerge first.', 'warning'); return;
        }

        // Determine primary cell (top-leftmost)
        let primaryCell = selectedCells[0];
        let minRowGUI = primaryCell.parentElement.getBoundingClientRect().top;
        let minColGUI = primaryCell.getBoundingClientRect().left;
        selectedCells.forEach(cell => { 
            const cellRowRect = cell.parentElement.getBoundingClientRect();
            const cellRect = cell.getBoundingClientRect();
            if (cellRowRect.top < minRowGUI || (cellRowRect.top === minRowGUI && cellRect.left < minColGUI)) {
                primaryCell = cell; minRowGUI = cellRowRect.top; minColGUI = cellRect.left;
            }
        });

        // Calculate total width and height of the merged area
        let minLeft = Infinity, maxRight = -Infinity, minTop = Infinity, maxBottom = -Infinity;
        selectedCells.forEach(cell => {
            const rect = cell.getBoundingClientRect();
            minLeft = Math.min(minLeft, rect.left); maxRight = Math.max(maxRight, rect.right);
            minTop = Math.min(minTop, rect.top); maxBottom = Math.max(maxBottom, rect.bottom);
        });
        const totalWidth = maxRight - minLeft; const totalHeight = maxBottom - minTop;

        const mergeId = `merge-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`; 

        const overlay = document.createElement('div');
        overlay.className = 'merged-cell-overlay';
        overlay.textContent = primaryCell.textContent; // Content from primary cell
        overlay.contentEditable = 'true';
        overlay.style.setProperty('--merged-width', `${totalWidth}px`);
        overlay.style.setProperty('--merged-height', `${totalHeight}px`);
        overlay.addEventListener('blur', () => { rebuildAndRenderSummary(); /* Autosave will pick up */ }); 
        overlay.addEventListener('input', (e) => { 
            const text = e.target.textContent;
            const parentCellForOverlay = e.target.parentElement; 
            // Trigger autocomplete for overlay if it's a data cell
            if (parentCellForOverlay && (parentCellForOverlay.cellIndex > 0 || parentCellForOverlay.closest('table')?.querySelector('thead th:first-child')?.textContent?.toLowerCase() !== 'class')) {
                 showCellAutocompleteSuggestions(parentCellForOverlay, text);
            } else {
                 hideCellAutocompleteSuggestions();
            }
            // Autosave will pick up change
        });

        primaryCell.innerHTML = ''; // Clear primary cell
        primaryCell.appendChild(overlay); 
        primaryCell.classList.add('merged-cell-container');
        primaryCell.setAttribute('data-merge-id', mergeId);

        // Mark other selected cells as subsumed
        selectedCells.forEach(cell => {
            if (cell !== primaryCell) {
                cell.textContent = ''; // Clear content
                cell.classList.add('subsumed-cell');
                cell.setAttribute('data-merge-id', mergeId);
            }
        });

        deselectAllTableCells(); 
        if (selectionMode) toggleCellSelectionMode(); // Turn off selection mode after merge
        showMessage('Cells visually merged.', 'success');
        // Autosave will pick up changes
    }

    function unmergeActiveCellIfMerged() {
        const cell = lastClickedCell; 
        if (!cell) { showMessage('Click a merged cell to unmerge.', 'info'); return; }

        const containerCell = cell.closest('[data-merge-id]'); // Find the cell with merge-id (could be the cell itself or a parent if clicked on overlay)
        if (!containerCell) { showMessage('Clicked cell is not part of a merge.', 'error'); return; }

        const mergeId = containerCell.dataset.mergeId;
        const table = containerCell.closest('table');
        if (!table) return;

        const cellsInGroup = table.querySelectorAll(`[data-merge-id="${mergeId}"]`);
        let originalText = '';
        // Find the primary cell of this group to get the text
        const primaryCellInGroup = Array.from(cellsInGroup).find(c => c.classList.contains('merged-cell-container'));
        if (primaryCellInGroup) {
            const overlay = primaryCellInGroup.querySelector('.merged-cell-overlay');
            if (overlay) originalText = overlay.textContent;
            else originalText = primaryCellInGroup.textContent; // Fallback if overlay somehow missing
        }

        // Reset all cells in the group
        cellsInGroup.forEach(c => {
            c.removeAttribute('data-merge-id');
            c.classList.remove('merged-cell-container', 'subsumed-cell');
            const overlayChild = c.querySelector('.merged-cell-overlay'); 
            if (overlayChild) overlayChild.remove();
            c.innerHTML = ''; // Clear content before potentially re-adding
        });

        // Restore text to the primary cell (or first cell if primary somehow not found)
        if (primaryCellInGroup) primaryCellInGroup.textContent = originalText;
        else if (cellsInGroup.length > 0) cellsInGroup[0].textContent = originalText; 

        rebuildAndRenderSummary(); 
        showMessage('Cells unmerged.', 'success');
        // Autosave will pick up changes
    }

    function updateAllMergeOverlays() {
        const activeTable = document.getElementById(activeTableId);
        if (!activeTable) return;

        const mergedContainers = activeTable.querySelectorAll('.merged-cell-container');
        mergedContainers.forEach(containerCell => {
            const mergeId = containerCell.dataset.mergeId; if (!mergeId) return;
            const overlay = containerCell.querySelector('.merged-cell-overlay'); if (!overlay) return;

            const cellsInGroup = Array.from(activeTable.querySelectorAll(`[data-merge-id="${mergeId}"]`));
            if (cellsInGroup.length === 0) return; 

            let minLeft = Infinity, maxRight = -Infinity, minTop = Infinity, maxBottom = -Infinity;
            cellsInGroup.forEach(cellInvolved => {
                const rect = cellInvolved.getBoundingClientRect();
                minLeft = Math.min(minLeft, rect.left); maxRight = Math.max(maxRight, rect.right);
                minTop = Math.min(minTop, rect.top); maxBottom = Math.max(maxBottom, rect.bottom);
            });

            if (minLeft === Infinity) return; // Should not happen if cellsInGroup is not empty

            overlay.style.setProperty('--merged-width', `${maxRight - minLeft}px`);
            overlay.style.setProperty('--merged-height', `${maxBottom - minTop}px`);
        });
    }

    // --- Name List Modal Functions ---
    function handleNameListSessionSwitch(session) {
        currentNameListSession = session;
        if(namePagiTabElement) namePagiTabElement.classList.toggle('active', session === 'pagi');
        if(namePetangTabElement) namePetangTabElement.classList.toggle('active', session === 'petang');
        if(nameModalTitleElement) nameModalTitleElement.textContent = `Shared Name List Manager (${session === 'pagi' ? 'Pagi' : 'Petang'})`;
        if(searchNameInputElement) searchNameInputElement.value = ''; // Clear search on tab switch
        renderNameListFromFirestore(); // Re-render list for the new session
        hideCellAutocompleteSuggestions(); // Hide any cell suggestions
    }

    function highlightSelectedNameInList(nameToHighlight) {
        if (!nameListContainer) return;
        const nameToHighlightStr = String(nameToHighlight || '');
        nameListContainer.querySelectorAll('.name-item span').forEach(span => {
            span.classList.toggle('highlighted', String(span.dataset.name || '') === nameToHighlightStr);
        });
    }

    function clearNameSelection() {
        selectedNameFromList = null;
        if (nameListContainer) {
            nameListContainer.querySelectorAll('.name-item span.highlighted').forEach(span => {
                span.classList.remove('highlighted');
            });
        }
    }

    function closeNameModal() {
        if (nameModal) nameModal.style.display = 'none';
        clearNameSelection(); 
        if(searchNameInputElement) searchNameInputElement.value = ''; 
    }

    function toggleNameListModalVisibility() {
        if (!nameModal || !nameModalContent || !newNameInput) return;
        const isDisplayed = nameModal.style.display === 'flex';
        if (isDisplayed) {
            closeNameModal();
        } else {
            // Reset modal position before showing (in case it was dragged)
            nameModalContent.style.position = 'relative'; // Revert from fixed if dragged
            nameModalContent.style.left = 'auto'; nameModalContent.style.top = 'auto';
            nameModalContent.style.transform = 'none'; // Ensure it's centered by flex

            nameModal.style.display = 'flex';
            if(searchNameInputElement) searchNameInputElement.value = ''; 
            handleNameListSessionSwitch(currentNameListSession); // Ensure correct session is shown
            if(newNameInput) newNameInput.focus(); 
            clearNameSelection(); 
        }
        hideCellAutocompleteSuggestions(); 
    }

    function renderNameListFromFirestore(filterText = '') {
        if (!nameListContainer) return;
        if (!fbIsAuthReady) { 
            nameListContainer.innerHTML = '<p style="text-align:center; grid-column: 1 / -1;">Loading shared names...</p>'; return;
        }

        nameListContainer.innerHTML = ''; 
        const namesToRender = currentNameListSession === 'pagi' ? namesPagiShared : namesPetangShared;
        const normalizedFilterText = String(filterText || '').toLowerCase().trim();

        if (!Array.isArray(namesToRender)) { 
            nameListContainer.innerHTML = '<p style="text-align:center; color:red;">Error: Shared name list data invalid.</p>'; return;
        }

        const filteredNames = namesToRender.filter(name => String(name || '').toLowerCase().trim().includes(normalizedFilterText));

        if (filteredNames.length === 0) {
            nameListContainer.innerHTML = `<p style="text-align:center; grid-column: 1 / -1;">${normalizedFilterText ? 'No names match.' : `No names in shared ${currentNameListSession} session.`}</p>`; return;
        }

        filteredNames.forEach(name => {
            const itemDiv = document.createElement('div'); itemDiv.className = 'name-item';
            const nameStr = String(name || '');
            const safeNameAttr = nameStr.replace(/"/g, '&quot;'); // Sanitize for attribute
            itemDiv.innerHTML = `<span data-name="${safeNameAttr}" title="Select '${safeNameAttr}'">${nameStr}</span><button data-name-delete="${safeNameAttr}" title="Delete '${safeNameAttr}' from shared list">Delete</button>`;
            nameListContainer.appendChild(itemDiv);
        });
        highlightSelectedNameInList(selectedNameFromList); // Re-apply highlight if a name was selected
    }

    function selectNameForCellInsertion(name) {
        selectedNameFromList = String(name || '');
        highlightSelectedNameInList(selectedNameFromList); 
        showMessage(`Selected "${selectedNameFromList}". Click a cell to insert.`, 'info', 4000);
    }

    function handleNameListImportFirestore(event) {
        const file = event.target.files[0];
        if (!file) { showMessage('No file selected.', 'info'); return; }
        if (file.type !== 'text/plain') { 
            showMessage('Invalid file type (.txt only).', 'error');
            event.target.value = ''; 
            return;
        }
        const reader = new FileReader();
        reader.onload = async (e) => {
            try {
                const importedNames = e.target.result.split(/\r?\n/).map(n => String(n||'').trim()).filter(n => n);
                if (importedNames.length === 0) { showMessage('No names in file.', 'info'); return; }
                
                const currentSessionNames = (currentNameListSession === 'pagi' ? namesPagiShared : namesPetangShared).map(n => String(n||'').trim());
                // Combine and remove duplicates, then save
                const combinedNames = [...new Set([...currentSessionNames, ...importedNames])];
                
                await saveSharedNameListToFirestore(currentNameListSession, combinedNames); 
                // Firestore listener will update the UI (namesPagiShared/namesPetangShared and renderNameListFromFirestore)
            } catch (error) { showMessage('Error processing name list file.', 'error'); }
            finally { event.target.value = ''; } // Reset file input
        };
        reader.onerror = () => { showMessage('Failed to read name list file.', 'error'); event.target.value = ''; };
        reader.readAsText(file);
    }

    // --- Excel Import/Export ---
    function handleExcelFileImport(event) {
        const file = event.target.files[0];
        if (!file || !tablesContainer) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const workbook = XLSX.read(new Uint8Array(e.target.result), { type: 'array' });
                const sheetName = workbook.SheetNames[0]; // Import only the first sheet
                const worksheet = workbook.Sheets[sheetName];
                const htmlTableString = XLSX.utils.sheet_to_html(worksheet, { raw: false }); 

                tableCount++; 
                const newTableId = `tbl_imported_${Date.now()}_${tableCount}`;
                const importedTableName = file.name.replace(/\.xlsx?$/i, '') || `Imported ${tableCount}`; 

                const tempDiv = document.createElement('div'); tempDiv.innerHTML = htmlTableString;
                const importedTableElement = tempDiv.querySelector('table');

                if (importedTableElement) {
                    importedTableElement.id = newTableId;
                    importedTableElement.dataset.tableName = importedTableName;
                    importedTableElement.querySelectorAll('td, th, .merged-cell-overlay').forEach(cell => cell.contentEditable = 'true');
                    
                    tablesContainer.appendChild(importedTableElement);
                    addTabButton(newTableId, importedTableName);
                    switchTable(newTableId); 
                    showMessage('Excel data imported!', 'success');
                    // Change will be picked up by autosave
                } else showMessage('Could not parse table from Excel.', 'error');
            } catch (error) { showMessage('Error processing Excel file.', 'error'); console.error("Excel import error:", error); }
            finally { event.target.value = ''; } // Reset file input
        };
        reader.readAsArrayBuffer(file);
    }

    function exportActiveTableToExcel() {
        const tableToExport = document.getElementById(activeTableId);
        if (!tableToExport) { showMessage('No active table to export.', 'error'); return; }

        // Temporarily replace merged cell overlays with their text content for export
        const overlaysData = [];
        tableToExport.querySelectorAll('.merged-cell-overlay').forEach(overlay => {
            const parentCell = overlay.parentElement;
            overlaysData.push({ parent: parentCell, originalHTML: parentCell.innerHTML }); 
            parentCell.textContent = overlay.textContent; // Replace HTML with text
        });

        const tableName = tableToExport.dataset.tableName || activeTableId;
        const wb = XLSX.utils.table_to_book(tableToExport, { sheet: tableName });
        XLSX.writeFile(wb, `${tableName}_${new Date().toISOString().split('T')[0]}.xlsx`); 

        // Restore original merged cell HTML
        overlaysData.forEach(data => {
            data.parent.innerHTML = data.originalHTML;
            // Re-attach event listeners if they were on the overlay itself and got removed
            const newOverlay = data.parent.querySelector('.merged-cell-overlay');
            if (newOverlay) { 
                newOverlay.addEventListener('blur', () => rebuildAndRenderSummary());
                newOverlay.addEventListener('input', (e) => {
                    const text = e.target.textContent;
                    const parentCellForOverlay = e.target.parentElement;
                    if (parentCellForOverlay && (parentCellForOverlay.cellIndex > 0 || parentCellForOverlay.closest('table')?.querySelector('thead th:first-child')?.textContent?.toLowerCase() !== 'class')) {
                        showCellAutocompleteSuggestions(parentCellForOverlay, text);
                    } else {
                        hideCellAutocompleteSuggestions();
                    }
                });
            }
        });
        if(overlaysData.length > 0) updateAllMergeOverlays(); // Ensure overlays are correctly sized after restoration

        showMessage(`Table "${tableName}" exported.`, 'success');
    }

    // --- PDF Generation ---
    async function generateSchedulePdf() {
        if (!pdfContentElement || !tablesContainer || !scheduleTitleElement) {
            showMessage('PDF generation elements not found.', 'error');
            return;
        }

        showGeneralLoading(true);
        showMessage('Generating PDF, please wait...', 'info', 15000); 
        pdfContentElement.innerHTML = ''; // Clear previous PDF content

        const tablesToPrint = tablesContainer.querySelectorAll('table'); 
        const numTables = tablesToPrint.length;

        if (numTables === 0) { // Handle case with no tables
            const pageWrapper = document.createElement('div');
            pageWrapper.className = 'pdf-page-wrapper';
            const mainTitleText = scheduleTitleElement.textContent || 'Weekly Schedule';
            const mainTitleH2 = document.createElement('h2');
            mainTitleH2.textContent = mainTitleText;
            pageWrapper.appendChild(mainTitleH2);
            const noTablesMessage = document.createElement('p');
            noTablesMessage.textContent = "No tables available to print.";
            noTablesMessage.style.textAlign = "center";
            pageWrapper.appendChild(noTablesMessage);
            const footnoteDiv = document.createElement('div');
            footnoteDiv.className = 'pdf-footnote';
            const today = new Date();
            const dateOptions = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
            footnoteDiv.textContent = `Generated on: ${today.toLocaleDateString(undefined, dateOptions)}`;
            pageWrapper.appendChild(footnoteDiv);
            pdfContentElement.appendChild(pageWrapper);
        } else {
            tablesToPrint.forEach((tableElement, index) => {
                const pageWrapper = document.createElement('div');
                pageWrapper.className = 'pdf-page-wrapper';

                // Add main schedule title only on the first page
                if (index === 0) {
                    const mainTitleText = scheduleTitleElement.textContent || 'Weekly Schedule';
                    const mainTitleH2 = document.createElement('h2');
                    mainTitleH2.textContent = mainTitleText;
                    pageWrapper.appendChild(mainTitleH2);
                }

                const tableId = tableElement.id;
                const tableName = tableElement.dataset.tableName || tableId || `Table ${index + 1}`;
                
                const tableTitleH3 = document.createElement('h3');
                tableTitleH3.textContent = tableName;
                pageWrapper.appendChild(tableTitleH3);

                const clonedTable = cloneTableForPdf(tableElement); 
                if (clonedTable) {
                    pageWrapper.appendChild(clonedTable);
                } else {
                    const errorMsg = document.createElement('p');
                    errorMsg.textContent = `Error: Table "${tableName}" could not be generated.`;
                    pageWrapper.appendChild(errorMsg);
                }

                // Add footnote to each page
                const footnoteDiv = document.createElement('div');
                footnoteDiv.className = 'pdf-footnote';
                const today = new Date();
                const dateOptions = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
                footnoteDiv.textContent = `Generated on: ${today.toLocaleDateString(undefined, dateOptions)}`;
                pageWrapper.appendChild(footnoteDiv);

                pdfContentElement.appendChild(pageWrapper);
            });
        }

        pdfContentElement.style.display = 'block'; // Make content visible for html2pdf

        const pdfOptions = {
            margin: [5, 5, 5, 5], // margins [top, left, bottom, right] in mm
            filename: `${(scheduleTitleElement.textContent || 'schedule').replace(/[^a-z0-9]/gi, '_').toLowerCase()}_complete.pdf`,
            image: { type: 'jpeg', quality: 0.95 }, 
            html2canvas: {
                scale: 2, 
                useCORS: true,
                logging: false, 
                scrollX: 0, 
                scrollY: -window.scrollY, // Try to capture from top of document
                windowWidth: pdfContentElement.scrollWidth, 
                windowHeight: pdfContentElement.scrollHeight, 
                removeContainer: true // Clean up temporary canvas
            },
            jsPDF: { unit: 'mm', format: 'a4', orientation: 'landscape' },
            pagebreak: { mode: ['css', 'legacy'], before: '.pdf-page-wrapper:not(:first-child)', avoid: ['h2', 'h3', 'table', 'tr', 'thead', 'tbody', '.pdf-footnote'] }
        };

        try {
            await html2pdf().from(pdfContentElement).set(pdfOptions).save();
            showMessage('PDF downloaded successfully!', 'success');
        } catch (error) {
            console.error('Error generating PDF with html2pdf:', error);
            showMessage(`Failed to generate PDF. Error: ${error.message}. Check console.`, 'error', 10000);
        } finally {
            pdfContentElement.style.display = 'none'; // Hide after processing
            showGeneralLoading(false);
        }
    }

    function cloneTableForPdf(originalTable) {
        if (!originalTable || typeof originalTable.cloneNode !== 'function') {
            console.error("cloneTableForPdf Error: Invalid originalTable provided:", originalTable);
            return null;
        }
        const tableIdForLog = originalTable.id || 'Unknown ID';

        const clonedTable = originalTable.cloneNode(true); 
        clonedTable.removeAttribute('id'); 
        clonedTable.classList.remove('active'); 
        clonedTable.style.width = '100%'; 
        clonedTable.style.tableLayout = 'fixed'; // Important for PDF layout

        // Remove contenteditable attributes
        clonedTable.querySelectorAll('[contenteditable="true"]').forEach(el => {
            el.removeAttribute('contenteditable');
        });

        // Process merged cells: convert overlays to rowspan/colspan
        const mergeGroups = {}; // Store info about each merge group
        // First pass: identify all cells in each merge group and the primary cell
        Array.from(originalTable.rows).forEach((originalRow, rowIndex) => {
            Array.from(originalRow.cells).forEach((originalCell, colIndex) => {
                const mergeId = originalCell.dataset.mergeId;
                if (!mergeId) return; // Not part of a merge

                if (!mergeGroups[mergeId]) { // Initialize group if new
                    mergeGroups[mergeId] = {
                        minRow: rowIndex, maxRow: rowIndex,
                        minCol: colIndex, maxCol: colIndex,
                        primaryCellOriginal: null, // The original cell that holds the .merged-cell-container
                        allOriginalCellsInGroup: [] // All original cells involved in this mergeId
                    };
                }
                const group = mergeGroups[mergeId];
                group.allOriginalCellsInGroup.push(originalCell);
                // Expand boundaries of the merge group
                group.minRow = Math.min(group.minRow, rowIndex);
                group.maxRow = Math.max(group.maxRow, rowIndex);
                group.minCol = Math.min(group.minCol, colIndex);
                group.maxCol = Math.max(group.maxCol, colIndex);

                if (originalCell.classList.contains('merged-cell-container')) {
                    group.primaryCellOriginal = originalCell;
                }
            });
        });

        // Second pass: apply rowspan/colspan to the cloned primary cell and remove subsumed cells
        for (const mergeId in mergeGroups) {
            const group = mergeGroups[mergeId];
            if (!group.primaryCellOriginal) {
                console.warn(`cloneTableForPdf (${tableIdForLog}): No primary cell found for mergeId: ${mergeId}. Skipping this merge group.`);
                continue;
            }

            const rowSpan = group.maxRow - group.minRow + 1;
            const colSpan = group.maxCol - group.minCol + 1;

            // Find the corresponding primary cell in the cloned table
            // This requires knowing its original row/col index
            let primaryCellOriginalRowIndex = -1;
            let primaryCellOriginalColIndex = -1;
            Array.from(originalTable.rows).forEach((r, rIdx) => {
                Array.from(r.cells).forEach((c, cIdx) => {
                     if (c === group.primaryCellOriginal) {
                        primaryCellOriginalRowIndex = rIdx;
                        primaryCellOriginalColIndex = cIdx;
                    }
                });
            });
            
            if (primaryCellOriginalRowIndex === -1 || primaryCellOriginalColIndex === -1) {
                console.warn(`cloneTableForPdf (${tableIdForLog}): Could not find original primary cell's indices for mergeId ${mergeId}. Skipping.`);
                continue;
            }
            
            const clonedPrimaryCell = clonedTable.rows[primaryCellOriginalRowIndex]?.cells[primaryCellOriginalColIndex];

            if (clonedPrimaryCell) {
                // Get text from the overlay of the original primary cell
                const overlayOriginal = group.primaryCellOriginal.querySelector('.merged-cell-overlay');
                clonedPrimaryCell.textContent = overlayOriginal ? overlayOriginal.textContent : group.primaryCellOriginal.textContent;

                // Remove overlay structure from cloned cell
                const overlayCloned = clonedPrimaryCell.querySelector('.merged-cell-overlay');
                if (overlayCloned) overlayCloned.remove();
                clonedPrimaryCell.classList.remove('merged-cell-container'); // Remove container class

                // Apply rowspan and colspan
                if (rowSpan > 1) clonedPrimaryCell.rowSpan = rowSpan;
                if (colSpan > 1) clonedPrimaryCell.colSpan = colSpan;

                // Identify and remove subsumed cells from the cloned table
                const cellsToRemoveFromClonedTable = [];
                group.allOriginalCellsInGroup.forEach(originalSubsumedCell => {
                    if (originalSubsumedCell === group.primaryCellOriginal) return; // Don't remove the primary cell itself

                    // Find originalSubsumedCell's indices to locate it in the cloned table
                    let subsumedOriginalRowIndex = -1;
                    let subsumedOriginalColIndex = -1;
                     Array.from(originalTable.rows).forEach((r, rIdx) => {
                        Array.from(r.cells).forEach((c, cIdx) => {
                             if (c === originalSubsumedCell) {
                                subsumedOriginalRowIndex = rIdx;
                                subsumedOriginalColIndex = cIdx;
                            }
                        });
                    });

                    if (subsumedOriginalRowIndex !== -1 && subsumedOriginalColIndex !== -1) {
                         const clonedSubsumedCell = clonedTable.rows[subsumedOriginalRowIndex]?.cells[subsumedOriginalColIndex];
                         // Ensure it's not the primary cell again and it exists
                         if (clonedSubsumedCell && clonedSubsumedCell !== clonedPrimaryCell) { 
                            cellsToRemoveFromClonedTable.push(clonedSubsumedCell);
                         }
                    }
                });
                cellsToRemoveFromClonedTable.forEach(cell => cell.remove());
            } else {
                 console.warn(`cloneTableForPdf (${tableIdForLog}): Cloned primary cell not found for mergeId: ${mergeId} at original cloned indices [${primaryCellOriginalRowIndex},${primaryCellOriginalColIndex}]`);
            }
        }
        return clonedTable;
    }

    // --- Summary Table Functions ---
    function getTextForSummary(cellText) { 
        if (typeof cellText !== 'string') return '';
        let textForSummary = cellText.split(' // ')[0]; // Get content before " // "
        // Remove words starting with '*'
        const words = textForSummary.split(/\s+/);
        const filteredWords = words.filter(word => !word.startsWith('*'));
        return filteredWords.join(' ').trim();
    }

    function rebuildAndRenderSummary() {
        const scheduledNames = new Set(); 
        if (tablesContainer) {
            tablesContainer.querySelectorAll('table').forEach(scheduleTable => { 
                if (!scheduleTable.tBodies[0]) return; 
                scheduleTable.tBodies[0].querySelectorAll('tr').forEach(row => {
                    Array.from(row.cells).forEach((cell, cellIndex) => {
                        // Skip first column (usually class/time headers)
                        if (cellIndex > 0) { 
                            const overlay = cell.querySelector('.merged-cell-overlay');
                            const nameFromCell = String(overlay ? overlay.textContent : cell.textContent || '').trim();
                            const actualNameForSummary = getTextForSummary(nameFromCell); 
                            if (actualNameForSummary) {
                                scheduledNames.add(actualNameForSummary);
                            }
                        }
                    });
                });
            });
        }
        // Sort names alphabetically for consistent summary table row order
        const allSummaryNames = [...scheduledNames].sort((a, b) => String(a).localeCompare(String(b), undefined, { sensitivity: 'base' }));
        
        buildSummaryTableSkeleton(allSummaryNames); // Rebuild skeleton with current headers and names
        updateSummaryTableData(allSummaryNames); // Populate with data
    }

    function parseTimeToMinutes(timeStr) { 
        if (typeof timeStr !== 'string') return Infinity; // Non-string cannot be parsed
        // Try to match HH:MM or HH.MM format, possibly with range like HH:MM-HH:MM
        const match = timeStr.match(/^(\d{1,2})\s*[:.]\s*(\d{2})/); 
        if (match) return parseInt(match[1], 10) * 60 + parseInt(match[2], 10);
        return Infinity; // Return Infinity if not parsable to ensure non-time headers sort last
    }

    function buildSummaryTableSkeleton(allAvailableNames) {
        if (!summaryTableElement) {
            console.error("buildSummaryTableSkeleton: summaryTableElement not found.");
            return;
        }
        summaryTableElement.innerHTML = ''; // Clear existing summary

        // Get headers from the currently active table for the summary columns
        let activeTableHeaders = [];
        const activeTableElement = document.getElementById(activeTableId);
        if (activeTableElement && activeTableElement.tHead && activeTableElement.tHead.rows.length > 0) {
            // Start from the second header cell (index 1), skipping the first (Class/Time)
            for (let hIdx = 1; hIdx < activeTableElement.tHead.rows[0].cells.length; hIdx++) {
                const headerText = String(activeTableElement.tHead.rows[0].cells[hIdx].textContent || '').trim();
                if (headerText) activeTableHeaders.push(headerText);
            }
        }

        // Special rule for LAU/LISAH: if they are in 10.30-12.00, add a 10.15-10.30 slot
        let laulisahRuleRequiresSpecialSlot = false;
        const specialNamesForRule = ["LAU", "LISAH"]; // Names that trigger the rule
        const targetSlotForSpecialNamesRule = "10.15-10.30"; // Slot to add/use
        const sourceSlotToShiftRule = "10.30-12.00"; // Slot that triggers the shift

        // Check all tables for the LAU/LISAH rule condition
        if (tablesContainer) {
            for (const scheduleTable of tablesContainer.querySelectorAll('table')) { // Iterate over ALL tables
                if (laulisahRuleRequiresSpecialSlot) break; // Stop if rule already triggered
                if (!scheduleTable.tHead?.rows.length > 0 || !scheduleTable.tBodies[0]) continue;
                
                const currentScheduleTableHeaders = Array.from(scheduleTable.tHead.rows[0].cells).map(th => String(th.textContent||'').trim());
                
                Array.from(scheduleTable.tBodies[0].rows).forEach((scheduleDataRow) => {
                    if (laulisahRuleRequiresSpecialSlot) return;
                    for (let cellIdx = 1; cellIdx < scheduleDataRow.cells.length; cellIdx++) {
                         const scheduleCell = scheduleDataRow.cells[cellIdx];
                         let entryInScheduleCellFull = String(scheduleCell.querySelector('.merged-cell-overlay')?.textContent || scheduleCell.textContent||'').trim();
                         let entryInScheduleCellForRule = getTextForSummary(entryInScheduleCellFull); // Get the name part
                         
                         if (specialNamesForRule.includes(entryInScheduleCellForRule)) { 
                            const headerText = currentScheduleTableHeaders[cellIdx];
                            // Normalize header text for comparison (remove spaces, use . for time)
                            if (headerText && headerText.replace(/\s/g, "").replace(/:/g,".") === sourceSlotToShiftRule.replace(/\s/g, "").replace(/:/g,".")) {
                                laulisahRuleRequiresSpecialSlot = true; return; // Rule triggered
                            }
                         }
                    }
                });
            }
        }
        
        // Combine headers from active table and the special slot if needed
        let combinedHeaders = new Set(activeTableHeaders); // Start with active table's headers
        if (laulisahRuleRequiresSpecialSlot) {
            combinedHeaders.add(targetSlotForSpecialNamesRule); // Add the special slot
        }

        // Sort all unique headers by time
        let sortedUniqueHeaders = Array.from(combinedHeaders).sort((a, b) => {
            const timeA = parseTimeToMinutes(a); const timeB = parseTimeToMinutes(b);
            if (timeA !== Infinity && timeB !== Infinity) return timeA - timeB; // Sort by time
            if (timeA !== Infinity) return -1; // Times before non-times
            if (timeB !== Infinity) return 1;  // Non-times after times
            return String(a).localeCompare(String(b)); // Alphabetical for non-times
        });

        const finalSummaryColumnHeaders = ['Nama/Masa', ...sortedUniqueHeaders]; 

        const thead = summaryTableElement.createTHead();
        const headerRowForSummary = thead.insertRow();
        finalSummaryColumnHeaders.forEach(headerText => {
            const th = document.createElement('th'); th.textContent = headerText;
            headerRowForSummary.appendChild(th);
        });

        const tbody = summaryTableElement.createTBody();
        if (allAvailableNames.length === 0 && sortedUniqueHeaders.length === 0) { 
            const tr = tbody.insertRow(); const td = tr.insertCell();
            td.textContent = "No names scheduled and no time slots defined in active table.";
            td.colSpan = finalSummaryColumnHeaders.length || 1;
            td.style.textAlign = 'center'; td.style.fontStyle = 'italic';
        } else if (allAvailableNames.length === 0) { 
            const tr = tbody.insertRow(); const td = tr.insertCell();
            td.textContent = "No names scheduled yet.";
            td.colSpan = finalSummaryColumnHeaders.length || 1;
            td.style.textAlign = 'center'; td.style.fontStyle = 'italic';
        } else { 
            allAvailableNames.forEach(name => {
                const tr = tbody.insertRow();
                tr.insertCell().textContent = String(name || ''); // Name in the first column
                // Add empty cells for each time slot; they will be populated by updateSummaryTableData
                for (let i = 1; i < finalSummaryColumnHeaders.length; i++) tr.insertCell().textContent = ''; 
            });
        }
    }

    function updateSummaryTableData(allAvailableNames) {
        if (!summaryTableElement?.tBodies?.[0] || !summaryTableElement.tHead?.rows?.[0]) {
            // console.warn("updateSummaryTableData: Summary table structure not ready.");
            return;
        }
        const summaryBody = summaryTableElement.tBodies[0];
        // If the first row is a placeholder message (colSpan > 1), don't try to update data cells
        if (summaryBody.rows.length === 0 && !(summaryBody.rows[0]?.cells[0]?.colSpan > 1)) {
            // console.warn("updateSummaryTableData: Summary table body has no data rows.");
            return;
        }

        // Get the actual headers displayed in the summary table for mapping
        const summaryTableDisplayHeaders = Array.from(summaryTableElement.tHead.rows[0].cells).map(th => String(th.textContent||'').trim());
        // Normalize summary headers for lookup (e.g., "08:00-09:00" -> "08.00-09.00" without spaces)
        const normalizedSummaryHeadersForLookup = summaryTableDisplayHeaders.map(h => h.replace(/\s/g, "").replace(/:/g,"."));

        // Clear previous data and conflict highlights from summary cells
        Array.from(summaryBody.rows).forEach(summaryRow => {
            if (summaryRow.cells.length > 1) Array.from(summaryRow.cells).slice(1).forEach(cell => {
                cell.textContent = ''; cell.classList.remove('highlight-conflict'); 
            });
        });

        // Iterate over ALL tables in tablesContainer to populate the summary
        if (tablesContainer) {
            tablesContainer.querySelectorAll('table').forEach(scheduleTable => {
                if (!scheduleTable.tHead?.rows.length > 0 || !scheduleTable.tBodies[0]) return; // Skip if table has no header or body
                
                const scheduleHeaders = Array.from(scheduleTable.tHead.rows[0].cells).map(th => String(th.textContent||'').trim());
                
                Array.from(scheduleTable.tBodies[0].rows).forEach((scheduleDataRow) => {
                    const classIdentifier = String(scheduleDataRow.cells[0]?.textContent||'').trim(); // e.g., "5S1"
                    if (!classIdentifier) return; // Skip if no class identifier

                    for (let cellIdx = 1; cellIdx < scheduleDataRow.cells.length; cellIdx++) { // Iterate over time slots in this row
                        const scheduleCell = scheduleDataRow.cells[cellIdx];
                        let entryInScheduleCellFull = String(scheduleCell.querySelector('.merged-cell-overlay')?.textContent || scheduleCell.textContent||'').trim();
                        let actualEntryForSummary = getTextForSummary(entryInScheduleCellFull); // e.g., "JAMES" from "JAMES *ReportDue"

                        if (actualEntryForSummary) { // If there's a name/subject scheduled
                            let scheduleColumnHeaderForThisCell = scheduleHeaders[cellIdx]; // e.g., "09:00"
                            if (!scheduleColumnHeaderForThisCell) continue; // Skip if no header for this cell

                            // Apply LAU/LISAH rule: shift to 10.15-10.30 if in 10.30-12.00
                            let summaryColumnToUse = scheduleColumnHeaderForThisCell; 
                            const specialNamesForRule = ["LAU", "LISAH"];
                            const targetSlotForSpecialNamesRule = "10.15-10.30";
                            const sourceSlotToShiftRule = "10.30-12.00";
                            if (specialNamesForRule.includes(actualEntryForSummary) && 
                                scheduleColumnHeaderForThisCell.replace(/\s/g, "").replace(/:/g,".") === sourceSlotToShiftRule.replace(/\s/g, "").replace(/:/g,".")) {
                                summaryColumnToUse = targetSlotForSpecialNamesRule; 
                            }

                            // Find the row in the summary table for this name/subject
                            const targetSummaryRow = Array.from(summaryBody.rows).find(sr => String(sr.cells[0]?.textContent||'') === actualEntryForSummary);
                            if (targetSummaryRow?.cells.length > 1) { // If name row exists
                                // Find the column index in the summary table for this time slot
                                const normalizedSummaryColumnToUse = summaryColumnToUse.replace(/\s/g, "").replace(/:/g,".");
                                const targetSummaryColumnCellIndex = normalizedSummaryHeadersForLookup.indexOf(normalizedSummaryColumnToUse);
                                
                                if (targetSummaryColumnCellIndex > 0) { // If time slot column exists in summary
                                    const summaryCellToUpdate = targetSummaryRow.cells[targetSummaryColumnCellIndex];
                                    let existingClasses = summaryCellToUpdate.textContent.trim() ? summaryCellToUpdate.textContent.trim().split(',').map(s => s.trim()) : [];
                                    if (!existingClasses.includes(classIdentifier)) {
                                        existingClasses.push(classIdentifier);
                                        // Sort classes alphabetically before joining
                                        summaryCellToUpdate.textContent = existingClasses.sort((a,b) => String(a).localeCompare(String(b), undefined, { sensitivity: 'base' })).join(', ');
                                    }
                                }
                            }
                        }
                    }
                });
            });
        }

        // Highlight conflicts (cells with multiple classes)
        Array.from(summaryBody.rows).forEach(summaryRow => {
            if (summaryRow.cells.length > 1) Array.from(summaryRow.cells).forEach((cell, cellIndex) => {
                if (cellIndex > 0 && cell.textContent.includes(',')) cell.classList.add('highlight-conflict');
            });
        });
    }
</script>
</body>
</html>
